[[system]]
== System and privileged architecture (v0.3)

This chapter defines the v0.3 privileged architecture: Access Control Rings (ACR), privileged system registers
(SSR), and the trap envelope for exceptions and interrupts.

Where platform-specific details are required, the chapter notes this with [PLATFORM] markers. See Linux bring-up status for implementation progress.

[[system-acr]]
=== Access Control Rings (ACR)

Linx partitions privileged state using **Access Control Rings** (**ACR**). The architecture defines up to **16**
rings, named **ACR0..ACR15**.

Bring-up conventions (v0.3):

* On reset, an LXCPU starts executing in **ACR0**.
* **ACR0 is the root / most privileged** ring. Rings with larger numeric IDs MAY be used for progressively less
  privileged software roles; the set of implemented rings is profile-defined.
* Every LXCPU executes at exactly one active ACR at a time (recorded in `CSTATE.ACR`).
* Some privileged SSRs are **ACR-scoped** (banked per ring). In this manual those registers are written with an
  `*_ACRn` suffix.

Informative software role mapping (v0.3):

[%header,cols="1,4"]
|===
|ACR |Role

|`ACR0` |Root management privilege (firmware / bring-up monitor / initialization).
|`ACR1` |Main system privilege (host OS or hypervisor).
|`ACR2` |Main system user privilege (host user programs).
|`ACR3` |Guest OS system privilege.
|`ACR4` |Guest user privilege.
|===

[[system-acr-tree]]
==== ACR tree and comparability

Implemented ACRs are organized as a **tree rooted at ACR0**. ACR privilege is a partial order:

* A parent node is **more privileged** than its children.
* Two ACRs are **comparable** if they are the same node, or one is an ancestor of the other.
* Two ACRs on different branches are **incomparable**.

This manual uses the following notation for comparable rings:

* `n p> m` means ACR`n` is *more privileged* than ACR`m`.
* `n p>= m` means ACR`n` is *more privileged than or equal to* ACR`m`.
* `n p= m` means ACR`n` and ACR`m` have equal privilege (same node).

ACR transitions MUST occur only between **comparable** rings.

[[system-transitions]]
=== Privilege transitions

An LXCPU's active ACR may change only due to one of the following events:

* an external interrupt,
* an internal synchronous exception,
* commit of an `ACRE` instruction (requests `ACR_ENTER`),
* commit of an `ACRC` instruction (requests `SERVICE_REQUEST`), or
* prepare/commit of a **system-call block** (bring-up mechanism).

The bring-up model distinguishes:

* **Instruction-level switches** (`ACR_ENTER` and `SERVICE_REQUEST`).
* **System-call-block switches**, where the caller temporarily executes a block in the callee ACR and then returns to
  the caller ACR on block commit.

[[system-acr-enter]]
==== ACR enter (`ACR_ENTER`, via `ACRE`)

`ACRE` requests an **ACR enter** transition. The request is taken at **block commit**, and `ACRE` MUST be the **last**
instruction in its block.

Target selection (bring-up):

* When executed in ACR`n`, `ACRE` reads the target ring from `ECSTATE_ACRn.ACR`.
* The target ring MUST be comparable with ACR`n` and MUST satisfy `n p>= ECSTATE_ACRn.ACR`. If not, the transition
  request MUST trap with `E_INST(EC_PARAM)`.

Return-request argument (RRA):

* `ACRE` encodes an immediate `RRA_Type` that controls state restoration.
* `RRA_Type=RRAT_DEFAULT(0)`: the block-engine state (`BSTATE`) is reset to its default state.
* `RRA_Type=RRAT_RESTORE(1)`: `BSTATE` is restored from exception state (`EBSTATE`).
* Other values are reserved and MUST trap with `E_INST(EC_ILLEGAL)`.

`ACR_ENTER` state restoration (v0.2 bring-up profile):

1. `CSTATE` is restored from `ECSTATE_ACRn` (all architecturally defined fields).
2. `BPC` is restored from `EBARG_BPC_CUR_ACRn` (in the managing ring's EBARG group; see <<ssr-ebarg>>).
3. If `ECSTATE_ACRn.BI = 1`, the body resume `TPC` is restored from `EBARG_TPC_ACRn` and execution resumes at that
   instruction address; otherwise execution resumes at the block start (`BPC`).
4. If `RRA_Type=RRAT_RESTORE`, block-engine state (`BSTATE`) is restored from profile-defined storage (see
   <<system-bstate-ebstate>>), and the architectural block snapshot (`BARG` + `LPR`) is restored from EBARG.

NOTE: The precise storage and format of `EBSTATE` for complex block types is profile-defined. See
<<system-bstate-ebstate>>.

[[system-service-request]]
==== Service request (`SERVICE_REQUEST`)

`SERVICE_REQUEST` is the bring-up trap entry mechanism used to transfer control from a managed ring to a managing
ring.

Triggers:

* commit of an `ACRC` instruction (software-initiated request),
* a synchronous exception detected by the execution pipeline, or
* an asynchronous interrupt.

Terminology:

* A synchronous `SERVICE_REQUEST` is a **SYNC_SERVICE_REQUEST**.
* An asynchronous interrupt-driven `SERVICE_REQUEST` is an **ASYNC_SERVICE_REQUEST**.
* The instruction location that triggers a `SERVICE_REQUEST` is the **trap source instruction**, identified by the
  pair (`BPC`, `TPC`) at the time of the event.

The trap number and cause are reported in `TRAPNO_ACRm` and the trap argument is reported in `TRAPARG0_ACRm` (see
<<ssr-acr-scoped>>).

NOTE: Not all exceptions invoke `SERVICE_REQUEST`. If an exception occurs in an unmanaged fixup block, it is handled
according to the fixup block definition.

[[system-service-request-flow]]
===== Trap entry flow (v0.2 bring-up profile)

For a `SERVICE_REQUEST` routed from ACR`n` to managing ring ACR`m`, the architecture performs the following steps as a
single internal action (no intervening architectural events may occur):

1. If the event is a floating-point exception, update the corresponding sticky flags in `CSTATE` / `FCSR` as defined
   by the profile. In v0.2 bring-up, floating-point exceptions do not trap.
2. Save `CSTATE` into `ECSTATE_ACRm`.
  * Set `ECSTATE_ACRm.BI = 0` if the trap source is in the block header (a block start marker or a `B.*` header
    descriptor) and the trap is taken while executing the header stream; otherwise set `ECSTATE_ACRm.BI = 1` (trap
    in a block body, a decoupled out-of-line body, or a template-generated micro-op stream).
3. Save the trap source block snapshot into the managing ring's **EBARG group** (`0xnf40..`; see <<ssr-ebarg>>):
  * `EBARG_BPC_CUR_ACRm` = trap source block start (`BPC`).
  * `EBARG_BPC_TGT_ACRm` = trap source next-block PC (`BPC.TGT`) as selected by the block header.
  * `EBARG_TPC_ACRm` = resume PC when `BI=1`:
    ** for faults that must be retried: the faulting instruction PC (precise exception),
    ** for traps that must be skipped (e.g. `ACRC`, breakpoints/watchpoints): the following instruction PC.
  * Copy any block-local queues and loop/context state required by the profile (e.g. `TQ`/`UQ`, `LB*`/`LC*`).
+
. Disable interrupts by clearing `CSTATE.I = 0`.
. Update the active ring to the managing ring by setting `CSTATE.ACR = m`.
. Reset `BARG` to its architectural initial state.
. Vector control to the trap handler by setting `BPC = EVBASE_ACRm`.
. Populate trap reporting registers:
  * For a SYNC_SERVICE_REQUEST: set `TRAPNO_ACRm.E = 0`, then write `TRAPNO_ACRm` / `TRAPARG0_ACRm`.
  * For an ASYNC_SERVICE_REQUEST: set `TRAPNO_ACRm.E = 1`, then write `TRAPNO_ACRm`/`TRAPARG0_ACRm` according to the
    interrupt source definition.

NOTE: The bring-up profile specifies `BPC` vectoring explicitly. At the start of the trap handler block, `TPC` is expected
to equal `BPC` (see <<progmodel-pc>>).

[[system-trap-routing]]
===== Routing rules (v0.2 bring-up profile)

`SERVICE_REQUEST` routing is profile-defined for interrupts. The bring-up profile defines the following routing rules for
software requests and for synchronous exceptions:

* `ACRC` routing (see <<system-acrc>>).
* Default exception routing (see <<system-exception-routing>>).

[[system-acrc]]
====== Software service request (`ACRC`)

`ACRC` requests a `SERVICE_REQUEST` and triggers a synchronous trap **immediately after it executes** (it does not wait
for block commit).

Bring-up restriction (v0.2): `ACRC` MUST be followed by an explicit block terminator (`BSTOP` / `C.BSTOP`) in the same
block so that the saved resume `TPC` can deterministically point at the terminator.

Assembly syntax:

* `acrc request_type`

Valid `request_type` encodings (bring-up):

* When executed in **ACR1**:
  - `SCT_MAC(0)`: machine request ( routed to BIOS/firmware services).
  - `SCT_SEC(2)`: security request ( routed to security services).
* When executed in **ACR2**:
  - `SCT_MAC(0)`: machine request.
  - `SCT_SYS(1)`: system call (a user-to-OS request).
  - `SCT_SEC(2)`: security request.
* In other ACRs, all `request_type` values are invalid.

Routing (bring-up):

* `ACR2` + `SCT_SYS` routes to **ACR1**.
* All other valid `request_type` values route to **ACR0**.
* Invalid encodings MUST trap with `E_INST(EC_ILLEGAL)`.
* Control-flow integrity violations MUST trap with `E_BLOCK(EC_CFI)`:
  - architectural control flow into the interior of a coupled block body, or
  - architectural control flow to an engine-internal entrypoint (e.g. decoupled `BodyTPC` or a vector-body `B.TEXT` target) via architectural control flow, or
  - fallthrough/linear-stream execution expects a block start marker but the next linear instruction is not a valid block start marker.
+
+Cause encoding (bring-up normative):
+
+* `EC_CFI = 0x1` within the `E_BLOCK` cause space.
+* `TRAPNO_ACRm.CAUSE[3:0]` = `EC_CFI_KIND` (4-bit subcause) when `E_BLOCK(EC_CFI)` is reported.
+* `TRAPNO_ACRm.CAUSE[7:4]` is reserved for future CFI subkind and MUST be `0`.
+* `EC_CFI_KIND` mapping:
+  - `0`: reserved
+  - `1`: `CFI_BAD_TARGET` (direct/indirect/ret target is not a block start marker)
+  - `2`: reserved
+  - `3`: `CFI_MISSING_NEXT_MARKER` (fallthrough expected but next linear instruction is not a block start marker)
+  - `4`: reserved
+
+Reporting (bring-up):
+
+* `TRAPARG0_ACRm` MUST be set to the **source PC/TPC** of the control-flow instruction (or boundary marker) that triggered the CFI violation.
+* `ECSTATE_ACRm.BI` MUST be set to `0` (treat as a header/control-flow legality failure).
+* Precision: `E_BLOCK(EC_CFI)` is **precise** — no architectural state changes from the offending control-flow instruction are committed.
+* Resume PC: `EBARG_TPC_ACRm` is profile-defined/handler-defined for `E_BLOCK(EC_CFI)`.
+
+* Template replay flags (bring-up): implementations SHOULD expose a single EBARG register `EBARG_TPLFLAGS_ACRm` with template trap/replay flags.
+  - Bitfields (widths/encodings TBD): `TPL_VALID`, `TPL_ID_PRESENT` + `TPL_ID`, `TPL_PHASE`, `TPL_DIRTY`, `TPL_REDO_OK`, `TPL_RESUME_OK`.
    - `TPL_ID` for marker templates (`TemplateKind.class=0`) uses the mnemonic-enum mapping in <<templates-tplid>>.
    - For marker templates (`TemplateKind.class=0`), `TPL_ID_PRESENT` MUST be `1` (reporting is required).
    - For TEPL templates (`TemplateKind.class=1`), `TPL_ID_PRESENT` MUST be `1` and `TPL_ID` MUST carry the raw `TileOp10` selector.
+    - `TPL_REDO_OK=1`: handler may restart the template from the beginning (no externally visible partial side effects).
+    - `TPL_RESUME_OK=1`: template supports/permits resume via `EBSTATE` snapshot (template-defined FSM/cursors). Templates that may commit to memory mid-execution MUST set `TPL_REDO_OK=0` and `TPL_RESUME_OK=1`.
+  - `TPL_PHASE` standard meanings:
+    - `0`: decode/validate
+    - `1`: executing
+    - `2`: finishing/commit
+    - `3`: reserved
+  - For `FENTRY`/`FEXIT`/`FRET.*` templates, the expanded uop stream (including `SETC_TGT`) is `TPL_PHASE=1`; `TPL_PHASE=2` is reserved for the final completion/commit boundary cycle.
+  - `TPL_DIRTY` MUST be set once any template uop executes / internal template state advances.
+  - For `FENTRY`/`FEXIT`/`FRET.*` templates:
+    - once `TPL_PHASE>=1`, `TPL_REDO_OK` MUST be `0` (redo-from-beginning is not permitted after execution begins).
+    - once `TPL_PHASE>=1`, `TPL_RESUME_OK` MUST be `1` (resume via EBSTATE is required).
+  - TEPL templates (`TemplateKind.class=1` / `BSTART.TEPL`) are accelerator-driven (not uop-expanded).
+    - `TPL_PHASE` for TEPL is TileOp10-defined but MUST respect the top-level meanings; `TPL_PHASE=0` is decode/validate only and MUST NOT be used once execution begins.
+    - `TPL_REDO_OK` MUST be `0` once execution begins.
+    - `TPL_RESUME_OK` is TileOp10-defined.
+    - `TPL_DIRTY` is set if the TEPL engine state actually progresses and requires restore.
+    - `ECSTATE.BI` for TEPL traps: `BI=0` when `TPL_PHASE=0`, and `BI=1` when `TPL_PHASE=1/2`.
+  - Canonical resume cursor: `BSTATE.Template.StepIndex` is the architectural micro-op progress cursor for template replay.
+  - Template-specific fine-grain subphase/state for replay belongs in `EBSTATE` (template-defined).
+
+* Block-format validation failures (missing/invalid mandatory descriptors) MUST trap with `E_BLOCK(EC_BLOCKFMT)`.
  - Cause encoding (bring-up normative): `EC_BLOCKFMT = 0x2` within the `E_BLOCK` cause space.

* Block body fetch faults (for decoupled bodies and `B.TEXT` vector bodies) are split into:
  - **MMU translation/access faults** while fetching/executing a body stream: MUST raise `E_DATA` (with `TRAPARG0` set to the faulting VA) and are handled using the normal data-fault routing.
    * The trap context MUST still indicate body execution (`BI=1` and `BSTATE.Common.InBody=1` where applicable) so software can resume correctly.
  - **Non-MMU body-fetch faults** (e.g. misaligned body entrypoint): MUST trap with `E_BLOCK(EC_BFETCH)`.
    * Cause encoding (bring-up normative): `EC_BFETCH = 0x3` within the `E_BLOCK` cause space.
    * Reporting (bring-up): `TRAPARG0_ACRm` MUST be set to the faulting body-fetch virtual address.
    * `ECSTATE_ACRm.BI` MUST be `1`.
    * The fault is **precise** and **fatal** (non-restartable): software MUST NOT attempt to resume execution from the faulting body entrypoint; treat as an unrecoverable codegen/format error.

NOTE: Restartable body-fetch faults are represented by the underlying MMU translation/access faults (`E_DATA`) taken while `BI=1` (body context).
  - Missing-descriptor reporting uses `TRAPARG0_ACRm`:
    - `TRAPARG0[7:0] = MissingDescFamily`
      - `0 = B.* (generic descriptor stream / non-family-specific)`
      - `1 = B.DIM`
      - `2 = B.TEXT`
      - `3 = B.ARG`
      - `4 = B.IOR`
      - `5 = B.IOT/B.IOTI`
    - `TRAPARG0[15:8] = MissingDetail` (standard meanings):
      - `0x00`: family missing
      - `0x01`: family present but value invalid/out-of-range
      - `0x02`: family present but illegal combination (conflicting descriptors)
      - `0x03..0xFF`: reserved for op/template-specific detail
    - upper bits reserved `0`
  - If multiple mandatory descriptor families are missing, implementations MUST report exactly one missing family.
    The reporting priority order is:
    1. `B.ARG`
    2. `B.TEXT`
    3. `B.IOT/B.IOTI`
    4. `B.IOR`
    5. `B.DIM`
  - Validation timing: missing/invalid mandatory descriptors MUST be detected during header validation before any block
    side effects (no body execution / no memory ops).
  - `ECSTATE_ACRm.BI = 0` and the trap is **precise**.

* Other invalid instruction/control-flow encodings that do not match the above CFI cases MUST trap with `E_INST(EC_ILLEGAL)` unless otherwise specified.

[[system-trap-resume]]
====== Resuming after a software request (redo vs advance)

On `ACRC`, hardware saves the trap source snapshot into the managing ring's EBARG group (see <<ssr-ebarg>>). In
particular, it sets `ECSTATE_ACRm.BI = 1` and sets `EBARG_TPC_ACRm` to the following instruction PC (bring-up: the
explicit `BSTOP`).

Software may choose how execution resumes when it later uses `ACRE` to return:

* **Redo** the `ACRC`: rewrite `EBARG_TPC_ACRm` to the `ACRC` instruction address.
* **Advance** to the next instruction: leave `EBARG_TPC_ACRm` as captured (the following instruction PC).

[[system-exception-routing]]
====== Default exception routing

The bring-up profile defines the following default managing ring selection for synchronous exceptions:

[%header,cols="2,1,1,1,1"]
|===
|Exception class |Trap number |If executing in ACR0 |If executing in ACR1 |If executing in ACR2

|Instruction-related |`E_INST` |ACR0 |ACR1 |ACR1
|Data access-related |`E_DATA` |ACR0 |ACR1 |ACR1
|Block-format-related |`E_BLOCK` |ACR0 |ACR1 |ACR1
|Assert |`E_ASSERT` |ACR0 |ACR1 |ACR1
|Breakpoint |`E_BREAKPOINT` |ACR0 |ACR1 |ACR1
|Illegal SSR access |`E_ISSR` |ACR0 |ACR1 |ACR1
|===

For system calls (`TRAPNUM=SCALL` in v0.2), routing is defined by the `ACRC` `request_type` rules above.

[[system-bstate-ebstate]]
=== Block engine state (`BSTATE` / `EBSTATE`)

A block execution unit may maintain internal state beyond the first-layer architectural state. The bring-up profile
names this internal per-block state **BSTATE**.

In v0.2 bring-up, `BSTATE` is treated as the union of:

* `BARG` (block arguments / commit metadata), and
* `LPR` (software-visible local purpose registers, including local queues and block-local execution context).

* `CSTATE` is **not** part of `BSTATE`; it is first-layer architectural state.
* `EBSTATE` is the storage used to save/restore `BSTATE` during trap handling.

Trap save/restore for scalar block types (`STD`, `SYS`, `FP`) is implemented using the **EBARG group** (see
<<ssr-ebarg>>). EBARG is the authoritative trap snapshot for v0.2:

* save `BPC.CUR`/`BPC.TGT` → `EBARG_BPC_CUR_ACRm` / `EBARG_BPC_TGT_ACRm`
* save resume `TPC` (when `BI=1`) → `EBARG_TPC_ACRm`
* save queues/context → `EBARG_TQ*` / `EBARG_UQ*` / `EBARG_LB` / `EBARG_LC`

For complex block types (`VPAR`, `VSEQ`, `MPAR`, `MSEQ`), the bring-up profile additionally records a profile-defined
group/context identity in EBARG (see <<ssr-ebarg>>). The bulk storage and restoration of other block-engine state is
profile-defined (e.g. via tile registers and/or memory).

Dirty vs clean `BSTATE` (bring-up):

* If a `SERVICE_REQUEST` interrupts a block while its `BSTATE` has been modified but not committed, the `BSTATE` is
  **dirty**.
* If `BSTATE` is dirty, the implementation saves it into the selected `EBSTATE` storage and sets `CSTATE.ebv = 1`.
  - Completeness requirement (bring-up): when `ACRE RRAT_RESTORE` is used, the saved `EBSTATE` snapshot MUST be **complete and internally consistent** for replay/resume (no partial snapshots).
* If `BSTATE` is clean, `EBSTATE` storage remains unchanged and `CSTATE.ebv = 0`.

[[system-bstate-bi]]
==== `BI` (trap location: header vs body)

`ECSTATE_ACRm.BI` reports whether a trap interrupted **block header execution** or **block body execution**:

* `BI = 0`: trap while executing the block header stream (block start marker or `B.*` header descriptor).
* `BI = 1`: trap while executing a block body, including:
** any instruction in a coupled block body (non-header instruction),
** any instruction in a decoupled out-of-line body (see <<blockisa-forms-decoupled>>),
** any template-generated micro-op stream (see <<templates-restart>>).

For template blocks, traps caused by decode/validation of the template instruction itself (e.g. illegal encoding)
SHOULD set `BI = 0`, while traps taken after template execution has begun (during generated micro-ops) MUST set
`BI = 1`.

[[system-bstate-min]]
==== Minimum required `BSTATE` / `EBSTATE` contents (v0.2 bring-up profile)

Implementations targeting the v0.2 bring-up profile MUST implement at least the following `BSTATE` fields and MUST
save/restore them via `EBSTATE` when `BSTATE` is dirty and `ACRE RRAT_RESTORE` is used.

Unless otherwise specified, fields are **XLEN** wide. Addresses are byte addresses.

* `BSTATE.Common` (all block types):
** `InBody`: whether execution is currently in a decoupled out-of-line body or in a template micro-op stream.
** `BodyTPC`: body entrypoint (`B.TEXT` target) for decoupled blocks (valid when `InBody=1` for decoupled blocks).
** `ReturnTPC`: header continuation address for decoupled blocks (valid when `InBody=1` for decoupled blocks).
** `BlockType`: the current block type.
* `BSTATE.Vector` (vector block types such as `VPAR`/`VSEQ`):
** `GroupID`: the current group ID.
** `GroupTPC`: the per-group Temporary PC (`TPC`) for the currently executing/faulting group stream.
** `ActiveMask`: the active-lane mask (may be fixed in early bring-up).
* `BSTATE.Template` (template blocks such as `FENTRY`/`FEXIT`/`FRET.*`/`MCOPY`/`MSET`):
** `TemplateKind`: which template is executing (packed `class,id`).
*** `class=0`: marker/template opcodes (`FENTRY`/`FEXIT`/`FRET.*`/`MCOPY`/`MSET`/...) with `id` = opcode-specific enum.
*** `class=1`: `BSTART.TEPL` templates with `id` = `TileOp10` (0..1023).
*** `class=2`: reserved for future (implementation-defined templates).
*** `class=3`: reserved.
** `StepIndex`: micro-op progress cursor.
** `RemainingCount`: remaining element/iteration count (template-defined).
** `CursorAddr`: current memory cursor address (template-defined).
** `RegCursor`: current register/cursor selector (template-defined).
* `BSTATE.TMA` (`TMA`-class blocks):
** `TransferCursor`: current transfer cursor (implementation-defined).
** `RemainingBytes` and/or `RemainingRows`: remaining transfer size (implementation-defined).
** `FaultRestartInfo`: sufficient information to restart after a translation or access fault.

[[system-ssr]]
=== Privileged system registers (SSR)

The privileged trap envelope is defined around a set of **manager-ACR SSR families** (see <<ssr-acr-scoped>>):

* `ECSTATE_ACRn` mirrors key `CSTATE` fields and records whether a trap interrupted the block body (`BI`).
* `EVBASE_ACRn` selects the exception/interrupt handler vector base for the managing ring.
* `TRAPNO_ACRn` / `TRAPARG0_ACRn` report the trap number/cause and argument.
* `EBARG_*_ACRn` (EBARG group) saves the trap source snapshot for later recovery.

These SSRs use IDs of the form `0xnfxx` and are visible in the global SSR ID space. In the bring-up privilege model they
MUST be accessible from ACR0 and ACR1; other ACRs may ignore accesses or may trap with `E_ISSR`.

[[system-mm]]
=== Memory management (TTBR0/TTBR1) and IOMMU (v0.2 bring-up profile)

This section defines the v0.2 bring-up MMU and IOMMU contract. It uses an **ARM-inspired TTBR0/TTBR1 split** for the
CPU MMU, while keeping permission bits and software expectations simple.

Unless stated otherwise, the configuration registers in this section are ACR-scoped privileged SSRs for `ACR1` and are
accessed using `HL.SSRGET/HL.SSRSET`:

* `TTBR0_ACR1 (0x1F10)` (alias: `MMTBASE_ACR1`)
* `TTBR1_ACR1 (0x1F11)` (alias: `MMCONFIG_ACR1`)
* `TCR_ACR1 (0x1F12)`
* `MAIR_ACR1 (0x1F13)`
* `IOTTBR_ACR1 (0x1F14)`
* `IOTCR_ACR1 (0x1F15)`
* `IOMAIR_ACR1 (0x1F16)`

[[system-mm-defaults]]
==== Addressing defaults

v0.2 bring-up defaults:

* Endianness: little.
* Page granule: 4 KiB.
* Virtual addresses (VA): 48-bit canonical:
** bits `[63:48]` MUST replicate bit `VA[47]`,
** a non-canonical VA MUST fault (treated as a translation fault).
* Region select (CPU MMU): `VA[47]=0` selects `TTBR0`, `VA[47]=1` selects `TTBR1`.
* Physical addresses (PA): 48-bit. Bits above PA[47] are reserved and MUST be zero in translation results.

[[system-mm-ttbr]]
==== `TTBR0_ACR1` / `TTBR1_ACR1` layout (64-bit)

`TTBR0_ACR1` (v0.2):

* `[63:48] ASID` — address-space ID used to tag `TTBR0` translations.
* `[47:12] BasePA` — physical base address of the level-0 translation table (4 KiB aligned).
* `[11:0]` — reserved, MUST be zero.

`TTBR1_ACR1` (v0.2):

* `[63:48]` — reserved, SHOULD be zero (ASID ignored in bring-up for `TTBR1`).
* `[47:12] BasePA` — physical base address of the level-0 translation table (4 KiB aligned).
* `[11:0]` — reserved, MUST be zero.

[[system-mm-tcr]]
==== `TCR_ACR1` layout (v0.2 subset)

Only the following `TCR_ACR1` fields are defined in the v0.2 bring-up profile. All other bits are reserved and MUST
be zero; any non-zero reserved bit MUST trap with `E_INST(EC_ILLEGAL)`.

* `MME` (bit 0) — MMU enable (`0`: translation disabled / identity; `1`: translation enabled).
* `T0SZ` (bits `[6:1]`) — `TTBR0` VA size offset. Default `16` (48-bit VA).
* `T1SZ` (bits `[12:7]`) — `TTBR1` VA size offset. Default `16` (48-bit VA).
* `EPD0` (bit 13) — disable `TTBR0` translation walks when set (treat as translation fault).
* `EPD1` (bit 14) — disable `TTBR1` translation walks when set (treat as translation fault).
* `A1` (bit 15) — ASID select. Fixed `0` in bring-up.

When `MME=0`, the CPU MUST perform no page-table walks and MUST treat VA as PA for instruction fetch and data access.

[[system-mm-mair]]
==== `MAIR_ACR1` layout (ARM-like, minimal)

`MAIR_ACR1` provides 8 independent 8-bit attribute encodings (`Attr0..Attr7`), packed into a 64-bit register. In v0.2,
software MUST use only `AttrIdx` values `0..2`:

* `AttrIdx=0`: Device-nGnRnE
* `AttrIdx=1`: Normal WB RA/WA
* `AttrIdx=2`: Normal NC

Other `AttrIdx` values are reserved in v0.2 and MUST fault if used in a valid translation entry.

[[system-mm-pt]]
==== Page table format (4-level, 4 KiB)

Translation uses 4 levels of 4 KiB tables (`L0/L1/L2/L3`). Each table contains 512 64-bit entries.

For 4 KiB pages with 48-bit VA, the v0.2 bring-up profile uses the following index bits:

* `L0 index` = `VA[47:39]`
* `L1 index` = `VA[38:30]`
* `L2 index` = `VA[29:21]`
* `L3 index` = `VA[20:12]`
* `page offset` = `VA[11:0]`

Descriptor type (v0.2):

* Invalid: `Desc[1:0] = 00`
* Table: `Desc[1:0] = 11` (points to next-level table)
* Block: `Desc[1:0] = 10` (maps a range at `L1` or `L2`; optional in bring-up)
* Page: `Desc[1:0] = 01` (maps a 4 KiB page at `L3`)

Table descriptor format (`Desc[1:0]=11`):

* `[47:12] NextTableBasePA` — physical base address of the next-level table (4 KiB aligned).
* `[11:2]` — reserved, MUST be zero.

Page/block descriptor format (`Desc[1:0]=01` for `L3` pages, `Desc[1:0]=10` for `L1/L2` blocks):

* `[47:12] OutputBasePA` — mapped physical base address (aligned to the mapping size).
* `[11:10]` — reserved, MUST be zero.
* `[9:7] AttrIdx` — selects an 8-bit attribute from `MAIR_ACR1`.
* `[6] AF` — access flag. If `AF=0`, the access MUST fault (the walker MAY set `AF` as an implementation choice).
* `[5] U` — user access allow.
* `[4] X` — execute allow.
* `[3] W` — write allow.
* `[2] R` — read allow.

Permission interpretation (v0.2):

* A read access requires `R=1`; otherwise a permission fault MUST be raised.
* A write access requires `W=1`; otherwise a permission fault MUST be raised.
* An instruction fetch requires `X=1`; otherwise an execute fault MUST be raised.
* If executing in `ACR2` (user), access additionally requires `U=1`; otherwise a user-access fault MUST be raised.

NOTE: For v0.2, software SHOULD assume that `Block` descriptors are not implemented unless explicitly indicated by the
platform profile (e.g. a feature bit in `LCFR`).

[[system-mm-faults]]
==== Faults and reporting

CPU translation and permission faults MUST raise a synchronous `E_DATA` exception. The faulting VA MUST be reported in
`TRAPARG0_ACRm`. The `TRAPNO_ACRm.CAUSE` encoding for these faults is profile-defined; in the v0.2 bring-up profile,
implementations SHOULD report `CAUSE=MMU_PF` for translation faults and `CAUSE=MMU_PERM` for permission faults.

[[system-iommu]]
==== IOMMU (v0.2 bring-up profile)

DMA-style engines (including `TMA` engines) MUST perform address translation using the IOMMU when enabled.

* IOVA is treated as 48-bit canonical, identical to VA.
* Translation uses `IOTTBR_ACR1`/`IOTCR_ACR1`/`IOMAIR_ACR1` and the same table format as the CPU MMU.

`IOTTBR_ACR1` layout (64-bit, v0.2):

* `[63:48]` — reserved, SHOULD be zero.
* `[47:12] BasePA` — physical base address of the level-0 IOMMU translation table (4 KiB aligned).
* `[11:0]` — reserved, MUST be zero.

`IOTCR_ACR1` layout (v0.2 subset):

* `IME` (bit 0) — IOMMU enable (`0`: identity; `1`: translate IOVA).
* `SZ` (bits `[6:1]`) — IOVA size offset. Default `16` (48-bit IOVA).
* All other bits are reserved and MUST be zero; any non-zero reserved bit MUST trap with `E_INST(EC_ILLEGAL)`.

`IOMAIR_ACR1` layout matches `MAIR_ACR1`.

IOMMU translation faults MUST raise a synchronous `E_DATA` exception with `TRAPARG0_ACRm` set to the faulting IOVA. In
the v0.2 bring-up profile, implementations SHOULD report `CAUSE=IOMMU_PF`.

==== TLB maintenance (`tlb.*`, v0.2)

The following TLB maintenance instructions are provided:

* `tlb.iv SrcL`
* `tlb.iav SrcL`
* `tlb.ia SrcL`
* `tlb.iall`

v0.2 contract (ARM-inspired):

* TLB entries are tagged with a 16-bit ASID.
* ASID selection follows `TCR_ACR1.A1`. In the v0.2 bring-up profile, `A1=0`, so the active ASID is taken from `TTBR0_ACR1[63:48]` for `TTBR0` translations (and `TTBR1` ASID is ignored).
* `tlb.*` instructions invalidate the matching cached translation entries.
  - Scope: implementations MUST broadcast the invalidation to all LXCPUs in the same platform-defined *TLB share-domain*.
  - `tlb.*` is **not** a completion/synchronization point. Software MUST use appropriate `FENCE.D` sequences (or stronger platform-defined mechanisms) to guarantee the required ordering/completion.

Operand encoding (v0.2):

* `tlb.iv SrcL`: `SrcL` contains the VA to invalidate. Implementations MUST ignore low page-offset bits (`VA[11:0]`) and invalidate at 4 KiB granularity (unaligned VAs are permitted). This operation is global with respect to ASID (i.e. matches any ASID).
* `tlb.iav SrcL`: `SrcL` contains the VA to invalidate (4 KiB granularity; low bits ignored; unaligned VAs are permitted), and the active ASID is selected per `TCR_ACR1.A1`. This operation matches only the selected ASID.
* `tlb.ia SrcL`: `SrcL[15:0]` contains the ASID to invalidate; `SrcL[63:16]` MUST be zero.
* `tlb.iall`: no operands.

Fault behavior (v0.2):

* For `tlb.iv` / `tlb.iav`, a non-canonical VA in `SrcL` MUST raise a translation fault (treated as `MMU_PF`).
* For `tlb.ia`, any non-zero reserved bit in `SrcL[63:16]` MUST trap as `E_INST(EC_ILLEGAL)`.
* Executing any `tlb.*` instruction from an unprivileged managing ring (bring-up: `ACR2`) MUST trap as `E_INST` with a cause indicating *privileged instruction*.

Recommended software sequences (ordering + completion):

The `tlb.*` instructions are not synchronization points, so software MUST surround them with fences sufficient to:
(1) ensure page-table writes are visible before invalidation takes effect, and
(2) ensure that subsequent accesses do not use stale translations.

* Data-side page-table updates (no impact to instruction fetch):
  . `FENCE.D RW,RW`
  . `tlb.iav SrcL` (preferred when invalidating one VA within the active ASID) OR `tlb.ia SrcL` / `tlb.iall` as appropriate
  . `FENCE.D RW,RW`

* Page-table updates that may impact instruction fetch (e.g., changing `X`, remapping executable pages, or changing fetch-relevant attributes):
  . `FENCE.D RW,RW`
  . `tlb.*` as appropriate
  . `FENCE.D I,I`

NOTE: For per-VA invalidation, software SHOULD prefer `tlb.iav` over `tlb.iv` to avoid invalidating translations for other ASIDs.

[[system-timers]]
=== Timers and counters

The base SSR namespace includes timer/counter registers such as `TIME` and `CYCLE` (see <<ssr-table>>). Privileged
timer programming uses `TIMER_TIME_ACRn` / `TIMER_TIMECMP_ACRn` (see <<ssr-acr-scoped>>).

[[system-debug]]
=== Debug and break

`EBREAK` is an execution-control instruction intended for debugging and bring-up. Its trap/debug entry behavior is
profile-defined.

[[system-todos]]
=== Platform-Specific Requirements (privileged architecture)

The following items require platform-specific or profile-specific definition for software portability:

* Interrupt definitions (Xproxy sources, IDs, priorities, and target ring routing).
* Exception/interrupt vectoring rules beyond `EVBASE` (offsets, priorities, nesting).
* Precise state rules on trap entry for each block type (what is committed/rolled back, and EBSTATE storage formats).
* System-call block calling convention details and cross-ring return/repair rules.

[NOTE]
====
These items are actively being defined as part of the LinxISA v0.3 privileged architecture development.
See the Linux bring-up status (`~/linux/Documentation/linxisa/bringup-status.md`) for implementation progress.
====
