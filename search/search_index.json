{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LinxISA Documentation","text":"<p>This site is built from the LinxISA superproject repository: LinxISA/linx-isa.</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting Started</li> <li>ISA v0.3 Architecture Contract</li> <li>Bring-up Progress</li> <li>ISA Manual (PDF, v0.3.0)</li> <li>Release Notes</li> </ul>"},{"location":"architecture/","title":"Architecture Docs","text":"<p>Architecture-facing documentation:</p> <ul> <li><code>docs/architecture/isa-manual/</code></li> <li>AsciiDoc ISA manual source and generated PDF.</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/","title":"LinxCore Unified AI + Rendering (GPU-class) Co-Design Draft","text":"<p>Status: draft / working doc</p> <p>Goal: define a software+hardware co-design that lets LinxISA + LinxCore run - AI applications (inference first, training later) - graphics rendering (Vulkan/OpenGL)</p> <p>by compiling shader/compute kernels to a Linx SIMT model deployed onto a vector (VEC) execution backend, while hardening selected hot paths into dedicated LinxCore \u201cengines\u201d.</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#0-design-goals-what-gpu-class-means","title":"0. Design goals (what \u201cGPU-class\u201d means)","text":""},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#goals","title":"Goals","text":"<ul> <li>One ISA + one runtime model to serve both graphics + AI compute.</li> <li>Vulkan as the primary user-facing ABI (graphics + compute).</li> <li>Support OpenGL via Zink (OpenGL-on-Vulkan) if acceptable.</li> <li>Compiler pipeline: SPIR-V \u2192 NIR \u2192 LinxSIMT IR \u2192 LinxVEC uops.</li> <li>Hardware: add/extend LinxCore with a command processor + shader/compute core + fixed-function engines.</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#non-goals-initially","title":"Non-goals (initially)","text":"<ul> <li>Perfect parity with a top-tier discrete GPU across all workloads.</li> <li>Full DirectX user-mode stack.</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#performance-reality-check","title":"Performance reality check","text":"<p>\u201cNot worse than GPU\u201d is only achievable if we define (and measure) a baseline: - baseline GPU compute core model (e.g. NVIDIA SM, AMD CU/WGP, Apple GPU core) and the per-core throughput we want to match - target workloads (AI: GEMM/conv/attn? graphics: forward? deferred? RT?) - per-core memory hierarchy targets (register file + L1/texture + LDS/shared) and the chip-level bandwidth / power / area envelope</p> <p>Assumption from discussion: we are designing a core comparable to a GPU SM, and scaling out via many cores to form a new-style GPGPU.</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#1-proposed-top-level-stack","title":"1. Proposed top-level stack","text":""},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#11-user-facing-apis","title":"1.1 User-facing APIs","text":"<ul> <li>Vulkan: primary graphics+compute API.</li> <li>OpenGL (optional): via Mesa Zink (Gallium OpenGL frontend \u2192 Vulkan).</li> <li>Advantage: avoid writing a full OpenGL driver; focus on Vulkan + compute.</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#12-user-mode-driver-plan-mesa","title":"1.2 User-mode driver plan (Mesa)","text":"<p>Use Mesa (now vendored as <code>lib/mesa3d</code>) and add a Linx Vulkan driver: - Mesa areas you\u2019ll touch:   - <code>src/vulkan/</code> (common Vulkan runtime, WSI, layers/util)   - <code>src/compiler/spirv/</code> (SPIR-V parsing \u2192 NIR)   - <code>src/compiler/nir/</code> (NIR IR + optimizations)   - (optional) <code>src/gallium/drivers/zink/</code> (OpenGL-on-Vulkan)</p> <p>Create a new driver namespace (exact location TBD; typical patterns are vendor directories): - <code>src/linx/vulkan/</code> or <code>src/vulkan/drivers/linx/</code> (depends on Mesa conventions)</p> <p>Deliverables: - <code>libvulkan_linx.so</code> ICD (Mesa) - WSI path for Linux (DRM/KMS + Wayland/X11 as needed)</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#13-kernel-driver-plan-linux-drm","title":"1.3 Kernel driver plan (Linux DRM)","text":"<p>A Linx GPU/NPU kernel driver providing: - memory management (GEM/TTM or modern equivalent) - submission queues - sync primitives (timeline semaphores/fences) - perf counters + debugging IOCTLs</p> <p>This enables: - Mesa Vulkan ICD talks to DRM - user-space apps use standard Vulkan loader</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#2-execution-model-build-on-linxisa-v03-simt-vector-blocks","title":"2. Execution model: build on LinxISA v0.3 SIMT vector blocks","text":"<p>LinxISA already defines SIMT-style execution via vector block types (<code>MSEQ/MPAR/VSEQ/VPAR</code>) rather than a separate \u201cGPU mode\u201d.</p> <p>Reference notes: <code>docs/architecture/research/linxisa-v0.3-simt-vector-model.md</code></p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#21-the-core-idea-isa-grounded","title":"2.1 The core idea (ISA-grounded)","text":"<ul> <li>Programmer-visible model: SIMT expressed as a one-lane body replayed over a lane space.</li> <li>Hardware backend: implement that replay efficiently on VEC pipelines.</li> </ul> <p>Architectural mapping (strict v0.3): - Lane space is defined by <code>LB0..LB2</code> (written by <code>B.DIM</code>), with lane counters <code>lc0..lc2</code> visible in the body. - Canonical 1-D lowering:   - <code>LB0 = lane_count</code> (lanes per group)   - <code>LB1 = group_count</code>   - linear lane index = <code>lc0 + lc1 * lane_count</code> - Scalar instructions in a vector body are uniform per group (execute once per group replay), while vector instructions operate in the lane domain.</p> <p>Execution families: - <code>MSEQ/MPAR</code>: may use bridged global memory (<code>*.brg</code>) via the tile/TMA path. - <code>VSEQ/VPAR</code>: tile-only (must not use <code>*.brg</code>).</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#211-proposed-linxgpgpu-group-warp-like-microarchitecture","title":"2.1.1 Proposed LinxGPGPU group (warp-like) microarchitecture","text":"<p>Assumption (from current design direction): - One group (\u2248 NVIDIA warp concept) consists of:   - 64 vector lanes, each lane is primarily 32-bit datapath   - 1 scalar-uniform lane (per group), 64-bit datapath   - a 64-bit predicate/mask used by the scalar lane to control the group\u2019s control flow / lane activity</p> <p>Mapping to LinxISA semantics: - Set <code>LB0 = 64</code> for <code>lane_count</code>. - Use <code>lc0</code> as the lane id in <code>[0..63]</code>. - Use <code>lc1</code> as the group id (warp id) when multiple groups are dispatched (<code>LB1 = group_count</code>).</p> <p>Important contract alignment: - This is consistent with strict v0.3\u2019s \u201cscalar-uniform per group\u201d rule. - We must explicitly define how the 64-bit lane mask interacts with v0.3\u2019s inactive-lane policy (<code>merge</code> vs <code>zero</code>) and how it is set/updated by the shader compiler/runtime.</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#22-lb0-lane_count-policy-vec-width","title":"2.2 <code>LB0</code> lane_count policy &amp; VEC width","text":"<p>Critical decisions (implementation policy; ISA allows variability): - Choose a lane_count policy (<code>LB0</code>, lanes per group). Common candidates: 8/16/32/64. - Choose a VEC width (lanes per cycle) and how many VEC pipes per core.</p> <p>Rules of thumb: - Larger <code>LB0</code> amortizes scalar-uniform work and improves reduction/shuffle efficiency, but increases pressure from lane divergence that must be handled via predication (lane predicate values + <code>V.CSEL</code>/<code>V.PSEL</code>). - VEC width should align with the <code>.brg</code> memory bridge/coalescing granularity and the tile-register banking scheme.</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#23-memory-execution-reality-local-vs-brg","title":"2.3 Memory execution reality: <code>.local</code> vs <code>.brg</code>","text":"<p>Architecturally, vector memory operations split into: - <code>.local</code>: tile/local direction accesses (base: <code>TA/TB/TO/TS</code>), suitable for tile engines + scratch. - <code>.brg</code>: bridged global memory accesses (base: <code>ri*</code> imported via <code>B.IOR</code>).</p> <p>Bring-up constraints: - <code>VPAR/VSEQ</code> are tile-only and MUST NOT use <code>.brg</code>. - <code>MSEQ/MPAR</code> may use <code>.brg</code> but the path is bridged through tile/TMA, so the \u201cshader core\u201d microarchitecture must treat global memory as an engine/bridge, not a free LSU.</p> <p>Implementation goal: - coalesce <code>.brg</code> accesses across lanes/groups (merge cacheline requests, handle scatter/gather efficiently, and define per-lane fault/disable behavior consistently with the restartability contracts).</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#3-hardware-partitioning-inside-linxcore-gpu-tile","title":"3. Hardware partitioning inside \u201cLinxCore GPU tile\u201d","text":"<p>Think of this as adding a GPU-like tile next to/inside LinxCore, controlled by command streams.</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#31-always-needed-engines-compute-first-baseline","title":"3.1 Always needed engines (compute-first baseline)","text":"<p>1) Command Processor (CP)    - parses command buffers, dispatches work    - integrates with LinxCore block/BID completion rules (engine_done)</p> <p>2) Shader/Compute Core (SIMT front-end + VEC back-end)    - wave scheduler    - register file(s) for vector/scalar    - VEC ALU pipelines    - LSU + coalescer    - shared memory / LDS (optional but important for performance)</p> <p>3) DMA/BLT engine    - fast copies, format conversions, clears</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#32-rendering-acceleration-engines-hardened-fixed-function","title":"3.2 Rendering acceleration engines (hardened fixed-function)","text":"<p>Add when moving from compute-only \u2192 full graphics: - Raster / tiler / binning engine (triangle setup, tile list build) - Texture engine (addressing, filtering, sampler cache) - ROP engine (depth/stencil test, blending, color writeback/compression)</p> <p>A good staged approach is: - Phase A: compute + blit (enables AI + simple compute rendering paths) - Phase B: texture engine (huge for real graphics perf) - Phase C: raster + ROP (full pipeline)</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#33-how-this-fits-linxcore-block-semantics","title":"3.3 How this fits LinxCore block semantics","text":"<p>Use LinxCore\u2019s established \u201cblock\u201d mechanism: - a block issues CP/engine commands via CMD uops - block completion:   - <code>complete = scalar_done &amp;&amp; engine_done</code> - on flush/redirect: kill younger blocks by BID (<code>bid &gt; flush_bid</code>)</p> <p>This gives you CPU-style speculation/control + long-latency engine work with clean cancellation rules.</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#4-compiler-pipeline-details-mesa-linx","title":"4. Compiler pipeline details (Mesa \u2192 Linx)","text":""},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#41-front-end-inputs","title":"4.1 Front-end inputs","text":"<ul> <li>SPIR-V for Vulkan shaders + compute kernels</li> <li>(optional) OpenCL C via clc \u2192 SPIR-V path, or MLIR \u2192 SPIR-V for AI</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#42-mid-end-nir","title":"4.2 Mid-end: NIR","text":"<p>Use NIR as the optimization hub: - algebraic opts, CSE, loop opts, vectorization/legalization passes - subgroup lowering and divergence-friendly transforms</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#43-back-end-nirspir-v-linx-vector-block-body-vec-lowering","title":"4.3 Back-end: NIR/SPIR-V \u2192 Linx vector-block body (+ VEC lowering)","text":"<p>Create/choose an internal IR that makes the Linx vector-block model explicit: - lane counters (<code>lc0..lc2</code>) and the canonical mapping to invocation IDs - group-uniform vs lane-varying values (scalar body ops vs <code>V.*</code> ops) - lane predicate values + predication strategy (<code>V.CSEL</code>/<code>V.PSEL</code>) for divergent control flow - subgroup ops: shuffles (<code>V.SHFL*</code>) and reductions (<code>V.RD*</code>) - <code>.local</code>/<code>.brg</code> memory selection and coalescing strategy for the bridged path</p> <p>Note: an exec-mask may still exist as a microarchitectural optimization, but it is not the primary architectural programming model in strict v0.3; the compiler should be correct using lane predicate values.</p> <p>Then lower to a machine model: - scalar ops (address calc, control) - vector ops (lane-wise ALU) - special function units (rcp/rsqrt/sin/cos) if you choose to harden</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#5-ai-mapping-strategy","title":"5. AI mapping strategy","text":""},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#51-unify-on-vulkan-compute-where-possible","title":"5.1 Unify on Vulkan compute where possible","text":"<ul> <li>Many AI stacks can target Vulkan compute (via IREE/MLIR, TVM, custom backends)</li> <li>Key Vulkan features for AI performance:</li> <li>FP16/BF16/INT8</li> <li>subgroup ops</li> <li>cooperative matrix / MMA-like ops (if implemented)</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#52-optional-dedicated-tensormma-engine","title":"5.2 Optional: dedicated Tensor/MMA engine","text":"<p>If \u201cGPU-class AI\u201d is strict, consider hardening: - block GEMM / MMA datapaths - accumulator precision - shared memory/LDS bandwidth</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#6-bring-up-plan-recommended-milestones","title":"6. Bring-up plan (recommended milestones)","text":"<p>1) Functional model in sim/emulator: execute simple SPIR-V compute kernels. 2) Mesa Vulkan ICD + Linux DRM minimal: <code>vkQueueSubmit</code> + fences + simple compute. 3) Zink on top (optional): get OpenGL apps running quickly. 4) Add texture engine + sampler cache. 5) Add raster/ROP for full graphics perf. 6) Perf pass: occupancy, register pressure, cache policy, tiling.</p>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#7-open-questions-backlog-we-will-answer-one-by-one","title":"7. Open questions backlog (we will answer one by one)","text":""},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#a-product-targets","title":"A. Product targets","text":"<ul> <li>What baseline GPU are we comparing to (class + bandwidth)?</li> <li>AI: inference only or training too? which models (LLM, CNN, diffusion)?</li> <li>Graphics: target API (Vulkan 1.1/1.2/1.3?), target resolution/FPS?</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#b-isa-micro-architecture","title":"B. ISA / micro-architecture","text":"<ul> <li>Preferred <code>LB0</code> lane_count policy (8/16/32/64)? Fixed or variable?</li> <li>Vector width / number of VEC pipes / clock target?</li> <li>How much tile/local storage (tile regs + scratch/LDS-like) per core?</li> <li>Do we want an ISA/profile extension for per-lane control flow (exec-mask + reconvergence), or commit to predication-first shaders?</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#c-fixed-function-hardening","title":"C. Fixed-function hardening","text":"<ul> <li>Which graphics stages must be fixed-function vs programmable?</li> <li>Texture formats + filtering requirements?</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#d-software-choices","title":"D. Software choices","text":"<ul> <li>Vulkan-only acceptable? OpenGL via Zink acceptable?</li> <li>Do we need OpenCL/CUDA compatibility?</li> </ul>"},{"location":"architecture/linxcore-unified-ai-render-gpgpu/#8-next-action","title":"8. Next action","text":"<p>After each of your answers, we\u2019ll update this doc into a concrete spec (interfaces + engine list + compiler contracts).</p>"},{"location":"architecture/v0.3-architecture-contract/","title":"LinxISA v0.3 Architecture Contract","text":"<p>This document is the public architecture contract for the block-structured Linx Instruction Set Architecture (LinxISA) v0.3. It replaces legacy bring-up notes and is aligned with the check26 contract gate.</p>"},{"location":"architecture/v0.3-architecture-contract/#scope","title":"Scope","text":"<ul> <li>ISA profile: <code>v0.3</code> only</li> <li>Canonical catalog: <code>isa/v0.3/linxisa-v0.3.json</code></li> <li>Canonical golden sources: <code>isa/v0.3/</code></li> </ul>"},{"location":"architecture/v0.3-architecture-contract/#architectural-guarantees","title":"Architectural Guarantees","text":"<ol> <li>Block-structured execution is mandatory.</li> <li>Control-flow targets MUST resolve to legal block boundaries.</li> <li><code>BSTART.*</code> / <code>BSTOP</code> are block boundary markers used for block init/commit and are normative for block lifecycle.</li> <li>Interpreting \u201cno architectural instructions outside blocks\u201d for bring-up: there must be no instructions that modify architectural state outside block execution (boundary markers/descriptors are allowed as control/packaging mechanisms).</li> <li>Template blocks (<code>FENTRY</code>, <code>FEXIT</code>, <code>FRET.*</code>, <code>ESAVE</code>, <code>ERCOV</code>) are architected contracts.</li> <li>Decoupled block execution requires legal header descriptors and <code>B.TEXT</code> body linkage.</li> <li>Privileged state and trap envelopes are defined by the v0.3 SSR and TRAPNO model.</li> <li>Memory ordering and tile-memory behaviors follow the v0.3 catalog + manual definitions.</li> </ol>"},{"location":"architecture/v0.3-architecture-contract/#conformance-gate","title":"Conformance Gate","text":"<p>The normative gate is <code>check26</code>:</p> <pre><code>python3 tools/bringup/check26_contract.py --root .\n</code></pre> <p>All public compiler/emulator/RTL integration updates MUST preserve this contract.</p>"},{"location":"architecture/isa-manual/","title":"Linx Instruction Set Architecture Manual (AsciiDoc)","text":"<p>This directory contains a draft ISA manual for the Linx Instruction Set Architecture (Linx ISA), written in AsciiDoc and built to PDF using <code>asciidoctor-pdf</code> (via Bundler).</p> <p>The content is specific to Linx\u2019s design (block-structured control flow, <code>BSTART/BSTOP</code>, ClockHands temporaries, template instructions like <code>FENTRY</code>, etc).</p>"},{"location":"architecture/isa-manual/#build","title":"Build","text":"<p>From this directory:</p> <pre><code>make pdf\n</code></pre> <p>Outputs: - <code>build/linxisa-isa-manual.pdf</code></p>"},{"location":"architecture/isa-manual/#prebuilt-pdf","title":"Prebuilt PDF","text":"<ul> <li>v0.3.0: <code>linxisa-isa-manual-v0.3.0.pdf</code></li> <li>Latest release page: https://github.com/LinxISA/linx-isa/releases/latest</li> </ul>"},{"location":"architecture/isa-manual/#regenerate-generated-sections","title":"Regenerate generated sections","text":"<p>The manual includes generated AsciiDoc derived from the canonical spec: - <code>isa/v0.3/linxisa-v0.3.json</code></p> <p>Regenerate:</p> <pre><code>make gen\n</code></pre> <p>Note: <code>build/</code> is gitignored; local build outputs are not committed to the repository.</p>"},{"location":"architecture/research/linxisa-v0.3-simt-vector-model/","title":"LinxISA v0.3 SIMT / Vector Block Model (research notes)","text":"<p>Purpose: capture what LinxISA already specifies about SIMT-style execution so our AI+render GPGPU design builds on it (instead of reinventing a GPU model).</p>"},{"location":"architecture/research/linxisa-v0.3-simt-vector-model/#1-simt-is-expressed-as-block-types-not-a-separate-isa-mode","title":"1) SIMT is expressed as block types (not a separate ISA mode)","text":"<p>The ISA defines SIMT-style vector blocks: - <code>BSTART.MSEQ</code> / <code>BSTART.MPAR</code> - <code>BSTART.VSEQ</code> / <code>BSTART.VPAR</code></p> <p>Key rule: a vector block body specifies one-lane semantics, and hardware replays it over a lane space.</p> <p>Sources: - <code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code> (SIMT-style vector blocks) - <code>docs/architecture/isa-manual/src/chapters/07_tile_blocks.adoc</code> (SIMT vector blocks)</p>"},{"location":"architecture/research/linxisa-v0.3-simt-vector-model/#2-lane-space-counters-lb0lb2-lc0lc2","title":"2) Lane space + counters (LB0\u2013LB2, lc0\u2013lc2)","text":"<p>Bring-up model (strict v0.3): - <code>LB0..LB2</code> are written by header <code>B.DIM</code>. - Hardware exposes lane counters <code>lc0..lc2</code> to the body, init <code>0</code>. - Body executes for each tuple <code>(lc0,lc1,lc2)</code>:   - <code>lc0: 0..LB0-1</code> (fastest)   - <code>lc1: 0..max(LB1,1)-1</code>   - <code>lc2: 0..max(LB2,1)-1</code></p> <p>Commit semantics: - <code>MSEQ</code>/<code>VSEQ</code>: lexicographic commit order. - <code>MPAR</code>/<code>VPAR</code>: conceptually parallel; commit may interleave but must be observationally valid.</p> <p>Source: <code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code></p>"},{"location":"architecture/research/linxisa-v0.3-simt-vector-model/#3-group-model-scalar-uniform-context-per-group","title":"3) \u201cGroup model\u201d: scalar-uniform context per group","text":"<p>Strict v0.3 defines a canonical 1-D lowering: - <code>LB0</code> = lane_count (lanes per group) - <code>LB1</code> = group_count - linear lane index: <code>lc0 + lc1 * lane_count</code></p> <p>Important: scalar instructions inside vector bodies are uniform per group: - one scalar-uniform execution context per group replay - scalar instructions execute once per group; vector instructions operate in the lane domain</p> <p>Source: <code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code> and <code>docs/architecture/isa-manual/src/chapters/02_programming_model.adoc</code></p>"},{"location":"architecture/research/linxisa-v0.3-simt-vector-model/#4-predicates-block-control-vs-lane-values","title":"4) Predicates: block-control vs lane values","text":"<p>Two distinct predicate domains: - Block-control predicate (<code>BARG.CARG</code>) from <code>SETC.*</code> for block-level control. - Vector-lane predicate values produced by <code>V.CMP.*</code> / <code>V.F*</code> compares, consumed by <code>V.CSEL</code> etc.</p> <p>Lane predicate truth: <code>value != 0</code>.</p> <p>Source: <code>docs/architecture/isa-manual/src/chapters/02_programming_model.adoc</code> and <code>isa/v0.3/state/architectural_state.json</code></p>"},{"location":"architecture/research/linxisa-v0.3-simt-vector-model/#5-memory-model-separation-bridged-global-memory","title":"5) Memory model separation + bridged global memory","text":"<p>Architectural constraint (v0.3 strict): - Vector PE has no direct main-memory access. - Scalar pipe and TMA/tile channel perform memory accesses.</p> <p>Vector memory naming: - <code>.local</code> forms: tile/local direction (base is tile bases <code>TA/TB/TO/TS</code>) - <code>.brg</code> forms: bridged global memory (base must be <code>ri*</code> imported via <code>B.IOR</code>)</p> <p>Hard restriction: - <code>VSEQ/VPAR</code> blocks MUST NOT use <code>.brg</code> ops (tile-only vector execution). - <code>MSEQ/MPAR</code> are the vector families intended to use the bridged path.</p> <p>Sources: - <code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code> (bridge naming + restrictions) - <code>docs/bringup/plan/arch.md</code> (vector-memory separation) - <code>isa/v0.3/state/memory_model.json</code> (MTC includes bridged MSEQ/MPAR)</p>"},{"location":"architecture/research/linxisa-v0.3-simt-vector-model/#6-implications-for-our-shadersimtvec-plan","title":"6) Implications for our \u201cshader\u2192SIMT\u2192VEC\u201d plan","text":"<p>What LinxISA already gives us: - A standardized SIMT replay model (lane_count/group_count). - Lane IDs (<code>lc*</code>) usable for subgroup ops, addressing, etc. - Reduction (<code>V.RD*</code>) and shuffle (<code>V.SHFL*</code>) operations suitable for subgroup programming.</p> <p>What we still must decide/design: - lane_count policy for our GPGPU core (e.g. LB0=8/16/32/64). ISA allows variable; hardware+compiler should pick a sweet spot. - How to compile GPU-style divergent control flow given the strict separation of predicate domains and the \u201cscalar-uniform per group\u201d rule.   - Likely needs aggressive if-conversion/predication, or an ISA/profile extension for per-lane control flow (exec-mask style). - How to map graphics shader stages onto <code>MSEQ/MPAR</code> vs tile-only <code>VSEQ/VPAR</code>.</p>"},{"location":"architecture/v0.4-draft/","title":"LinxISA v0.4 (DRAFT)","text":"<p>This folder is the working area for LinxISA v0.4 architectural changes.</p> <p>Rules for this repo state (per project direction): - Do not modify v0.3 documents/contracts while drafting v0.4. - All new/changed semantics required by the rendering + GPGPU architecture are captured here first. - Once the rendering architecture draft stabilizes, we will propose a controlled upgrade path from v0.3 \u2192 v0.4.</p>"},{"location":"architecture/v0.4-draft/#what-goes-here","title":"What goes here","text":"<ul> <li>New or revised architectural contracts.</li> <li>Deltas relative to v0.3 (control-flow, SIMT kernel bodies, memory path, etc.).</li> <li>Rendering pipeline requirements that drive ISA changes.</li> </ul>"},{"location":"architecture/v0.4-draft/#what-does-not-go-here","title":"What does not go here","text":"<ul> <li>Machine-generated artifacts (JSON catalogs, generated instruction tables) until the draft is ready to be promoted.</li> </ul>"},{"location":"architecture/v0.4-draft/#index","title":"Index","text":"<ul> <li><code>notes/v0.4-deltas.md</code> \u2014 high-level list of planned semantic changes vs v0.3</li> <li><code>notes/simt-kernel-body-controlflow.md</code> \u2014 proposed rules for SIMT kernel bodies with group-level control flow</li> <li><code>rendering/arch-overview.md</code> \u2014 rendering + AI unified GPGPU architecture notes (v0.4-driven)</li> </ul>"},{"location":"architecture/v0.4-draft/notes/simt-kernel-body-controlflow/","title":"v0.4 draft: SIMT kernel body control flow (group-granular)","text":""},{"location":"architecture/v0.4-draft/notes/simt-kernel-body-controlflow/#context","title":"Context","text":"<p>In v0.3 strict, decoupled bodies are specified as linear snippets and MUST NOT contain any architectural control transfer instructions.</p> <p>For rendering/GPGPU, we want to treat a vector block launch (e.g. <code>BSTART.MPAR</code> + descriptors) as launching a small kernel whose code is the body referenced by <code>B.TEXT</code>.</p> <p>The kernel body must allow full structured control flow (if/else/loops), but control flow is evaluated at group (warp) granularity using the scalar-uniform lane.</p>"},{"location":"architecture/v0.4-draft/notes/simt-kernel-body-controlflow/#proposed-model-draft","title":"Proposed model (draft)","text":""},{"location":"architecture/v0.4-draft/notes/simt-kernel-body-controlflow/#a-body-is-a-kernel-not-a-linear-snippet","title":"A) Body is a kernel (not a linear snippet)","text":"<ul> <li><code>B.TEXT</code> selects a kernel entrypoint.</li> <li>The kernel body is a normal instruction stream (may contain branches/jumps), executed under the vector-block replay model.</li> </ul>"},{"location":"architecture/v0.4-draft/notes/simt-kernel-body-controlflow/#b-control-flow-granularity","title":"B) Control-flow granularity","text":"<ul> <li>Branch/jump instructions (<code>B.*</code>, <code>J</code>, <code>JR</code>, etc.) are executed by the scalar-uniform lane context.</li> <li>A group maintains a group PC (TPC) and executes one control-flow path at a time.</li> <li>Vector lanes execute lane operations under a lane mask (64-bit) maintained by the kernel/runtime/compiler.</li> </ul>"},{"location":"architecture/v0.4-draft/notes/simt-kernel-body-controlflow/#c-lane-mask-inactive-lane-behavior","title":"C) Lane mask / inactive-lane behavior","text":"<ul> <li>The lane mask defines which lanes are active for vector operations.</li> <li>Inactive lane behavior must be deterministic and compatible with the architectural inactive-lane policy (merge vs zero).</li> <li>The kernel/compiler is responsible for updating the lane mask around divergent regions.</li> </ul> <p>Draft anchoring in existing v0.3 conventions: - v0.3 semantics conventions already define a vec-engine scalar-lane predicate register named <code>p</code>, with <code>B.Z/B.NZ</code> testing <code>p==0</code> / <code>p!=0</code>. - In v0.4, we reuse <code>p</code> as the group EXEC mask (64-bit).</p> <p>Draft access rule (chosen direction): - <code>p</code> is treated as a scalar-lane 64-bit register that can be used as a normal source/destination in scalar-lane instructions inside the kernel body (i.e. allow <code>-&gt;p</code> destinations and <code>p</code> as an operand in scalar-lane ALU/bitwise/compare as needed).</p> <p>Draft execution rule (chosen direction): - <code>p</code> is the EXEC mask: for each vector instruction, lane <code>i</code> is active iff <code>p[i] == 1</code>. - For inactive lanes, destination writeback behavior follows the architected inactive-lane policy (merge vs zero).</p>"},{"location":"architecture/v0.4-draft/notes/simt-kernel-body-controlflow/#d-containment-and-safety","title":"D) Containment and safety","text":"<p>To preserve CFI and avoid arbitrary jumps: - The kernel text region is implicitly bounded by terminator markers.   - The body is considered fetchable/executable starting at <code>B.TEXT</code> entry.   - The kernel ends on the first terminator marker encountered in the body stream.   - Terminators: <code>BSTOP</code>/<code>C.BSTOP</code> and any <code>BSTART.*</code>/<code>C.BSTART.*</code> (first terminator wins; anything after is unreachable). - In-body control-flow targets (branches/jumps) MUST NOT escape the body\u2019s fetchable region; escaping targets fault as body-fetch faults (consistent with existing vec-engine BRU conventions). - No architectural control flow may jump into the middle of a kernel from outside (same as v0.3 <code>B.TEXT</code> rule). - Kernel returns to the header continuation point by reaching the terminator.</p>"},{"location":"architecture/v0.4-draft/notes/simt-kernel-body-controlflow/#e-calls-optional","title":"E) Calls (optional)","text":"<ul> <li>v0.4 may still prohibit call/return inside kernel bodies initially (to simplify bring-up), even if branches are allowed.</li> </ul>"},{"location":"architecture/v0.4-draft/notes/simt-kernel-body-controlflow/#open-questions","title":"Open questions","text":"<p>1) How do we declare the kernel text region (start/end) for containment checks?    - chosen direction: terminator markers (first <code>BSTOP/C.BSTOP</code> or any <code>BSTART.*</code> ends the kernel)    - (defer) fixed-size in descriptor?    - (defer) side-table metadata in driver/runtime?</p> <p>2) How is the lane mask represented architecturally?    - reuse vec-engine scalar-lane predicate register <code>p</code> as EXEC (preferred by current direction)    - implicit (microarchitectural) with compiler conventions    - explicit SSR or dedicated register file</p> <p>3) If we reuse <code>p</code> as EXEC: what are the read/write mechanisms?    - allow scalar ALU ops to write <code>-&gt;p</code> (destination form)    - or add explicit <code>PSET/PGET</code> ops    - or model <code>p</code> as an SSR (SSRGET/SSRSET)</p> <p>4) How do we set <code>p</code> from per-lane conditions?    - chosen direction: allow vector compare instructions to write an EXEC mask: <code>V.CMP.* -&gt;p</code>    - inactive lane rule (chosen): when executing <code>V.CMP.* -&gt;p</code>, any lane that is inactive under the current EXEC mask is treated as producing 0 (bit cleared).</p> <p>5) Interaction with <code>MPAR/MSEQ</code> retirement ordering and traps/restartability.</p>"},{"location":"architecture/v0.4-draft/notes/unified-lx64-kernel-encoding/","title":"v0.4 draft note: Unified lx64 kernel encoding (scalar lane + vector lane)","text":""},{"location":"architecture/v0.4-draft/notes/unified-lx64-kernel-encoding/#context","title":"Context","text":"<p>The strict v0.3 manual currently documents a split between \"scalar\" instruction families (often 16/32-bit) and \"vector\" instruction families (<code>V.*</code>, 64-bit prefix+main), with additional operand restrictions in vector bodies.</p> <p>For the rendering/GPGPU kernel-body direction, we assume a different (more GPU-like) execution reality:</p> <ul> <li>Scalar-lane and vector-lane instructions are both 64-bit encodings inside the SIMT kernel body.</li> <li>They share one operand encoding space: a register field can name one of several domains:</li> <li>scalar temporaries / clockhands (<code>t</code>, <code>u</code>)</li> <li>vector-argument namespace (<code>ri*</code>)</li> <li>predicate register (<code>p</code>)</li> <li>tile bases (<code>TA</code>, <code>TB</code>, <code>TO</code>, <code>TS</code>, ...)</li> <li>per-lane tile/value registers (<code>vt</code>, <code>vu</code>, <code>vm</code>, <code>vn</code>) for lane execution</li> <li>The execution domain is derived from register class usage (no dedicated mode bit):</li> <li>operations targeting/using per-lane tile/value registers (<code>vt/vu/vm/vn</code>) are treated as vector-lane execution (<code>v.*</code>)</li> <li>operations targeting/using scalar/group resources (<code>t/u/ri/p/TA/TB/TO/TS/...</code>) are treated as scalar-uniform lane execution (<code>l.*</code>)</li> </ul> <p>Chosen derivation rule: any-operand rule - If any operand (src or dst) names a per-lane register (<code>vt/vu/vm/vn</code>), the instruction is treated as vector-lane execution (<code>v.*</code>). - Otherwise it is treated as scalar-uniform lane execution (<code>l.*</code>).</p> <p>This enables: - uniform control-flow and uniform global-memory access via the bridged path in kernel bodies (no BCC scalar memory) - natural shader lowering with per-lane compute + scalar control + explicit EXEC mask <code>p</code></p>"},{"location":"architecture/v0.4-draft/notes/unified-lx64-kernel-encoding/#chosen-mixed-class-semantics-initial","title":"Chosen mixed-class semantics (initial)","text":"<p>Given the any-operand rule: - In a <code>v.*</code> instruction, any scalar/group-domain source operand (<code>t/u/ri/p/TA/TB/TO/TS/...</code>) is broadcast to all active lanes. - Per-lane operands (<code>vt/vu/vm/vn</code>) remain lane-specific.</p>"},{"location":"architecture/v0.4-draft/notes/unified-lx64-kernel-encoding/#remaining-todos","title":"Remaining TODOs","text":"<p>1) <code>v.*</code> writing scalar/group-domain destinations is not allowed; any cross-lane aggregation must use an explicit reduction primitive (<code>V.RD*</code>) or other explicitly defined cross-lane op. 2) The register-id ranges / numeric encodings for special domains (<code>ri*</code>, <code>p</code>, <code>TA/TB/TO/TS</code>, <code>vt/vu/vm/vn</code>). 3) For <code>.brg</code> loads/stores: whether the address formation differs between <code>v.*.brg</code> and <code>l.*.brg</code> (implicit <code>lc0</code> or not), or whether both share the same rules.</p>"},{"location":"architecture/v0.4-draft/notes/v0.4-deltas/","title":"v0.4 draft deltas (vs v0.3)","text":"<p>This is a draft checklist of semantic changes we may need for the rendering-focused GPGPU architecture. It is intentionally incomplete; we will refine it as we lock the rendering architecture.</p>"},{"location":"architecture/v0.4-draft/notes/v0.4-deltas/#1-simt-kernel-bodies-with-control-flow-group-level","title":"1) SIMT kernel bodies with control flow (group-level)","text":"<p>Potential change: - v0.3 decoupled bodies are specified as linear snippets and prohibit branch/jump/control-transfer instructions. - Rendering/GPGPU shaders need complex control flow inside the kernel body, at group (warp) granularity.</p> <p>Related kernel-encoding direction: - In-kernel scalar + vector instructions are treated as a unified 64-bit encoding space with shared operand naming. - <code>l.*</code> vs <code>v.*</code> is derived from register class usage (no dedicated mode bit), using an any-operand rule: if any operand references <code>vt/vu/vm/vn</code>, it is <code>v.*</code>. - See: <code>notes/unified-lx64-kernel-encoding.md</code></p> <p>Related execution-control requirements: - Define EXEC mask register <code>p</code> (64-bit) and implicit vector predication by <code>p</code>. - Provide a way to set <code>p</code> from per-lane comparisons (chosen direction: allow <code>V.CMP.* -&gt;p</code>).</p> <p>Draft direction: - Define a v0.4 SIMT \"kernel body\" form allowing in-body control flow with strict containment rules.</p> <p>See: <code>notes/simt-kernel-body-controlflow.md</code></p>"},{"location":"architecture/v0.4-draft/notes/v0.4-deltas/#2-group-model-pin-down","title":"2) Group model pin-down","text":"<p>Draft direction: - Standardize on a \"warp-like\" group model for the GPGPU core:   - 64 vector lanes (32-bit lanes)   - 1 scalar-uniform lane (64-bit)   - 64-bit lane mask/predicate used for group-level control flow - Reuse vec-engine scalar-lane predicate register <code>p</code> as the EXEC mask.   - <code>p</code> is readable/writable by scalar-lane instructions in kernel bodies (normal src/dst operand role).   - Vector instructions are implicitly predicated by <code>p</code> (inactive lanes follow merge/zero policy).</p>"},{"location":"architecture/v0.4-draft/notes/v0.4-deltas/#3-memory-path-clarity-for-shaders","title":"3) Memory path clarity for shaders","text":"<p>Draft direction: - Make the bridging contract for global memory explicit for shader kernels. - Clarify how <code>.brg</code> accesses map onto the tile/TMA channel in the presence of SIMT kernels. - Default shader-kernel vector block type: MPAR (throughput-oriented). - Shader kernels may access global memory via <code>*.brg</code> (bridged path).   - vector: <code>v.*.brg</code>   - scalar lane (uniform): <code>l.*.brg</code> (draft requirement) - Adopt the v0.3 staged MCALL-like boundaries for MPAR/MSEQ entry/exit (acquire before, release after; BCC closed while active; non-speculative start until <code>B.IOT/B.IOTI</code> resolved).</p>"},{"location":"architecture/v0.4-draft/notes/v0.4-deltas/#4-rendering-pipeline-isa-implications","title":"4) Rendering pipeline ISA implications","text":"<p>Draft direction: - Decide which stages are expressed as SIMT kernels vs fixed-function engines. - Decide required subgroup primitives (shuffles/reductions) and any missing ops.</p>"},{"location":"architecture/v0.4-draft/rendering/arch-overview/","title":"v0.4 draft: Rendering + AI on LinxGPGPU (arch overview)","text":"<p>This document will host the rendering-driven architectural requirements that may force ISA v0.4 changes.</p>"},{"location":"architecture/v0.4-draft/rendering/arch-overview/#goals","title":"Goals","text":"<ul> <li>Vulkan-first graphics + compute.</li> <li>Shaders/compute compile to Linx SIMT kernel bodies, executed on a multi-core LinxGPGPU.</li> <li>Group model: 64-lane vector + 1 scalar lane controlling group-level control flow.</li> <li>Default kernel launch form: <code>BSTART.MPAR</code>.</li> <li>Kernel global memory access: allowed via <code>*.brg</code> (bridged path).</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/arch-overview/#topics-to-fill-in","title":"Topics to fill in","text":"<ul> <li>Pipeline stages expressed as kernels vs hardened engines (raster/tex/ROP/etc).</li> <li>Memory model expectations for GPU workloads (queues, barriers, caches).</li> <li>Shader compiler contract (SPIR-V/NIR lowering strategy).</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/arch-overview/#draft-memory-mode-rule-for-shader-kernels-mcall-like","title":"Draft memory-mode rule for shader kernels (MCALL-like)","text":"<p>Carry forward the v0.3 staged memory-channel model into the v0.4 shader-kernel story: - Treat <code>BSTART.MPAR/MSEQ</code> shader kernels as entering a MCALL-like mode. - Entry boundary: acquire-style ordering before MTC-only execution begins. - Exit boundary: release-style ordering before subsequent scalar blocks execute. - While active: BCC scalar memory issue is closed (no normal scalar <code>load/store/atomic/fence</code>).   - Global memory traffic is via the bridged path (<code>*.brg</code>):     - vector lanes: <code>v.*.brg</code>     - scalar lane (uniform): <code>l.*.brg</code> (v0.4 draft requirement / alias family) - Non-speculative start: do not begin side-effecting execution until declared input dependencies (<code>B.IOT/B.IOTI</code>) are resolved.</p>"},{"location":"architecture/v0.4-draft/rendering/bcc-led-command-buffer-lowering/","title":"v0.4 draft: BCC-led Vulkan command buffer lowering","text":""},{"location":"architecture/v0.4-draft/rendering/bcc-led-command-buffer-lowering/#decision","title":"Decision","text":"<p>Vulkan command buffers are lowered/expanded by BCC (or a BCC-adjacent runtime) into a sequence of Linx blocks.</p> <p>Rationale: - keeps on-device CP simple early (fewer corner cases) - allows aggressive scheduling/OOO composition using LinxCore\u2019s existing block/BID machinery - makes bring-up/debug easier in emulator/RTL</p>"},{"location":"architecture/v0.4-draft/rendering/bcc-led-command-buffer-lowering/#what-this-implies","title":"What this implies","text":"<ul> <li>The Vulkan driver is responsible for producing a block stream that encodes:</li> <li>pipeline state bindings</li> <li>resource bindings (descriptors)</li> <li>kernel launches (MPAR shader kernels)</li> <li>synchronization/barriers</li> <li>fixed-function engine invocations (DMA/clear/etc)</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/bcc-led-command-buffer-lowering/#open-items","title":"Open items","text":"<p>1) Which parts are in user-mode driver vs kernel driver? 2) How to represent state bundles (PSO) efficiently to avoid bloating block streams? 3) How to handle secondary command buffers / multi-thread recording? 4) How to map Vulkan sync primitives (timeline semaphores) to block/BID fences.</p>"},{"location":"architecture/v0.4-draft/rendering/bringup-plan-to-vulkan/","title":"v0.4 draft: Rendering bring-up plan (Mesa \u2192 emulator \u2192 Vulkan runs)","text":"<p>Goal: in the Linx emulator, reach a state where we can run Vulkan applications (at least headless/offscreen) using Mesa\u2019s software Vulkan backend as the initial reference, and then iterate toward LinxGPGPU acceleration.</p> <p>Assumptions (current direction): - Start with Mesa softpipe bring-up first (lowest dependency path), then expand. - Final milestone for this plan: Vulkan runs in emulator (feature completeness can be staged). - Hardening decisions come after we have a working stack + profiling.</p>"},{"location":"architecture/v0.4-draft/rendering/bringup-plan-to-vulkan/#stage-0-platform-sanity-prerequisites","title":"Stage 0 \u2014 \u201cplatform sanity\u201d prerequisites","text":"<p>Deliverable: emulator can boot Linux userspace and run dynamic binaries reliably.</p> <p>Gate: - can run: <code>uname -a</code>, <code>ldd --version</code>, <code>python3 --version</code> (or at least a minimal shell) - filesystem has enough space for a Mesa install prefix + test binaries</p> <p>Artifacts: - a reproducible emulator launch config - a reproducible Linx Linux rootfs/sysroot reference</p>"},{"location":"architecture/v0.4-draft/rendering/bringup-plan-to-vulkan/#stage-1-build-mesa-for-linx-host-side-cross-build-preferred","title":"Stage 1 \u2014 Build Mesa for Linx (host-side cross build preferred)","text":"<p>Deliverable: Mesa built for Linx, installed into a sysroot/prefix used by emulator.</p> <p>Recommendations: - Use Meson + Ninja. - Start with OpenGL + Gallium softpipe only (avoid LLVM dependency at first).</p> <p>Gate: - Mesa libraries present in the prefix (GL/EGL/GBM as needed) - Can run <code>glxinfo</code> is optional; headless path is OK.</p> <p>Notes: - We keep WSI/window-system dependencies minimal (prefer surfaceless/pbuffer).</p>"},{"location":"architecture/v0.4-draft/rendering/bringup-plan-to-vulkan/#stage-2-opengl-first-pixels-via-softpipe-headlessoffscreen","title":"Stage 2 \u2014 OpenGL \u201cfirst pixels\u201d via softpipe (headless/offscreen)","text":"<p>Deliverable: In emulator, a minimal GL program renders offscreen and dumps an image/checksum.</p> <p>Suggested target: - EGL surfaceless or pbuffer context - Render a triangle/quad with a tiny shader - Read back RGBA, dump PPM/RAW, or compute a deterministic checksum</p> <p>Gate: - deterministic output across runs (within a tolerance if needed)</p> <p>Why this stage matters: - Proves dynamic loader + libc + Mesa + shader compiler path can execute in Linx emulator.</p>"},{"location":"architecture/v0.4-draft/rendering/bringup-plan-to-vulkan/#stage-3-vulkan-first-device-software-vulkan-in-mesa","title":"Stage 3 \u2014 Vulkan \u201cfirst device\u201d (software Vulkan in Mesa)","text":"<p>Deliverable: In emulator, Vulkan loader + a software Vulkan ICD works.</p> <p>Suggested baseline Vulkan driver: - Mesa lavapipe (lvp) as the reference software Vulkan implementation.</p> <p>Gates (required): 1) <code>vulkaninfo</code> runs and enumerates 1 physical device. 2) A headless Vulkan sample runs:    - create instance/device    - create a storage buffer / image    - run a simple compute or graphics pipeline    - copy results back, validate checksum</p> <p>Note: - This avoids needing X11/Wayland early.</p>"},{"location":"architecture/v0.4-draft/rendering/bringup-plan-to-vulkan/#stage-4-optional-wsi-presentation","title":"Stage 4 \u2014 Optional: WSI / presentation","text":"<p>Deliverable: a Vulkan app that presents frames (X11/Wayland/DRM).</p> <p>Gate: - <code>vkcube</code> or a minimal present demo runs.</p> <p>This stage can be deferred until we need interactive demos.</p>"},{"location":"architecture/v0.4-draft/rendering/bringup-plan-to-vulkan/#stage-5-start-replacing-software-pieces-with-linxgpgpu-kernels-future","title":"Stage 5 \u2014 Start replacing software pieces with LinxGPGPU kernels (future)","text":"<p>Out of scope for \u201cVulkan runs\u201d, but the next step: - introduce a Linx Vulkan driver path where shader kernels compile to MPAR kernels - keep a fallback to software (lavapipe/softpipe) while verifying correctness</p>"},{"location":"architecture/v0.4-draft/rendering/bringup-plan-to-vulkan/#metrics-to-collect-from-day-1","title":"Metrics to collect from day 1","text":"<ul> <li>shader count and size</li> <li>instruction mix proxies (NIR stats / LLVM stats if applicable)</li> <li>memory bandwidth estimates (bytes read/write per frame)</li> <li>texture sample counts and formats (once we run real scenes)</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/bringup-plan-to-vulkan/#open-questions","title":"Open questions","text":"<ul> <li>Mesa install prefix in emulator rootfs: <code>/opt/mesa</code> (chosen).</li> <li>Build mode: cross-compile on host (chosen).</li> <li>Do we need OpenGL at all after Vulkan is up, or keep it for debugging/regression?</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/hardening-experiment-plan/","title":"v0.4 draft: Limited hardening experiment plan (render + AI)","text":""},{"location":"architecture/v0.4-draft/rendering/hardening-experiment-plan/#principle","title":"Principle","text":"<ul> <li>Hardening is limited: only the most common + best ROI + easiest-to-verify units become fixed-function engines.</li> <li>Everything else must have a VEC-kernel fallback (MPAR shader kernels) orchestrated by the command processor / BCC scheduling.</li> <li>The chip is a composition of heterogeneous blocks, allowed to run out-of-order, but retiring/visibility is managed by LinxCore block/BID rules.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/hardening-experiment-plan/#what-we-need-to-measure-to-decide-what-to-harden","title":"What we need to measure (to decide what to harden)","text":"<p>For representative workloads, collect: - instruction mix (ALU, LDS/shared, memory, special ops) - texture/sample count, filter modes, format usage - depth/stencil/blend frequency - bandwidth (bytes read/write), cache hit rates if modeled - occupancy limits (regs/LDS)</p>"},{"location":"architecture/v0.4-draft/rendering/hardening-experiment-plan/#candidate-engines-initial-list","title":"Candidate engines (initial list)","text":"<p>These are typical high-ROI candidates; we will rank them using the measurements above: 1) DMA/BLT/Clear (copies, resolves, clears, format conversion) 2) Texture/Sampler (addressing + filtering + cache) 3) Depth/Stencil + Blend (ROP) 4) Raster/Tiler/Binner (triangle setup + binning) 5) Tensor/MMA micro-engine (AI focus; optional)</p>"},{"location":"architecture/v0.4-draft/rendering/hardening-experiment-plan/#experimental-workflow-draft","title":"Experimental workflow (draft)","text":"<p>1) Baseline: everything in MPAR kernels + minimal DMA. 2) Add instrumentation:    - Mesa driver counters (API-level and shader compiler-level)    - kernel/driver submission stats    - (later) hardware perf counters in RTL/emulator 3) Run a benchmark suite (to be defined) and produce a ranked heatmap. 4) Pick top-1 engine to harden; define its ISA/command interface + fallback path. 5) Iterate.</p>"},{"location":"architecture/v0.4-draft/rendering/hardening-experiment-plan/#open-questions","title":"Open questions","text":"<ul> <li>Benchmark/workload suite definition.</li> <li>Which metrics are obtainable in each environment (emulator vs RTL vs silicon).</li> <li>Acceptance criteria for \u201cworth hardening\u201d.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/","title":"v0.4 draft: LinxGPGPU core architecture (render-first)","text":"<p>This document is the working architectural spec for a GPU-SM-like core (\u201cLinxGPGPU core\u201d), scaling out to many cores to form a GPGPU suitable for rendering + compute.</p>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#1-system-philosophy","title":"1) System philosophy","text":"<ul> <li>CPU (BCC) + Shader Core as the primary composition model:</li> <li>CPU/BCC performs command lowering, orchestration, and software fallbacks.</li> <li>Shader core runs kernels (MPAR) for the parallel parts.</li> <li>Limited hardening: only high-ROI units become fixed-function engines.</li> <li>VEC/SIMT kernel fallback: everything must be runnable as MPAR kernels.</li> <li>Heterogeneous blocks + out-of-order: the machine is a composition of blocks targeting different engines, allowed to run out-of-order, but retiring/visibility is managed by LinxCore block/BID rules.</li> <li>Tile is general intermediate state storage for cross-engine communication; rendering may be tile-based or immediate-mode.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#2-execution-model-kernel-body","title":"2) Execution model (kernel body)","text":""},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#21-groupwarp","title":"2.1 Group/warp","text":"<ul> <li>One group \u2248 NVIDIA warp.</li> <li>Group composition:</li> <li>64 vector lanes</li> <li>1 scalar-uniform lane (controls group-level control flow)</li> <li><code>p</code> is the EXEC mask (64-bit).</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#22-control-flow-in-kernel-body","title":"2.2 Control flow in kernel body","text":"<ul> <li>Kernel body is a normal instruction stream (branches/loops allowed).</li> <li>Control-flow instructions update body-local <code>TPC</code> and are evaluated at group granularity using the scalar-uniform lane.</li> <li>Kernel terminates on the first terminator marker (<code>BSTOP/C.BSTOP</code> or any <code>BSTART.*</code>).</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#23-exec-mask-rules","title":"2.3 EXEC mask rules","text":"<ul> <li>Vector instructions are implicitly predicated by <code>p</code> (lane active iff <code>p[lane]==1</code>).</li> <li><code>V.CMP.* -&gt;p</code> is used to generate masks.</li> <li>Inactive lanes during <code>V.CMP.* -&gt;p</code> produce 0 bits.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#3-unified-64-bit-kernel-encoding-and-lv-derivation","title":"3) Unified 64-bit kernel encoding and l/v derivation","text":"<p>Design direction: - Kernel-body instructions use a unified 64-bit encoding space. - <code>l.*</code> vs <code>v.*</code> is derived from register-class usage (no dedicated mode bit).   - Any-operand rule: if any operand references per-lane regs (<code>vt/vu/vm/vn</code>), treat as <code>v.*</code>.   - Otherwise treat as <code>l.*</code>. - Mixed-class semantics (initial): scalar/group-domain src operands (<code>t/u/ri/p/TA/TB/TO/TS/...</code>) are broadcast to all active lanes when executing <code>v.*</code>. - <code>v.*</code> writing scalar/group-domain destinations is not allowed; use explicit reductions (<code>V.RD*</code>) or other explicit cross-lane ops.</p>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#4-global-memory-access-inside-kernels","title":"4) Global memory access inside kernels","text":"<ul> <li>Kernel global memory accesses go through the bridged path (<code>*.brg</code>).</li> <li>vector lanes: <code>v.*.brg</code></li> <li>scalar lane (uniform): <code>l.*.brg</code></li> <li>Normal BCC scalar memory issue is closed while in MCALL-like MPAR/MSEQ mode; <code>l.*.brg</code> is treated as part of the bridged/MTC-like domain.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#5-hardware-partitioning-core-engines","title":"5) Hardware partitioning (core + engines)","text":""},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#51-core-roles","title":"5.1 Core roles","text":"<ul> <li>VEC (shader core): runs MPAR kernels for compute shading and serves as the fallback path for any feature not supported by hardening.</li> <li>TAU (tile arithmetic unit): is the primary substrate for hardening \u201cshader-like\u201d operations and other accelerators.</li> <li>TAU/accelerators communicate via tile registers (general intermediate state storage).</li> <li>Hardening should be expressed as TAU-facing operations so state handoff stays in tiles.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#52-engine-set-current-linxcore-decomposition","title":"5.2 Engine set (current LinxCore decomposition)","text":"<ul> <li>BCC + block fabric dispatch to engines by block type.</li> <li>Engines include: TMA, CUBE, VEC, TAU (plus DMA/clear as needed).</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#53-state-handoff","title":"5.3 State handoff","text":"<ul> <li>The primary inter-engine handoff medium is the tile register file.</li> <li>BCC orchestrates pipelines by issuing heterogeneous blocks whose inputs/outputs are tiles.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/linxgpgpu-core-arch/#6-open-items-to-decide-next","title":"6) Open items to decide next","text":"<ul> <li>Rendering pipeline modes: support both immediate-mode (desktop-style) and tile-based approaches.</li> <li>Linx \u201ctile\u201d remains general-purpose intermediate state storage; screen-space tiling is an optional strategy.</li> <li>What work is on CPU/BCC vs shader core in each pipeline mode (stage-by-stage split).</li> <li>If/when we introduce binning: stage-1 binning can be built by BCC scalar-block software logic; later migrate to MPAR kernels / hardened binner if ROI proves out.</li> <li>Vulkan command buffer mapping: BCC-led expansion (command buffers are lowered/expanded into Linx blocks by BCC/runtime rather than a heavy on-GPU CP parser).</li> <li>Memory/cache/coherence policy for <code>.brg</code> vs CPU.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/mesa-bringup-with-softpipe-llvmpipe/","title":"v0.4 draft: Rendering bring-up using Mesa softpipe/llvmpipe (scaffold)","text":""},{"location":"architecture/v0.4-draft/rendering/mesa-bringup-with-softpipe-llvmpipe/#intent","title":"Intent","text":"<p>Use Mesa\u2019s software rasterizers as scaffolding to: - validate the Linx Linux+libc runtime can run real-world rendering stacks in the emulator - validate our driver/Winsys/WSI plumbing and test infrastructure - produce traces + workload characterization before deciding what to harden</p> <p>These software backends are not the end goal; they are the baseline/reference.</p>"},{"location":"architecture/v0.4-draft/rendering/mesa-bringup-with-softpipe-llvmpipe/#why-softpipe-llvmpipe","title":"Why softpipe + llvmpipe","text":"<ul> <li><code>softpipe</code>: pure C pipeline; simplest dependency story; slower but easiest to get running.</li> <li><code>llvmpipe</code>: higher performance and wider feature coverage; depends on LLVM; good reference for shader/IR behavior.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/mesa-bringup-with-softpipe-llvmpipe/#phased-plan","title":"Phased plan","text":""},{"location":"architecture/v0.4-draft/rendering/mesa-bringup-with-softpipe-llvmpipe/#phase-0-build-run-mesa-in-linx-emulator-headless-first","title":"Phase 0 \u2014 build &amp; run Mesa in Linx emulator (headless first)","text":"<ul> <li>Target: run a simple OpenGL program in emulator using software rasterizer.</li> <li>Prefer headless/surfaceless (EGL pbuffer / surfaceless) to avoid early window-system complexity.</li> <li>Deliverable: reproducible build scripts + minimal demo + image compare.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/mesa-bringup-with-softpipe-llvmpipe/#phase-1-testing-workload-characterization","title":"Phase 1 \u2014 testing + workload characterization","text":"<ul> <li>Run a small suite (vkmark/glmark2-like equivalents, micro scenes, shader-heavy scenes).</li> <li>Collect:</li> <li>shader count/types, instruction mix</li> <li>texture sampling frequency/modes</li> <li>depth/stencil/blend usage</li> <li>bandwidth footprints</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/mesa-bringup-with-softpipe-llvmpipe/#phase-2-start-replacing-pieces-with-linxgpgpu-kernels","title":"Phase 2 \u2014 start replacing pieces with LinxGPGPU kernels","text":"<ul> <li>Introduce a Linx-target backend where shaders/compute are compiled into MPAR kernels (our SIMT kernel model).</li> <li>Keep fixed-function stages in software initially; ensure correctness.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/mesa-bringup-with-softpipe-llvmpipe/#phase-3-limited-hardening","title":"Phase 3 \u2014 limited hardening","text":"<ul> <li>Use measurement-driven ranking to choose 1 engine at a time to harden.</li> <li>Maintain a strict fallback path to MPAR kernels.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/mesa-bringup-with-softpipe-llvmpipe/#notes-links","title":"Notes / links","text":"<ul> <li>Upstream Mesa driver locations:</li> <li><code>src/gallium/drivers/softpipe/</code></li> <li><code>src/gallium/drivers/llvmpipe/</code></li> </ul>"},{"location":"architecture/v0.4-draft/rendering/pipeline-modes-cpu-plus-shadercore/","title":"v0.4 draft: Rendering pipeline modes (CPU + Shader Core)","text":""},{"location":"architecture/v0.4-draft/rendering/pipeline-modes-cpu-plus-shadercore/#goal","title":"Goal","text":"<p>Support both: - desktop / immediate-mode rendering pipelines - tile-based rendering pipelines</p> <p>The architectural direction is CPU (BCC) + shader core composition: - CPU/BCC builds and schedules work (command buffer lowering, raster/binning software scaffolding, fallbacks). - VEC shader core runs MPAR kernels for parallel stages (compute shading + fallback execution). - TAU hosts hardened shader-like ops/accelerators; handoff state lives in tile registers.</p>"},{"location":"architecture/v0.4-draft/rendering/pipeline-modes-cpu-plus-shadercore/#common-building-blocks","title":"Common building blocks","text":"<ul> <li>Tiles: general-purpose intermediate state storage for cross-engine communication and shared working sets.</li> <li><code>.brg</code>: bridged global memory accesses for both scalar-uniform (<code>l.*.brg</code>) and vector-lane (<code>v.*.brg</code>).</li> <li>Blocks: heterogeneous blocks can target shader core kernels, DMA/clear, and future hardened engines.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/pipeline-modes-cpu-plus-shadercore/#mode-a-immediate-mode-desktop-style","title":"Mode A: Immediate-mode (desktop style)","text":"<p>Concept: - Process primitives in submission order (or reordered batches). - Typical stages (software or kernels):   - command expansion + state setup (CPU/BCC)   - vertex shading (shader core)   - primitive assembly + rasterization (CPU/BCC first; later kernels/engine)   - fragment shading (shader core)   - depth/stencil/blend/writeback (CPU/BCC first; later engine)</p> <p>Benefits: - simpler mental model; aligns with many desktop workloads.</p> <p>Risks: - bandwidth pressure (frequent <code>.brg</code> traffic) - software raster/ROP may dominate until hardened.</p>"},{"location":"architecture/v0.4-draft/rendering/pipeline-modes-cpu-plus-shadercore/#mode-b-tile-based","title":"Mode B: Tile-based","text":"<p>Concept: - Build tile lists, process one tile\u2019s working set largely in local tile storage, then write back.</p> <p>Staging: - Start with CPU/BCC software binning/raster scaffolding. - Gradually move hot loops to kernels or hardened engines.</p>"},{"location":"architecture/v0.4-draft/rendering/pipeline-modes-cpu-plus-shadercore/#open-question-to-be-decided-next","title":"Open question (to be decided next)","text":"<ul> <li>In the first accelerated prototype beyond pure software, what is the minimum shader-core responsibility?</li> <li>shading only (VS/FS/CS)</li> <li>shading + some rasterization</li> <li>shading + ROP-like ops</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-kernel-style/","title":"v0.4 draft: Rendering PTO kernel writing style (recommended)","text":"<p>This is a practical coding style guide for writing rendering-related kernels in <code>workloads/pto_kernels</code>.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-kernel-style/#1-keep-the-same-conventions-as-existing-pto-kernels","title":"1) Keep the same conventions as existing PTO kernels","text":"<ul> <li>Use <code>Tile&lt;Location::Vec, T, 32, 32, ...&gt;</code> and enforce <code>tile_bytes == 4096</code>.</li> <li>Use <code>global_tensor&lt;T, RowMajor&lt;H,W&gt;&gt;</code> + <code>global_iterator&lt;...&gt;</code> for linear buffers.</li> <li>Prefer SoA: one tile per channel.</li> </ul> <p>Example pattern (from <code>add_custom.cpp</code>): - create iterators - nested loops over tile rows/cols - <code>TLOAD</code> tiles \u2192 do ops \u2192 <code>TSTORE</code></p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-kernel-style/#2-rendering-kernel-signatures","title":"2) Rendering kernel signatures","text":"<p>Stage kernels should take: - pointers to global buffers (vertex buffers, index buffers, attachments) - pointers to descriptor/state tables (via <code>.brg</code> pointers in <code>ri*</code> when lowered to Linx) - optional scratch pointers</p> <p>In the early software-first phase, CPU/BCC can marshal these pointers.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-kernel-style/#3-shading-kernels-vec-vs-hardened-ops-tau","title":"3) Shading kernels (VEC) vs hardened ops (TAU)","text":"<ul> <li>VEC kernels: implement shading/compute and serve as fallback.</li> <li>TAU PTOs:</li> <li>TEPL/TileOp10 for stable primitives</li> <li>TAU micro-kernels for complex units</li> <li>tile\u2192tile only (no direct <code>.brg</code>), by current v0.4 direction</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-kernel-style/#4-what-to-avoid-early","title":"4) What to avoid early","text":"<ul> <li>Don\u2019t bind tile meaning to a single rendering pipeline (tile-based only).</li> <li>Don\u2019t overfit to a single pixel format; keep pack/unpack explicit.</li> <li>Don\u2019t introduce hidden global memory effects inside TAU PTOs.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/","title":"v0.4 draft: PTO (Parallel Tile Ops) for rendering","text":""},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#context-goal","title":"Context / goal","text":"<p>We want the full rendering pipeline to be decomposable into small, composable PTO units.</p> <p>Programming model direction (chosen): - Hybrid TAU: PTOs may be expressed as either:   - TEPL/TileOp10 header-only ops (preferred for common/stable units)   - TAU micro-kernels (for complex or evolving units)</p> <p>Architecture direction: - VEC: compute shading + fallback for anything not hardened. - TAU: the primary hardening substrate. - Tile registers: the universal intermediate-state storage used for state handoff between heterogeneous engines/blocks. - BCC/CPU: builds the pipeline in software first (command lowering, scaffolding), then we selectively replace hot regions with TAU PTOs.</p> <p>This document proposes a rendering-oriented PTO catalog (names + signatures + staging plan). It is a planning doc, not a frozen spec.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#0-pto-design-rules-so-it-composes","title":"0) PTO design rules (so it composes)","text":"<p>1) Tile-in / tile-out, minimal side effects - A PTO consumes 0\u2013N input tiles and produces 0\u2013M output tiles. - Avoid hidden global memory side effects; if needed, make memory actions explicit via TMA/DMA blocks.</p> <p>2) Explicit parameters via descriptors - Small constants/state via <code>B.ARG</code>. - Larger state tables via <code>B.IOR</code> pointers (<code>ri*</code>) referencing <code>.brg</code> memory (for example descriptor tables, LUTs).</p> <p>3) I/O arity stays small - Prefer ops with &lt;=3 input tiles and 1 output tile (aligns with strict-v0.3 header constraints). - If more are needed, compose ops (or define v0.4 header extension later).</p> <p>4) Fallback equivalence - Every PTO should have a reference implementation as a VEC MPAR kernel (functional equivalence gate).</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#1-common-tile-payload-conventions-rendering","title":"1) Common tile payload conventions (rendering)","text":"<p>We treat tiles as generic storage; rendering defines conventions for what a tile contains.</p> <p>Recommended early conventions (simple and composable): - Color tile: RGBA vectors for a micro-batch of fragments/pixels (exact packing TBD). - Depth tile: depth values for the same micro-batch. - Stencil/coverage tile: 8-bit stencil and/or 1-bit coverage mask packed in a tile. - Attribute tiles: varyings/intermediate values (N tiles as needed).</p> <p>Important: the \u201cmicro-batch\u201d does not have to be a screen-space tile; it can be any batch chosen by BCC.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#2-pto-families-for-rendering","title":"2) PTO families for rendering","text":""},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#a-tile-utility-packing-high-roi-low-risk","title":"A) Tile utility &amp; packing (high ROI, low risk)","text":"<p>These are foundational and likely needed regardless of pipeline mode.</p> <ul> <li>PTO.TCLEAR: fill a tile with a constant pattern (zero, one, imm32, imm64).</li> <li>in: none or optional mask tile</li> <li>out: one tile</li> <li> <p>params: fill value, element type, stride/packing mode</p> </li> <li> <p>PTO.TPACK / PTO.TUNPACK: convert between tile internal layout and a canonical vector layout.</p> </li> <li>in: one tile</li> <li>out: one tile</li> <li> <p>params: packing mode (RGBA8, RGBA16F, R11G11B10F, etc.)</p> </li> <li> <p>PTO.TCVT: datatype conversion (F16\u2194F32, UNORM\u2194F32, sRGB encode/decode as separate ops).</p> </li> <li>in: one tile</li> <li>out: one tile</li> <li> <p>params: conversion mode, rounding/sat</p> </li> <li> <p>PTO.TSWZ: channel swizzle / replicate / mask.</p> </li> <li>in: one tile</li> <li>out: one tile</li> <li>params: swizzle map, write mask</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#b-fragmentrop-like-ops-prime-hardening-candidates","title":"B) Fragment/ROP-like ops (prime hardening candidates)","text":"<p>These capture operations that are ubiquitous in desktop rendering.</p> <ul> <li>PTO.DEPTH_TEST: compare depth vs existing depth, produce pass mask and optional updated depth.</li> <li>in: depth_in, depth_buf (and optional stencil)</li> <li>out: pass_mask, depth_out (optional)</li> <li> <p>params: func (LESS/LEQUAL/\u2026), write_enable</p> </li> <li> <p>PTO.STENCIL_TEST_OP: stencil compare + update (separate from depth initially).</p> </li> <li>in: stencil_in, stencil_buf, pass_mask(optional)</li> <li>out: stencil_out, new_pass_mask</li> <li> <p>params: func, ref, read_mask, write_mask, ops (fail/zfail/zpass)</p> </li> <li> <p>PTO.BLEND: blend src color with dst color under a mask.</p> </li> <li>in: src_color, dst_color, pass_mask</li> <li>out: out_color</li> <li> <p>params: blend factors, blend ops, color write mask</p> </li> <li> <p>PTO.LOGIC_OP (optional): bitwise logic blend.</p> </li> <li>in: src_color, dst_color</li> <li>out: out_color</li> <li>params: op (AND/OR/XOR/...)</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#c-interpolation-derivatives-shader-support-helpers","title":"C) Interpolation &amp; derivatives (shader support helpers)","text":"<ul> <li>PTO.INTERP_LINEAR: barycentric interpolation for varyings.</li> <li>in: v0, v1, v2, bary_coords (or edge eqs)</li> <li>out: varying_tile</li> <li> <p>params: perspective/linear mode</p> </li> <li> <p>PTO.DERIV_QUAD: compute dFdx/dFdy-like derivatives on a quad layout.</p> </li> <li>in: value_tile</li> <li>out: ddx_tile, ddy_tile</li> <li>params: quad layout policy</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#d-texture-sampling-later-depends-on-memory-cache-policy","title":"D) Texture sampling (later; depends on memory + cache policy)","text":"<p>Texture is expensive but high ROI. We stage it later because it pulls in memory hierarchy and format tables.</p> <ul> <li>PTO.TEX2D_SAMPLE (staged): sample a 2D texture for a batch of coordinates.</li> <li>in: uv_tile, lod_tile(optional)</li> <li>out: texel_tile</li> <li>params: filter mode, address mode</li> <li>resources: descriptors via <code>B.IOR</code> pointer(s) to <code>.brg</code> tables (image/sampler state)</li> </ul> <p>Note: even if texture is ultimately a hardened engine, PTO is a good programming surface.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#e-rasterization-setup-cpu-first-optional-tau-later","title":"E) Rasterization setup (CPU-first; optional TAU later)","text":"<p>Given the current direction (software first), these start on CPU/BCC and move later.</p> <ul> <li>PTO.TRI_SETUP: edge equations / barycentric setup.</li> <li>PTO.COVERAGE: coverage mask generation.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#3-mvp-recommendation-what-to-harden-first","title":"3) MVP recommendation (what to harden first)","text":"<p>If we want a small set that unlocks big wins while keeping the rest on VEC fallback:</p> <p>Tier-0 (plumbing): - TCLEAR, TPACK/TUNPACK, TCVT, TSWZ</p> <p>Tier-1 (desktop must-have): - DEPTH_TEST (+ writeback) - BLEND - STENCIL_TEST_OP (if needed for target apps)</p> <p>Texture can be Tier-2 unless your target apps are texture-dominated.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-ops/#4-open-questions-to-answer-next","title":"4) Open questions (to answer next)","text":"<p>1) What is the first supported render path we target in Vulkan terms?    - simplest: single color attachment, optional depth, no MSAA 2) Which PTO arity constraints do we enforce in v0.4? 3) Tile payload packing for color/depth/mask: define one \u201ccanonical\u201d packing for the first profile.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-tile-conventions/","title":"v0.4 draft: Rendering tile conventions for PTO kernels (layout + data structures)","text":"<p>This document defines initial rendering-oriented conventions on top of the existing PTO tile type system.</p> <p>Principle: tile is generic storage (4KB <code>RawTile</code> carrier). Rendering defines conventions that can evolve.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-tile-conventions/#0-what-we-learned-from-workloadspto_kernels","title":"0) What we learned from <code>workloads/pto_kernels</code>","text":"<ul> <li>A tile is ultimately a 4KB <code>RawTile</code> carrier. On Linx backend it is opaque (vector_size(4096)).</li> <li>The <code>pto::Tile&lt;Location, DType, Rows, Cols, ...&gt;</code> template adds compile-time metadata (dtype, dims, layout).</li> <li>Current kernels often enforce the convention: <code>Rows*Cols*sizeof(DType) == 4096</code>.</li> </ul> <p>Sources: - <code>workloads/pto_kernels/include/pto/linx/impl/backend.hpp</code> (RawTile) - <code>workloads/pto_kernels/kernels/add_custom.cpp</code> (4KB tile convention)</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-tile-conventions/#1-canonical-rendering-tile-profile-initial","title":"1) Canonical rendering tile profile (initial)","text":"<p>We pick a simple, uniform initial profile aligned with the current rendering direction:</p> <ul> <li>Tile element grid: <code>1024 x 1 = 1024</code> elements (single-column)</li> <li>Tile byte size: <code>4096B</code></li> <li>Layout tag: <code>RowMajor</code></li> </ul> <p>Rationale: - Works for <code>float32</code> channels: <code>1024*4B = 4096B</code> - Works for packed RGBA8 as <code>uint32_t</code> per pixel: <code>1024*4B = 4096B</code> - Keeps the data structure list-like and avoids binding semantics to screen-space tiling.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-tile-conventions/#2-data-structures-recommended-soa","title":"2) Data structures (recommended SoA)","text":""},{"location":"architecture/v0.4-draft/rendering/pto-rendering-tile-conventions/#21-fragment-batch-soa","title":"2.1 Fragment batch (SoA)","text":"<p>Represent a batch of fragments/pixels as structure-of-arrays tiles.</p> <p>Recommended minimum set: - <code>pos_x</code>, <code>pos_y</code>, <code>pos_z</code>, <code>pos_w</code> : <code>Tile&lt;Vec, float, 32, 32&gt;</code> (or fewer as needed) - <code>coverage</code> / <code>mask</code> : <code>Tile&lt;Vec, uint32_t, 32, 32&gt;</code> (0/1 or bitfield convention TBD) - <code>color_r/g/b/a</code> : <code>Tile&lt;Vec, float, 32, 32&gt;</code> for shader output in float</p> <p>Optional: - packed output color: <code>Tile&lt;Vec, uint32_t, 32, 32&gt;</code> where each element is <code>RGBA8</code> packed in u32.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-tile-conventions/#22-attachments","title":"2.2 Attachments","text":"<ul> <li>Color attachment (linear) can be treated as a <code>global_tensor&lt;uint32_t, RowMajor&lt;H,W&gt;&gt;</code> for RGBA8.</li> <li>Depth attachment can be <code>global_tensor&lt;uint32_t, RowMajor&lt;H,W&gt;&gt;</code> for D24S8-like packed formats, or <code>float</code>/<code>uint32_t</code> depending on profile.</li> </ul> <p>(We keep formats simple in the first profile; expand later.)</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-tile-conventions/#3-rendering-specific-layouts-format-conventions","title":"3) Rendering-specific layouts (format conventions)","text":"<p>We define format conventions as packing in tile elements, not as a fundamental tile type:</p> <ul> <li><code>RGBA8_UNORM</code>: 1 pixel = 1 <code>uint32_t</code> (packed little-endian RGBA).</li> <li><code>RGBA16F</code> / <code>RGBA32F</code>: stored as 4 separate float tiles (SoA) in the first version.</li> <li><code>Depth32F</code>: 1 depth = 1 float element.</li> </ul> <p>Future (later): add explicit pack/unpack PTOs for sRGB, R11G11B10F, D24S8, etc.</p>"},{"location":"architecture/v0.4-draft/rendering/pto-rendering-tile-conventions/#4-indexing-convention","title":"4) Indexing convention","text":"<p>Define <code>elem = row * kTileW + col</code>.</p> <p>For the initial <code>1024x1</code> profile, this reduces to <code>elem = row</code>.</p> <p>Open item: whether <code>(row,col)</code> should correspond to: - a screen-space micro-tile, or - an arbitrary fragment list produced by CPU/BCC.</p> <p>We will pick one as the initial bring-up convention.</p>"},{"location":"architecture/v0.4-draft/rendering/render-state-conventions/","title":"v0.4 draft: Rendering state conventions (BCC config + StateTiles)","text":"<p>Decision (current direction): - Small/rarely-changing state: configured by BCC via descriptors (<code>B.ARG</code>, possibly <code>B.IOR</code> pointers for VEC). - Large or frequently-referenced state: placed into tile registers as dedicated StateTiles.</p> <p>Rationale: - Keeps hot-path state in tile regs for TAU ops (TAU is tile\u2192tile only; no <code>.brg</code>). - Keeps the command stream compact for small constants.</p>"},{"location":"architecture/v0.4-draft/rendering/render-state-conventions/#examples","title":"Examples","text":""},{"location":"architecture/v0.4-draft/rendering/render-state-conventions/#small-state-bcc-configured","title":"Small state (BCC-configured)","text":"<ul> <li>blend enable flags</li> <li>depth/stencil compare func enums</li> <li>write masks</li> <li>small scalar constants (e.g., clear color)</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/render-state-conventions/#largehot-state-statetiles","title":"Large/hot state (StateTiles)","text":"<ul> <li>descriptor tables (already materialized into tile form)</li> <li>LUTs (gamma/sRGB, etc.)</li> <li>per-draw constant buffers that are reused heavily within a pass</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/render-state-conventions/#open-items","title":"Open items","text":"<ul> <li>Define canonical packing for a <code>RenderStateTile</code> (fields + offsets).</li> <li>Define which state is duplicated per draw vs per pipeline vs per renderpass.</li> <li>How BCC manages lifetime/renaming of StateTiles across blocks.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/tau-as-hardening-substrate/","title":"v0.4 draft: TAU as the hardening substrate (render-first)","text":""},{"location":"architecture/v0.4-draft/rendering/tau-as-hardening-substrate/#decision-direction","title":"Decision direction","text":"<ul> <li>VEC is the general-purpose kernel engine (compute shading + fallback).</li> <li>TAU (Tile Arithmetic Unit) is the primary target for limited hardening:</li> <li>hardened shader-like operations</li> <li>accelerator kernels that are common and ROI-positive</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/tau-as-hardening-substrate/#key-contract-tile-registers-as-the-handoff-medium","title":"Key contract: tile registers as the handoff medium","text":"<ul> <li>Intermediate state passed between heterogeneous engines/blocks is stored in tile registers.</li> <li>TAU operations should consume/produce tiles, enabling:</li> <li>cheap handoff (no round-trip to <code>.brg</code> unless needed)</li> <li>clear dependency tracking via tile descriptors</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/tau-as-hardening-substrate/#relationship-to-isa-block-types","title":"Relationship to ISA block types","text":"<ul> <li>In v0.3, tile-oriented template ops are staged under <code>BSTART.TEPL</code> and conceptually map to TAU execution.</li> <li>In v0.4, we extend this idea to rendering:</li> <li>represent hardened shader fragments as TAU-executable ops (likely TEPL-like) with well-defined tile IO.</li> <li>keep a strict fallback path: if a shader cannot be matched/lowered, compile it to VEC MPAR kernels.</li> </ul>"},{"location":"architecture/v0.4-draft/rendering/tau-as-hardening-substrate/#what-we-still-need-to-decide","title":"What we still need to decide","text":"<p>1) Offload granularity    - whole shader stage to TAU?    - or partial offload: replace subgraphs/regions with TAU ops and run the rest on VEC?</p> <p>2) TAU op programming model (chosen direction)    - Hybrid:      - common, stable PTOs are header-only TEPL-like ops (TileOp10 space)      - complex/evolving units can use a TAU micro-kernel model</p> <p>TAU micro-kernel I/O contract (chosen direction): - Micro-kernels use the standard tile-block descriptor interface:   - tiles via <code>B.IOT/B.IOTI</code>   - small params via <code>B.ARG</code>   - external tables/pointers via <code>B.IOR</code> (<code>ri*</code>)</p> <p>3) Tile payload layout for rendering    - how pixels/fragments/attributes are packed into tile registers    - how many channels and formats are supported in the first profile</p> <p>4) Memory interactions (chosen direction)    - TAU micro-kernels and TEPL PTOs are tile\u2192tile only.    - No direct <code>.brg</code> access from TAU; any global-memory interaction is via explicit TMA/DMA blocks or VEC fallback.</p>"},{"location":"architecture/v0.4-draft/rendering/tile-based-rendering-on-linx/","title":"v0.4 draft: Tile-based rendering on Linx (open design)","text":""},{"location":"architecture/v0.4-draft/rendering/tile-based-rendering-on-linx/#positioning","title":"Positioning","text":"<ul> <li>Tile-based rendering is one optional strategy we want to support.</li> <li>We also want to support desktop/immediate-mode style rendering.</li> <li>Linx \u201ctile\u201d is general-purpose intermediate state storage; screen-space tiling is built on top of it when we choose the tile-based strategy.</li> </ul> <p>Caveat: - Linx \u201ctile\u201d (tile registers, TA/TB/TO/TS bases, TLOAD/TSTORE, etc.) may not map 1:1 onto conventional TBDR tiles.</p>"},{"location":"architecture/v0.4-draft/rendering/tile-based-rendering-on-linx/#what-we-must-define-linx-specific","title":"What we must define (Linx-specific)","text":"<p>1) What is a tile?</p> <p>Chosen direction: - A tile is general-purpose intermediate state storage: the shared medium for data exchange and state handoff across heterogeneous engines/blocks (shader kernels, DMA/clear, future texture/ROP/tiler engines, etc.). - It is not inherently a screen-space tile; screen-space tiling is a higher-level rendering strategy built on top of this general tile storage.</p> <p>2) Tile size(s) and shapes    - Screen-space tile sizes (e.g. 8x8, 16x16, 32x32 pixels)?    - Relationship to tile register sizes (512B..4KB) and data formats.</p> <p>3) Where does binning live?</p> <p>Chosen staging: - First implementation uses BCC / scalar-block software logic to build tile lists/binning structures. - Future: migrate hot paths to MPAR kernels and/or a hardened tiler/binner engine once measured.</p> <p>4) Pass structure mapping    - Vulkan renderpass/subpass boundaries \u2192 which blocks/engines?    - When do we flush tile contents to global memory (<code>*.brg</code> stores)?</p> <p>5) MSAA / compression / depth formats    - staged bring-up: disable first    - later: decide whether to harden ROP-like functionality</p>"},{"location":"architecture/v0.4-draft/rendering/tile-based-rendering-on-linx/#recommended-staged-approach","title":"Recommended staged approach","text":"<ul> <li>First get Vulkan running (software baseline).</li> <li>Then implement a tile-based path that:</li> <li>bins primitives to tiles in software</li> <li>shades a tile in MPAR kernel using tile-local working set</li> <li>resolves/writes out via <code>.brg</code></li> <li>Only then decide what to harden.</li> </ul>"},{"location":"bringup/","title":"LinxISA Bring-up (Public v0.3)","text":"<p>This directory tracks v0.3 architecture/implementation alignment and public bring-up checkpoints.</p>"},{"location":"bringup/#start-here","title":"Start Here","text":"<ul> <li>Onboarding and workspace setup: <code>docs/bringup/GETTING_STARTED.md</code></li> </ul>"},{"location":"bringup/#normative-contract","title":"Normative Contract","text":"<ul> <li>Architecture contract: <code>docs/architecture/v0.3-architecture-contract.md</code></li> <li>check26 contract file: <code>docs/bringup/check26_contract.yaml</code></li> <li>contract gate: <code>python3 tools/bringup/check26_contract.py --root .</code></li> </ul>"},{"location":"bringup/#key-references","title":"Key References","text":"<ul> <li><code>docs/bringup/CHECK26_CONTRACT.md</code></li> <li><code>docs/bringup/CPP_BRINGUP_CONTRACT.md</code></li> <li><code>docs/bringup/PROGRESS.md</code></li> <li><code>docs/bringup/gates/latest.json</code> (canonical machine-readable gate report)</li> <li><code>docs/bringup/GATE_STATUS.md</code> (generated from gate report JSON)</li> <li><code>docs/bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST.md</code></li> <li><code>docs/bringup/CROSSSTACK_SKILLS_SUMMARY.md</code></li> <li><code>docs/bringup/agent_runs/manifest.yaml</code> (machine-readable multi-agent gate ownership map)</li> <li><code>docs/bringup/agent_runs/waivers.yaml</code> (tracked explicit waiver ledger)</li> <li><code>docs/bringup/agent_runs/checklists/</code> (per-domain execution checklists with stable IDs)</li> <li><code>docs/reference/linxisa-call-ret-contract.md</code></li> <li><code>docs/bringup/phases/</code></li> <li><code>docs/bringup/contracts/</code></li> </ul>"},{"location":"bringup/#path-variables-in-gate-reports-portable","title":"Path Variables in Gate Reports (portable)","text":"<p>Checked-in gate reports under <code>docs/bringup/gates/</code> use <code>${...}</code> placeholders instead of machine-specific absolute paths.</p> <p>Recommended defaults for an in-tree (pinned) checkout:</p> <ul> <li><code>LINXISA_ROOT</code> = repo root</li> <li><code>LLVM_ROOT</code> = <code>${LINXISA_ROOT}/compiler/llvm</code></li> <li><code>QEMU_ROOT</code> = <code>${LINXISA_ROOT}/emulator/qemu</code></li> <li><code>LINUX_ROOT</code> = <code>${LINXISA_ROOT}/kernel/linux</code></li> <li><code>PYCIRCUIT_ROOT</code> = <code>${LINXISA_ROOT}/tools/pyCircuit</code></li> <li><code>LINXCORE_ROOT</code> = <code>${LINXISA_ROOT}/rtl/LinxCore</code></li> <li><code>GLIBC_ROOT</code> = <code>${LINXISA_ROOT}/lib/glibc</code></li> <li><code>MUSL_ROOT</code> = <code>${LINXISA_ROOT}/lib/musl</code></li> </ul> <p>For the \"external\" lane, set these variables to point at your external clones/builds if you intentionally keep toolchains outside the superproject.</p> <p>Gate status markdown refresh command:</p> <p><code>python3 tools/bringup/gate_report.py render --report docs/bringup/gates/latest.json --out-md docs/bringup/GATE_STATUS.md</code></p> <p>Multi-agent strict static checklist gate:</p> <p><code>python3 tools/bringup/check_multi_agent_gates.py --strict-always --mode static --manifest docs/bringup/agent_runs/manifest.yaml --waivers docs/bringup/agent_runs/waivers.yaml --checklists-root docs/bringup/agent_runs/checklists</code></p> <p>Multi-agent strict runtime closure gate (per lane/run):</p> <p><code>python3 tools/bringup/check_multi_agent_gates.py --strict-always --mode runtime --manifest docs/bringup/agent_runs/manifest.yaml --waivers docs/bringup/agent_runs/waivers.yaml --checklists-root docs/bringup/agent_runs/checklists --report docs/bringup/gates/latest.json --lane pin --run-id &lt;run-id&gt; --out docs/bringup/gates/logs/&lt;run-id&gt;/pin/multi_agent_summary.json</code></p> <p>Release-strict bring-up consistency checks:</p> <ul> <li><code>python3 tools/bringup/check_check26_coverage.py --matrix avs/linx_avs_v1_test_matrix.yaml --contract docs/bringup/check26_contract.yaml --status avs/linx_avs_v1_test_matrix_status.json --profile release-strict</code></li> <li><code>python3 tools/bringup/run_model_diff_suite.py --root . --suite avs/model/linx_model_diff_suite.yaml --profile release-strict --trace-schema-version 1.0 --report-out docs/bringup/gates/model_diff_summary.json</code></li> <li><code>python3 tools/bringup/check_avs_matrix_status.py --matrix avs/linx_avs_v1_test_matrix.yaml --status avs/linx_avs_v1_test_matrix_status.json --report-out docs/bringup/gates/avs_matrix_status_audit.json</code></li> <li><code>python3 tools/bringup/check_qemu_opcode_meta_sync.py --allowlist docs/bringup/qemu_opcode_sync_allowlist.json --report-out docs/bringup/gates/qemu_opcode_sync_latest.json --out-md docs/bringup/gates/qemu_opcode_sync_latest.md</code></li> <li><code>python3 tools/bringup/report_qemu_isa_coverage.py --report-out docs/bringup/gates/qemu_isa_coverage_latest.json --out-md docs/bringup/gates/qemu_isa_coverage_latest.md</code></li> <li><code>python3 tools/bringup/check_linx_virt_defconfig_spec.py --report-out docs/bringup/gates/linxisa_virt_defconfig_audit.json</code></li> <li><code>python3 tools/bringup/check_gate_consistency.py --report docs/bringup/gates/latest.json --progress docs/bringup/PROGRESS.md --gate-status docs/bringup/GATE_STATUS.md --libc-status docs/bringup/libc_status.md --avs-matrix-audit docs/bringup/gates/avs_matrix_status_audit.json --qemu-opcode-sync docs/bringup/gates/qemu_opcode_sync_latest.json --qemu-isa-coverage docs/bringup/gates/qemu_isa_coverage_latest.json --linux-defconfig-audit docs/bringup/gates/linxisa_virt_defconfig_audit.json --require-maturity-artifacts --profile release-strict --lane-policy external+pin-required --trace-schema-version 1.0 --multi-agent-summary docs/bringup/gates/logs/&lt;run-id&gt;/&lt;lane&gt;/multi_agent_summary.json --max-age-hours 24</code></li> </ul>"},{"location":"bringup/ALIGNMENT_MATRIX/","title":"Alignment Matrix","text":"<p>This matrix tracks cross-domain alignment at the current workspace scope.</p> Topic Spec Compiler Emulator Kernel Model Evidence Linx Linux libc ABI + relocation contract (<code>EM_LINXISA</code>, <code>R_LINX_*</code>, <code>setjmp/signal/ucontext</code>) \u2705 ABI guide/checklist + musl/glibc header sync \u2705 workspace clang call/ret relocation+template gates pass (<code>FENTRY/FRET.STK</code> vs musttail <code>FENTRY/FEXIT</code>) \u2705 strict lane runtime gates pass (musl runtime + glibc G1b + strict system + model-diff) \u2705 smoke/full/busybox/virtio-disk boot gates pass \u2705 qemu-vs-pyc commit diff pass <code>docs/bringup/gates/latest.json</code>; <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/lib_musl_both.log</code>; <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/lib_glibc_g1b.log</code>; <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/model_diff_suite.log</code> Block/descriptor contracts (<code>B.ARG/B.IOR/B.IOT/C.B.DIMI</code>) \u2705 manual + generated refs \u2705 descriptor emission/tests \u2705 descriptor execution + AVS gates \u2705 userspace boot not regressed \u2705 trace-compatible bring-up subset <code>bash tools/regression/run.sh</code> ACR/IRQ/exception correctness \u2705 privileged chapter + trap table \u2705 MC symbols + encodings \u2705 strict system tests \u2705 smoke/full/virtio boots pass \u2705 qemu-vs-pyc commit diff pass <code>avs/qemu/check_system_strict.sh</code> ISA catalog parity (<code>v0.3</code>) \u2705 golden + current json \u2705 compile coverage tests \u2705 decode/execute gates \u2705 no legacy refs in runtime scripts \u2705 model-side contract checks <code>python3 tools/isa/check_no_legacy_v03.py --root .</code> ISA breadth tracking (spec vs QEMU implementation) \u2705 canonical spec catalog (<code>710</code> unique mnemonics) \u2705 compile/disasm coverage remains 100% for implemented toolchain surface \u26a0 mapped QEMU coverage is <code>311/710</code> (gap tracked as artifact, not waived) \u2705 kernel runtime closure remains green while breadth expands incrementally \u2705 model suite remains required and passing for implemented subsets <code>docs/bringup/gates/qemu_isa_coverage_latest.json</code>; <code>docs/bringup/gates/qemu_isa_coverage_latest.md</code> AVS consolidation \u2705 matrix maintained in <code>avs/</code> \u2705 compile tests under <code>avs/compiler/linx-llvm/tests</code> \u2705 runtime tests under <code>avs/qemu</code> \u2705 n/a \u2705 n/a <code>bash tools/ci/check_repo_layout.sh</code>"},{"location":"bringup/CHECK26_CONTRACT/","title":"LinxISA Strict 26-Check Contract (v0.3 current)","text":"<p>Last updated: 2026-02-12</p> <p>This document freezes the architectural contract from <code>docs/architecture/v0.3-architecture-contract.md</code> into a machine-checkable ledger used by bring-up gates.</p> <p>Machine-readable source:</p> <ul> <li><code>./docs/bringup/check26_contract.yaml</code></li> <li>Gate script: <code>./tools/bringup/check26_contract.py</code></li> </ul>"},{"location":"bringup/CHECK26_CONTRACT/#numbering-policy","title":"Numbering policy","text":"<ul> <li>The source text contains two sections labeled \"Check 15\".</li> <li>In the strict contract they are represented as:</li> <li><code>Check 15</code> (generic <code>BSTART.TEPL</code> interface)</li> <li><code>Check 15</code>, clause <code>2</code> (FP-hint behavior of <code>BSTART.FP</code>)</li> <li>The contract still contains exactly 26 checks (<code>1..26</code>).</li> </ul>"},{"location":"bringup/CHECK26_CONTRACT/#scope","title":"Scope","text":"<p>Each check in the machine ledger contains:</p> <ul> <li>norm text clauses (<code>clauses[]</code>)</li> <li>implementation owner references (<code>owners[]</code>)</li> <li>required verification references (<code>tests[]</code>)</li> <li>required canonical text/encoding tokens (<code>patterns[]</code>)</li> </ul> <p>The gate enforces:</p> <ol> <li>exactly 26 checks with contiguous IDs <code>1..26</code>,</li> <li>no empty clauses/owners/tests,</li> <li>every required pattern exists in canonical v0.3 artifacts.</li> </ol>"},{"location":"bringup/CHECK26_CONTRACT/#required-canonical-artifacts","title":"Required canonical artifacts","text":"<p>Pattern scanning is restricted to the strict v0.3 source-of-truth artifacts:</p> <ul> <li><code>./isa/v0.3/opcodes/lx_32.opc</code></li> <li><code>./isa/v0.3/state/memory_model.json</code></li> <li><code>./docs/architecture/isa-manual/src/chapters/02_programming_model.adoc</code></li> <li><code>./docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code></li> <li><code>./docs/architecture/isa-manual/src/chapters/08_memory_operations.adoc</code></li> <li><code>./docs/architecture/isa-manual/src/chapters/09_system_and_privilege.adoc</code></li> </ul>"},{"location":"bringup/CHECK26_CONTRACT/#exit-criteria","title":"Exit criteria","text":"<ul> <li><code>python3 ./tools/bringup/check26_contract.py --root .</code> returns <code>OK</code>.</li> </ul>"},{"location":"bringup/CPP_BRINGUP_CONTRACT/","title":"Linx C++ Bring-up Contract (C++17, LLVM stack, musl-first)","text":"<p>This document freezes the hosted C++ bring-up contract for LinxISA so gate scripts and reports use one deterministic policy.</p>"},{"location":"bringup/CPP_BRINGUP_CONTRACT/#scope","title":"Scope","text":"<ul> <li>Primary runtime stack: <code>compiler-rt</code> + <code>libunwind</code> + <code>libc++abi</code> + <code>libc++</code>.</li> <li>Language baseline: <code>-std=c++17</code>.</li> <li>Bring-up profile <code>CXX17_NOEH</code>:</li> <li><code>-fno-exceptions</code></li> <li><code>-fno-rtti</code></li> <li>libc order: musl lane first, glibc lane second.</li> <li>Promotion policy: both <code>pin</code> and <code>external</code> lanes must pass.</li> </ul>"},{"location":"bringup/CPP_BRINGUP_CONTRACT/#triple-and-lane-contract","title":"Triple and lane contract","text":"<ul> <li>Baremetal compile lane: <code>linx64-linx-none-elf</code> and <code>linx32-linx-none-elf</code>.</li> <li>Hosted Linux musl lane: <code>linx64-unknown-linux-musl</code>.</li> <li>Hosted Linux glibc lane (follow-up): <code>linx64-unknown-linux-gnu</code>.</li> </ul> <p>Lane roles:</p> <ul> <li><code>pin</code> lane: reproducible baseline from superproject submodule SHAs.</li> <li><code>external</code> lane: integration health against active external heads.</li> </ul> <p>Promotion rule:</p> <ul> <li>Never promote runtime/C++ status to green from one lane only.</li> <li>Require matching pass classification and evidence in both lanes.</li> </ul>"},{"location":"bringup/CPP_BRINGUP_CONTRACT/#clang-driver-contract","title":"Clang driver contract","text":"<ul> <li>Linx cross links must not route through host C++ drivers.</li> <li>Default linker for Linx Linux and Linx baremetal flows is <code>ld.lld</code>.</li> <li>Linux Linx default C++ runtime policy in this phase:</li> <li><code>stdlib=libc++</code></li> <li><code>rtlib=compiler-rt</code></li> <li><code>unwindlib=libunwind</code> (policy target for hosted C++ gates)</li> </ul>"},{"location":"bringup/CPP_BRINGUP_CONTRACT/#sysroot-contract-musl","title":"Sysroot contract (musl)","text":"<p>Musl sysroot base:</p> <ul> <li><code>out/libc/musl/install/&lt;mode&gt;/</code></li> </ul> <p>LLVM C++ runtime overlay install root:</p> <ul> <li><code>out/cpp-runtime/musl-cxx17-noeh/install/</code></li> </ul> <p>Expected hosted C++ layout consumed by clang:</p> <ul> <li>Headers:</li> <li><code>&lt;overlay&gt;/include/c++/v1</code></li> <li>Runtime libs:</li> <li><code>&lt;overlay&gt;/lib/libc++.a</code></li> <li><code>&lt;overlay&gt;/lib/libc++abi.a</code></li> <li><code>&lt;overlay&gt;/lib/libunwind.a</code></li> <li><code>&lt;overlay&gt;/lib/clang/&lt;ver&gt;/lib/linx64/libclang_rt.builtins-*.a</code> (or arch-equivalent)</li> </ul> <p>Merge/install policy:</p> <ul> <li>Overlay artifacts are copied into the active musl sysroot for AVS/QEMU gates.</li> <li>No hidden host include/lib fallback is allowed in gate commands.</li> </ul>"},{"location":"bringup/CPP_BRINGUP_CONTRACT/#gate-ids-and-evidence-policy","title":"Gate IDs and evidence policy","text":"<p>New AVS IDs are reserved for C++ bring-up and recorded in:</p> <ul> <li><code>avs/linx_avs_v1_test_matrix.yaml</code></li> <li><code>avs/linx_avs_v1_test_matrix_status.json</code></li> </ul> <p>Gate evidence must include:</p> <ul> <li>exact command</li> <li>lane (<code>pin</code> or <code>external</code>)</li> <li>SHA manifest (llvm/qemu/linux/musl/glibc/...)</li> <li>pass/fail classification</li> <li>artifact paths (logs + summaries)</li> </ul>"},{"location":"bringup/CPP_BRINGUP_CONTRACT/#canonical-commands","title":"Canonical commands","text":"<p>Build/install musl C++ runtime overlay:</p> <pre><code>bash tools/build_linx_llvm_cpp_runtimes.sh --mode phase-b\n</code></pre> <p>C++ compile gate:</p> <pre><code>(cd avs/compiler/linx-llvm/tests &amp;&amp; ./run_cpp.sh)\n</code></pre> <p>Musl C++ runtime smoke gate:</p> <pre><code>python3 avs/qemu/run_musl_smoke.py --mode phase-b --link both --sample cpp17_smoke\n</code></pre>"},{"location":"bringup/CROSSSTACK_SKILLS_SUMMARY/","title":"Linx Cross-Stack Skills Summary","text":"<p>This note summarizes practical skills and review focus for Linx call/ret and libc bring-up across Linux, LLVM, QEMU, and libc stacks.</p>"},{"location":"bringup/CROSSSTACK_SKILLS_SUMMARY/#linux","title":"Linux","text":"<ul> <li>Validate emitted call/ret patterns in kernel objects (<code>entry.o</code>, <code>switch_to.o</code>, <code>panic.o</code>).</li> <li>Keep return/indirect paths explicit (<code>BSTART.RET/IND</code> + <code>setc.tgt</code>).</li> <li>Cross-check with:</li> <li><code>${LINUX_ROOT}/arch/linx/kernel/entry.S</code></li> <li><code>${LINUX_ROOT}/arch/linx/kernel/switch_to.S</code></li> <li>Gate with <code>tools/ci/check_linx_callret_crossstack.sh</code>.</li> </ul>"},{"location":"bringup/CROSSSTACK_SKILLS_SUMMARY/#llvm","title":"LLVM","text":"<ul> <li>Enforce call-header adjacency (<code>BSTART.CALL</code> followed immediately by setret form).</li> <li>Keep musttail lowering on <code>FEXIT</code> tail-transfer path; non-tail on <code>FRET.STK</code>.</li> <li>Preserve stable MC/disasm fused view (<code>CALL ..., ra=...</code>) and relocation legality.</li> <li>Add lit coverage for:</li> <li>normal call/return shape</li> <li>musttail tail-transfer shape</li> <li>call-header adjacency constraints</li> </ul>"},{"location":"bringup/CROSSSTACK_SKILLS_SUMMARY/#qemu","title":"QEMU","text":"<ul> <li>Treat strict contract violations as deterministic traps:</li> <li>missing setret</li> <li>invalid setret sequence</li> <li>missing <code>setc.tgt</code> for <code>RET/IND/ICALL</code></li> <li>Validate dynamic targets as legal block starts before transfer.</li> <li>Preserve call-header contract across TB boundaries (translator state must not be lost).</li> <li>Support all setret widths (<code>c.setret</code>, <code>setret</code>, <code>hl.setret</code> alias path).</li> </ul>"},{"location":"bringup/CROSSSTACK_SKILLS_SUMMARY/#musl","title":"musl","text":"<ul> <li>Keep linx64 arch ABI concrete (no riscv-derived placeholder layouts).</li> <li>Replace stubs with arch asm for <code>clone</code>, <code>sigsetjmp</code>, restorer, <code>__unmapself</code>, ldso paths.</li> <li>Keep relocation contract aligned to canonical <code>R_LINX_*</code>.</li> <li>Gate static/shared runtime behavior with <code>avs/qemu/run_musl_smoke.py</code>.</li> </ul>"},{"location":"bringup/CROSSSTACK_SKILLS_SUMMARY/#glibc","title":"glibc","text":"<ul> <li>Keep syscall/trap mechanism aligned with Linx contract (<code>acrc 1</code> path).</li> <li>Keep relocation numbering and setjmp/signal/ucontext contracts aligned with Linux UAPI and musl.</li> <li>Avoid fallback relocation/shim behavior that diverges from musl/QEMU expectations.</li> </ul>"},{"location":"bringup/CROSSSTACK_SKILLS_SUMMARY/#common-review-checklist","title":"Common Review Checklist","text":"<ol> <li>Call headers: returning calls always have adjacent setret form.</li> <li>Return/indirect: every <code>RET/IND/ICALL</code> path has explicit <code>setc.tgt</code>.</li> <li>Targets: dynamic targets are block starts.</li> <li>Tail calls: <code>FENTRY + FEXIT</code> only on musttail/tail-transfer path.</li> <li>Runtime gates: compiler-only + freestanding QEMU + Linux+musl all pass.</li> </ol>"},{"location":"bringup/GATE_STATUS/","title":"Bring-up Gate Status (Canonical)","text":"<p>This file is generated from <code>docs/bringup/gates/latest.json</code> via <code>python3 tools/bringup/gate_report.py render</code>.</p> <p>Last generated (UTC): <code>2026-02-25 12:41:30Z</code></p>"},{"location":"bringup/GATE_STATUS/#lane-external-2026-02-17-r1-external","title":"Lane <code>external</code> (<code>2026-02-17-r1-external</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 04:32:23Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>04e750e75b73957cf1c791535a3f4319534a52fc</code> (<code>${GLIBC_ROOT}</code>)</li> <li><code>linux</code>: <code>9e37586596e85a1985bef53f597d0c75e4a9a215</code> (<code>${LINUX_ROOT}</code>)</li> <li><code>linxcore</code>: <code>fbb0450d98db2d9d33fb2e339cf32bc1a6c91493</code> (<code>${LINXCORE_ROOT}</code>)</li> <li><code>llvm</code>: <code>8ee471fd9882e4d0099ff5425f12528e98fe8aaf</code> (<code>${LLVM_ROOT}</code>)</li> <li><code>musl</code>: <code>missing</code> (<code>${MUSL_ROOT}</code>)</li> <li><code>pycircuit</code>: <code>edc3ef51110b339d64d034db39acb26e0a9a6c53</code> (<code>${PYCIRCUIT_ROOT}</code>)</li> <li><code>qemu</code>: <code>712f581e9a13f664118b3cf8c509b919c3ec4b87</code> (<code>${QEMU_ROOT}</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Kernel Linux initramfs full boot yes no <code>unowned</code> <code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u274c fail (<code>trap_loop_pc_0x31f85c</code>) <code>terminal: repeated [linx trap] pc=0x000000000031f85c</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u274c fail (<code>trap_loop_pc_0x31f85c</code>) <code>terminal: repeated [linx trap] pc=0x000000000031f85c</code> RTL LinxCore co-sim smoke yes no <code>unowned</code> <code>bash ${LINXCORE_ROOT}/tests/test_cosim_smoke.sh</code> \u2705 pass (<code>cosim_smoke_pass</code>) <code>terminal: test_cosim_smoke.sh PASS</code>"},{"location":"bringup/GATE_STATUS/#lane-external-2026-02-17-r1-external-phase2c","title":"Lane <code>external</code> (<code>2026-02-17-r1-external-phase2c</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 11:12:06Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>04e750e75b73957cf1c791535a3f4319534a52fc</code> (<code>${GLIBC_ROOT}</code>)</li> <li><code>linux</code>: <code>9e37586596e85a1985bef53f597d0c75e4a9a215</code> (<code>${LINUX_ROOT}</code>)</li> <li><code>linxcore</code>: <code>b3bbe65ee5fcecc69631b46554d4789122c57f2c</code> (<code>${LINXCORE_ROOT}</code>)</li> <li><code>llvm</code>: <code>5289c65ce582a8d71fdaecc95b5a16eae43f9fcc</code> (<code>${LLVM_ROOT}</code>)</li> <li><code>musl</code>: <code>missing</code> (<code>${MUSL_ROOT}</code>)</li> <li><code>pycircuit</code>: <code>273eff570b670aec8795c85c5c7223f2cd6b22a5</code> (<code>${PYCIRCUIT_ROOT}</code>)</li> <li><code>qemu</code>: <code>712f581e9a13f664118b3cf8c509b919c3ec4b87</code> (<code>${QEMU_ROOT}</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${QEMU_ROOT}/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${QEMU_ROOT}/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${QEMU_ROOT}/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${QEMU_ROOT}/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/kernel_smoke.log</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${QEMU_ROOT}/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/lib_musl_both.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=external QEMU=${QEMU_ROOT}/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 ALLOW_GLIBC_G1_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase2c/external/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-external-2026-02-17-r1-external-phase3","title":"Lane <code>external</code> (<code>2026-02-17-r1-external-phase3</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 11:37:03Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>04e750e75b73957cf1c791535a3f4319534a52fc</code> (<code>${GLIBC_ROOT}</code>)</li> <li><code>linux</code>: <code>9e37586596e85a1985bef53f597d0c75e4a9a215</code> (<code>${LINUX_ROOT}</code>)</li> <li><code>linxcore</code>: <code>b3bbe65ee5fcecc69631b46554d4789122c57f2c</code> (<code>${LINXCORE_ROOT}</code>)</li> <li><code>llvm</code>: <code>5289c65ce582a8d71fdaecc95b5a16eae43f9fcc</code> (<code>${LLVM_ROOT}</code>)</li> <li><code>musl</code>: <code>missing</code> (<code>${MUSL_ROOT}</code>)</li> <li><code>pycircuit</code>: <code>273eff570b670aec8795c85c5c7223f2cd6b22a5</code> (<code>${PYCIRCUIT_ROOT}</code>)</li> <li><code>qemu</code>: <code>712f581e9a13f664118b3cf8c509b919c3ec4b87</code> (<code>${QEMU_ROOT}</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${QEMU_ROOT}/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${QEMU_ROOT}/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${QEMU_ROOT}/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${QEMU_ROOT}/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=1 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u2705 pass (<code>glibc_g1b_pass_or_allowed_blocked</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/lib_glibc_g1b.log</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${QEMU_ROOT}/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/lib_musl_both.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=external QEMU=${QEMU_ROOT}/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=0 ALLOW_GLIBC_G1_BLOCKED=1 GLIBC_G1B_ALLOW_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase3/external/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-external-2026-02-17-r1-external-phase4","title":"Lane <code>external</code> (<code>2026-02-17-r1-external-phase4</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 11:50:29Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>04e750e75b73957cf1c791535a3f4319534a52fc</code> (<code>${GLIBC_ROOT}</code>)</li> <li><code>linux</code>: <code>9e37586596e85a1985bef53f597d0c75e4a9a215</code> (<code>${LINUX_ROOT}</code>)</li> <li><code>linxcore</code>: <code>b3bbe65ee5fcecc69631b46554d4789122c57f2c</code> (<code>${LINXCORE_ROOT}</code>)</li> <li><code>llvm</code>: <code>5289c65ce582a8d71fdaecc95b5a16eae43f9fcc</code> (<code>${LLVM_ROOT}</code>)</li> <li><code>musl</code>: <code>missing</code> (<code>${MUSL_ROOT}</code>)</li> <li><code>pycircuit</code>: <code>273eff570b670aec8795c85c5c7223f2cd6b22a5</code> (<code>${PYCIRCUIT_ROOT}</code>)</li> <li><code>qemu</code>: <code>712f581e9a13f664118b3cf8c509b919c3ec4b87</code> (<code>${QEMU_ROOT}</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${QEMU_ROOT}/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${QEMU_ROOT}/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${QEMU_ROOT}/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${QEMU_ROOT}/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=1 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u2705 pass (<code>glibc_g1b_pass_or_allowed_blocked</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/lib_glibc_g1b.log</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${QEMU_ROOT}/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/lib_musl_both.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=external QEMU=${QEMU_ROOT}/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=0 ALLOW_GLIBC_G1_BLOCKED=1 GLIBC_G1B_ALLOW_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4/external/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-external-2026-02-17-r1-external-phase4b","title":"Lane <code>external</code> (<code>2026-02-17-r1-external-phase4b</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 19:09:56Z</code></li> <li>Profile: <code>release-strict</code></li> <li>Lane policy: <code>external+pin-required</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>04e750e75b73957cf1c791535a3f4319534a52fc</code> (<code>${GLIBC_ROOT}</code>)</li> <li><code>linux</code>: <code>812f083bc29e075577b1a5ec7782b4ae9cebd428</code> (<code>${LINUX_ROOT}</code>)</li> <li><code>linxcore</code>: <code>d9898156083b2174931ccf4c634421784fc1c881</code> (<code>${LINXCORE_ROOT}</code>)</li> <li><code>llvm</code>: <code>55a7e27b80ba06bd3db9a098703256802d8fb9ea</code> (<code>${LLVM_ROOT}</code>)</li> <li><code>musl</code>: <code>missing</code> (<code>${MUSL_ROOT}</code>)</li> <li><code>pycircuit</code>: <code>5fe8de17b648a997d49fa863d11418aa06abdea3</code> (<code>${PYCIRCUIT_ROOT}</code>)</li> <li><code>qemu</code>: <code>712f581e9a13f664118b3cf8c509b919c3ec4b87</code> (<code>${QEMU_ROOT}</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${QEMU_ROOT}/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${QEMU_ROOT}/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${QEMU_ROOT}/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${QEMU_ROOT}/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=1 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u2705 pass (<code>glibc_g1b_pass_shared_libc_so_built</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/lib_glibc_g1b.log</code>; <code>summary:${LINXISA_ROOT}/out/libc/glibc/logs/g1b-summary.txt</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${QEMU_ROOT}/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/lib_musl_both.log</code> Model QEMU vs model differential suite yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/run_model_diff_suite.py --root ${LINXISA_ROOT} --suite ${LINXISA_ROOT}/avs/model/linx_model_diff_suite.yaml --profile release-strict --trace-schema-version 1.0 --report-out ${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/model_diff_summary.json</code> \u2705 pass (<code>model_diff_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/model_diff_suite.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=external QEMU=${QEMU_ROOT}/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=0 ALLOW_GLIBC_G1_BLOCKED=1 GLIBC_G1B_ALLOW_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-17-r1-pin","title":"Lane <code>pin</code> (<code>2026-02-17-r1-pin</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 19:41:53Z</code></li> <li>Profile: <code>release-strict</code></li> <li>Lane policy: <code>external+pin-required</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>5d20f2c3a1f33b5d81720638fee82ac091a635ff</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>37a93dd5c49b5fda807fd204edf2547c3493319c</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>10f457bf75996c96901b91b2bd05e39fee20ab1c</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>d390d4890d5863697935275a3aa2598759b7cc00</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>a079402e5d09e5a86bc703eb203d735ed057708f</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>f9e7978f67374572cc1b0f032fd1ed85470e1f11</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>feee44880b063477a4908c496ffb8139096a574e</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>d8bfcfcb7909a261a689f19d469cb77f59ba940a</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>glibc</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=0 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u2705 pass (<code>glibc_g1b_pass_shared_libc_so_built</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/lib_glibc_g1b.log</code>; <code>summary:${LINXISA_ROOT}/out/libc/glibc/logs/g1b-summary.txt</code> Library musl runtime static+shared yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/lib_musl_both.log</code> Model QEMU vs model differential suite yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/run_model_diff_suite.py --root ${LINXISA_ROOT} --suite ${LINXISA_ROOT}/avs/model/linx_model_diff_suite.yaml --profile release-strict --trace-schema-version 1.0 --report-out ${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/model_diff_summary.json</code> \u2705 pass (<code>model_diff_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/model_diff_suite.log</code> Regression strict_cross_repo.sh yes no <code>bringup</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=1 RUN_MODEL_DIFF=1 RUN_CPP_GATES=1 CPP_MODE=phase-b RUN_CONSISTENCY_CHECKS=0 ALLOW_GLIBC_G1_BLOCKED=0 GLIBC_G1B_ALLOW_BLOCKED=0 bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-17-r1-pin-phase2","title":"Lane <code>pin</code> (<code>2026-02-17-r1-pin-phase2</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 10:47:22Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>28633bc1a719ef4fa27c63f827b07cf7d1f6f7c6</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>37a93dd5c49b5fda807fd204edf2547c3493319c</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>10f457bf75996c96901b91b2bd05e39fee20ab1c</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>d390d4890d5863697935275a3aa2598759b7cc00</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>a079402e5d09e5a86bc703eb203d735ed057708f</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>f9e7978f67374572cc1b0f032fd1ed85470e1f11</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>feee44880b063477a4908c496ffb8139096a574e</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>d8bfcfcb7909a261a689f19d469cb77f59ba940a</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u274c fail (<code>all_suites_fail_or_timeout</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u274c fail (<code>strict_system_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/kernel_smoke.log</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/lib_musl_both.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 RUN_GLIBC_G1=0 ALLOW_GLIBC_G1_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u274c fail (<code>strict_cross_repo_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-17-r1-pin-phase2b","title":"Lane <code>pin</code> (<code>2026-02-17-r1-pin-phase2b</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 10:59:27Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>28633bc1a719ef4fa27c63f827b07cf7d1f6f7c6</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>37a93dd5c49b5fda807fd204edf2547c3493319c</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>10f457bf75996c96901b91b2bd05e39fee20ab1c</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>d390d4890d5863697935275a3aa2598759b7cc00</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>a079402e5d09e5a86bc703eb203d735ed057708f</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>f9e7978f67374572cc1b0f032fd1ed85470e1f11</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>feee44880b063477a4908c496ffb8139096a574e</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>d8bfcfcb7909a261a689f19d469cb77f59ba940a</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u274c fail (<code>all_suites_fail_or_timeout</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u274c fail (<code>strict_system_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/kernel_smoke.log</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2b/pin/lib_musl_both.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-17-r1-pin-phase2c","title":"Lane <code>pin</code> (<code>2026-02-17-r1-pin-phase2c</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 11:07:09Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>28633bc1a719ef4fa27c63f827b07cf7d1f6f7c6</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>37a93dd5c49b5fda807fd204edf2547c3493319c</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>10f457bf75996c96901b91b2bd05e39fee20ab1c</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>d390d4890d5863697935275a3aa2598759b7cc00</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>a079402e5d09e5a86bc703eb203d735ed057708f</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>f9e7978f67374572cc1b0f032fd1ed85470e1f11</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>feee44880b063477a4908c496ffb8139096a574e</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>d8bfcfcb7909a261a689f19d469cb77f59ba940a</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/kernel_smoke.log</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/lib_musl_both.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 ALLOW_GLIBC_G1_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase2c/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-17-r1-pin-phase3","title":"Lane <code>pin</code> (<code>2026-02-17-r1-pin-phase3</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 11:31:36Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>28633bc1a719ef4fa27c63f827b07cf7d1f6f7c6</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>37a93dd5c49b5fda807fd204edf2547c3493319c</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>10f457bf75996c96901b91b2bd05e39fee20ab1c</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>d390d4890d5863697935275a3aa2598759b7cc00</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>a079402e5d09e5a86bc703eb203d735ed057708f</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>f9e7978f67374572cc1b0f032fd1ed85470e1f11</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>feee44880b063477a4908c496ffb8139096a574e</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>d8bfcfcb7909a261a689f19d469cb77f59ba940a</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=1 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u2705 pass (<code>glibc_g1b_pass_or_allowed_blocked</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/lib_glibc_g1b.log</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/lib_musl_both.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=0 ALLOW_GLIBC_G1_BLOCKED=1 GLIBC_G1B_ALLOW_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase3/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-17-r1-pin-phase4","title":"Lane <code>pin</code> (<code>2026-02-17-r1-pin-phase4</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 11:45:52Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>28633bc1a719ef4fa27c63f827b07cf7d1f6f7c6</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>37a93dd5c49b5fda807fd204edf2547c3493319c</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>10f457bf75996c96901b91b2bd05e39fee20ab1c</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>d390d4890d5863697935275a3aa2598759b7cc00</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>a079402e5d09e5a86bc703eb203d735ed057708f</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>f9e7978f67374572cc1b0f032fd1ed85470e1f11</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>feee44880b063477a4908c496ffb8139096a574e</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>d8bfcfcb7909a261a689f19d469cb77f59ba940a</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=1 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u2705 pass (<code>glibc_g1b_pass_or_allowed_blocked</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/lib_glibc_g1b.log</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/lib_musl_both.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=0 ALLOW_GLIBC_G1_BLOCKED=1 GLIBC_G1B_ALLOW_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-17-r1-pin-phase4b","title":"Lane <code>pin</code> (<code>2026-02-17-r1-pin-phase4b</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 11:57:59Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>28633bc1a719ef4fa27c63f827b07cf7d1f6f7c6</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>37a93dd5c49b5fda807fd204edf2547c3493319c</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>10f457bf75996c96901b91b2bd05e39fee20ab1c</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>d390d4890d5863697935275a3aa2598759b7cc00</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>a079402e5d09e5a86bc703eb203d735ed057708f</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>f9e7978f67374572cc1b0f032fd1ed85470e1f11</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>feee44880b063477a4908c496ffb8139096a574e</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>d8bfcfcb7909a261a689f19d469cb77f59ba940a</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=1 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u2705 pass (<code>glibc_g1b_pass_shared_libc_so_built</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/lib_glibc_g1b.log</code>; <code>summary:${LINXISA_ROOT}/out/libc/glibc/logs/g1b-summary.txt</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/lib_musl_both.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=0 ALLOW_GLIBC_G1_BLOCKED=1 GLIBC_G1B_ALLOW_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-phase4b/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-17-r1-pin-stable","title":"Lane <code>pin</code> (<code>2026-02-17-r1-pin-stable</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-17 10:38:57Z</code></li> <li>Profile: <code>dev</code></li> <li>Lane policy: <code>legacy</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>28633bc1a719ef4fa27c63f827b07cf7d1f6f7c6</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>37a93dd5c49b5fda807fd204edf2547c3493319c</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>10f457bf75996c96901b91b2bd05e39fee20ab1c</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>d390d4890d5863697935275a3aa2598759b7cc00</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>a079402e5d09e5a86bc703eb203d735ed057708f</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>f9e7978f67374572cc1b0f032fd1ed85470e1f11</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>feee44880b063477a4908c496ffb8139096a574e</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>d8bfcfcb7909a261a689f19d469cb77f59ba940a</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>unowned</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>unowned</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/isa_check26.log</code> Kernel Linux initramfs full boot yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/kernel_smoke.log</code> Library musl runtime static+shared yes no <code>unowned</code> <code>LINX_DISABLE_TIMER_IRQ=1 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/lib_musl_both.log</code> Regression strict_cross_repo.sh yes no <code>unowned</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=1 RUN_GLIBC_G1=0 ALLOW_GLIBC_G1_BLOCKED=1 bash tools/regression/strict_cross_repo.sh</code> \u274c fail (<code>strict_cross_repo_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-17-r1-pin-stable/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-23-r2-pin-reassess","title":"Lane <code>pin</code> (<code>2026-02-23-r2-pin-reassess</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-23 04:52:01Z</code></li> <li>Profile: <code>release-strict</code></li> <li>Lane policy: <code>external+pin-required</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>f26077d084862e4edbc2d5729fd2c3732ba29026</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>284e7fc25b42de2bed13f6afbf25e1f6f135b218</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>566a829372d54f455fe85f1110d5ee2e0185dd17</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>9be2cd701fa568d4257eca2b3f2f86423480c054</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>c2f015644441d45dddc5fd706c6b1a188967a2ea</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>c474cbf83190772306b3e01b2ad1e52259f0e1d3</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>603e6ca3a4940d052720f68ae60b86c2e484e774</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>a8958dd84ce2df4165e9f9d7bf4f27f40e49b0da</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u274c fail (<code>all_suites_fail_or_timeout</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u274c fail (<code>strict_system_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/isa_check26.log</code> Kernel Linux busybox rootfs boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINXISA_ROOT}/kernel/linux/tools/linxisa/busybox_rootfs/boot.py</code> \u274c fail (<code>linux_busybox_rootfs_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/kernel_busybox_rootfs.log</code> Kernel Linux initramfs full boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINXISA_ROOT}/kernel/linux/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINXISA_ROOT}/kernel/linux/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>glibc</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=0 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u274c fail (<code>glibc_g1b_wrapper_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/lib_glibc_g1b.log</code>; <code>summary:${LINXISA_ROOT}/out/libc/glibc/logs/g1b-summary.txt</code> Library musl runtime static+shared yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u274c fail (<code>runtime_mode_failure</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/lib_musl_both.log</code> Model QEMU vs model differential suite yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/run_model_diff_suite.py --root ${LINXISA_ROOT} --suite ${LINXISA_ROOT}/avs/model/linx_model_diff_suite.yaml --profile release-strict --trace-schema-version 1.0 --report-out ${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/model_diff_summary.json</code> \u274c fail (<code>model_diff_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/model_diff_suite.log</code> Regression strict_cross_repo.sh yes no <code>bringup</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=external QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=0 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=1 RUN_MODEL_DIFF=1 RUN_CPP_GATES=0 CPP_MODE=phase-b RUN_CONSISTENCY_CHECKS=0 ALLOW_GLIBC_G1_BLOCKED=0 GLIBC_G1B_ALLOW_BLOCKED=0 MULTI_AGENT_MANIFEST=${LINXISA_ROOT}/docs/bringup/agent_runs/manifest.yaml MULTI_AGENT_WAIVERS=${LINXISA_ROOT}/docs/bringup/agent_runs/waivers.yaml MULTI_AGENT_CHECKLISTS_ROOT=${LINXISA_ROOT}/docs/bringup/agent_runs/checklists MULTI_AGENT_REPORT=${LINXISA_ROOT}/docs/bringup/gates/latest.json MULTI_AGENT_LANE=pin MULTI_AGENT_RUN_ID=2026-02-23-r2-pin-reassess MULTI_AGENT_OUT=${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/multi_agent_summary.strict_cross.json bash tools/regression/strict_cross_repo.sh</code> \u274c fail (<code>strict_cross_repo_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-23-r4-pin-qemu-linux-ctxfix","title":"Lane <code>pin</code> (<code>2026-02-23-r4-pin-qemu-linux-ctxfix</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-23 08:14:19Z</code></li> <li>Profile: <code>release-strict</code></li> <li>Lane policy: <code>external+pin-required</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>f26077d084862e4edbc2d5729fd2c3732ba29026</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>c7fe5b9db245195f534052a9ba67764bf10857fc</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>d33e82d4cdf4839c5c143c2fd8abcb228ae49287</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>9be2cd701fa568d4257eca2b3f2f86423480c054</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>c2f015644441d45dddc5fd706c6b1a188967a2ea</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>c474cbf83190772306b3e01b2ad1e52259f0e1d3</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>603e6ca3a4940d052720f68ae60b86c2e484e774</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>2dd7ea383e6bae5af17bfcdec3cf42d9fa9509e7</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/clang LLD=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/clang LLD=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/isa_check26.log</code> Kernel Linux busybox rootfs boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINXISA_ROOT}/kernel/linux/tools/linxisa/busybox_rootfs/boot.py</code> \u274c fail (<code>linux_busybox_rootfs_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/kernel_busybox_rootfs.log</code> Kernel Linux initramfs full boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINXISA_ROOT}/kernel/linux/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINXISA_ROOT}/kernel/linux/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>glibc</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=0 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u274c fail (<code>glibc_g1b_wrapper_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/lib_glibc_g1b.log</code>; <code>summary:${LINXISA_ROOT}/out/libc/glibc/logs/g1b-summary.txt</code> Library musl runtime static+shared yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u274c fail (<code>runtime_mode_failure</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/lib_musl_both.log</code> Model QEMU vs model differential suite yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/run_model_diff_suite.py --root ${LINXISA_ROOT} --suite ${LINXISA_ROOT}/avs/model/linx_model_diff_suite.yaml --profile release-strict --trace-schema-version 1.0 --report-out ${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/model_diff_summary.json</code> \u274c fail (<code>model_diff_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/model_diff_suite.log</code> Regression strict_cross_repo.sh yes no <code>bringup</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=pin QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=0 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=1 RUN_MODEL_DIFF=1 RUN_CPP_GATES=0 CPP_MODE=phase-b RUN_CONSISTENCY_CHECKS=0 ALLOW_GLIBC_G1_BLOCKED=0 GLIBC_G1B_ALLOW_BLOCKED=0 MULTI_AGENT_MANIFEST=${LINXISA_ROOT}/docs/bringup/agent_runs/manifest.yaml MULTI_AGENT_WAIVERS=${LINXISA_ROOT}/docs/bringup/agent_runs/waivers.yaml MULTI_AGENT_CHECKLISTS_ROOT=${LINXISA_ROOT}/docs/bringup/agent_runs/checklists MULTI_AGENT_REPORT=${LINXISA_ROOT}/docs/bringup/gates/latest.json MULTI_AGENT_LANE=pin MULTI_AGENT_RUN_ID=2026-02-23-r4-pin-qemu-linux-ctxfix MULTI_AGENT_OUT=${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/multi_agent_summary.strict_cross.json bash tools/regression/strict_cross_repo.sh</code> \u274c fail (<code>strict_cross_repo_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-23-r5-pin-ctx-rootfs","title":"Lane <code>pin</code> (<code>2026-02-23-r5-pin-ctx-rootfs</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-23 08:30:41Z</code></li> <li>Profile: <code>release-strict</code></li> <li>Lane policy: <code>external+pin-required</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>f26077d084862e4edbc2d5729fd2c3732ba29026</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>c7fe5b9db245195f534052a9ba67764bf10857fc</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>d33e82d4cdf4839c5c143c2fd8abcb228ae49287</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>9be2cd701fa568d4257eca2b3f2f86423480c054</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>c2f015644441d45dddc5fd706c6b1a188967a2ea</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>c474cbf83190772306b3e01b2ad1e52259f0e1d3</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>603e6ca3a4940d052720f68ae60b86c2e484e774</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>2dd7ea383e6bae5af17bfcdec3cf42d9fa9509e7</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ${LINXISA_ROOT}/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/clang LLD=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>bringup</code> <code>cd ${LINXISA_ROOT}/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/clang LLD=${LINXISA_ROOT}/compiler/llvm/build-linxisa-clang/bin/ld.lld QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/check26_contract.py --root ${LINXISA_ROOT}</code> \u2705 pass (<code>contract_ok</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/isa_check26.log</code> Kernel Linux busybox rootfs boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINXISA_ROOT}/kernel/linux/tools/linxisa/busybox_rootfs/boot.py</code> \u274c fail (<code>linux_busybox_rootfs_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/kernel_busybox_rootfs.log</code> Kernel Linux initramfs full boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINXISA_ROOT}/kernel/linux/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 python3 ${LINXISA_ROOT}/kernel/linux/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>glibc</code> <code>cd ${LINXISA_ROOT} &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=0 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u274c fail (<code>glibc_g1b_wrapper_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/lib_glibc_g1b.log</code>; <code>summary:${LINXISA_ROOT}/out/libc/glibc/logs/g1b-summary.txt</code> Library musl runtime static+shared yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 python3 ${LINXISA_ROOT}/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu ${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u274c fail (<code>runtime_mode_failure</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/lib_musl_both.log</code> Model QEMU vs model differential suite yes no <code>bringup</code> <code>python3 ${LINXISA_ROOT}/tools/bringup/run_model_diff_suite.py --root ${LINXISA_ROOT} --suite ${LINXISA_ROOT}/avs/model/linx_model_diff_suite.yaml --profile release-strict --trace-schema-version 1.0 --report-out ${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/model_diff_summary.json</code> \u274c fail (<code>model_diff_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/model_diff_suite.log</code> Regression strict_cross_repo.sh yes no <code>bringup</code> <code>cd ${LINXISA_ROOT} &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=pin QEMU_LANE=pin QEMU=${LINXISA_ROOT}/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=0 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=1 RUN_MODEL_DIFF=1 RUN_CPP_GATES=0 CPP_MODE=phase-b RUN_CONSISTENCY_CHECKS=0 ALLOW_GLIBC_G1_BLOCKED=0 GLIBC_G1B_ALLOW_BLOCKED=0 MULTI_AGENT_MANIFEST=${LINXISA_ROOT}/docs/bringup/agent_runs/manifest.yaml MULTI_AGENT_WAIVERS=${LINXISA_ROOT}/docs/bringup/agent_runs/waivers.yaml MULTI_AGENT_CHECKLISTS_ROOT=${LINXISA_ROOT}/docs/bringup/agent_runs/checklists MULTI_AGENT_REPORT=${LINXISA_ROOT}/docs/bringup/gates/latest.json MULTI_AGENT_LANE=pin MULTI_AGENT_RUN_ID=2026-02-23-r5-pin-ctx-rootfs MULTI_AGENT_OUT=${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/multi_agent_summary.strict_cross.json bash tools/regression/strict_cross_repo.sh</code> \u274c fail (<code>strict_cross_repo_fail</code>) <code>log:${LINXISA_ROOT}/docs/bringup/gates/logs/2026-02-23-r5-pin-ctx-rootfs/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-24-r1-pin-timeron","title":"Lane <code>pin</code> (<code>2026-02-24-r1-pin-timeron</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-24 22:05:58Z</code></li> <li>Profile: <code>release-strict</code></li> <li>Lane policy: <code>external+pin-required</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>69493c1b395a23546cab196947d6424003a9f5ed</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>7326fc7cc9338ffde3e84daa82269b68b691765f</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>16eca62df97c79088861f8979c6b1ceeeb281b73</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>70de88fbedd6dd1c53b6c0d06df84dd84ed782e9</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>4e3d23f6ee81b399bdd6125eb30922dc6ddcff85</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>eedfeaa4df3d07fc7f3cefb13641bf6eb000217a</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>5fe5e8304a993b6abf341a4a1138bb48c167c135</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>56b77eae03de6c89ba309b35ce1256046b8e13e0</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=/Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=/Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>bringup</code> <code>python3 /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>bringup</code> <code>python3 /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/clang LLD=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/ld.lld QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/clang LLD=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/ld.lld QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>bringup</code> <code>python3 /Users/zhoubot/linx-isa/tools/bringup/check26_contract.py --root /Users/zhoubot/linx-isa</code> \u2705 pass (<code>contract_ok</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/isa_check26.log</code> Kernel Linux busybox rootfs boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 python3 /Users/zhoubot/linx-isa/kernel/linux/tools/linxisa/busybox_rootfs/boot.py</code> \u274c fail (<code>linux_busybox_rootfs_fail</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/kernel_busybox_rootfs.log</code> Kernel Linux initramfs full boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 python3 /Users/zhoubot/linx-isa/kernel/linux/tools/linxisa/initramfs/full_boot.py</code> \u274c fail (<code>linux_full_boot_fail</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 python3 /Users/zhoubot/linx-isa/kernel/linux/tools/linxisa/initramfs/smoke.py</code> \u274c fail (<code>linux_smoke_fail</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/kernel_smoke.log</code> Library glibc G1b shared libc.so yes no <code>glibc</code> <code>cd /Users/zhoubot/linx-isa &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=0 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u274c fail (<code>glibc_g1b_wrapper_fail</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/lib_glibc_g1b.log</code>; <code>summary:/Users/zhoubot/linx-isa/out/libc/glibc/logs/g1b-summary.txt</code> Library musl runtime static+shared yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 python3 /Users/zhoubot/linx-isa/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu /Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/lib_musl_both.log</code> Model QEMU vs model differential suite yes no <code>bringup</code> <code>python3 /Users/zhoubot/linx-isa/tools/bringup/run_model_diff_suite.py --root /Users/zhoubot/linx-isa --suite /Users/zhoubot/linx-isa/avs/model/linx_model_diff_suite.yaml --profile release-strict --trace-schema-version 1.0 --report-out /Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/model_diff_summary.json</code> \u274c fail (<code>model_diff_fail</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/model_diff_suite.log</code> Regression strict_cross_repo.sh yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa &amp;&amp; SKIP_BUILD=1 TOOLCHAIN_LANE=pin QEMU_LANE=pin QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 LINX_DISABLE_TIMER_IRQ=0 LINX_EMU_DISABLE_TIMER_IRQ=0 RUN_GLIBC_G1=0 RUN_GLIBC_G1B=1 RUN_MODEL_DIFF=1 RUN_CPP_GATES=0 CPP_MODE=phase-b RUN_CONSISTENCY_CHECKS=0 ALLOW_GLIBC_G1_BLOCKED=0 GLIBC_G1B_ALLOW_BLOCKED=0 MULTI_AGENT_MANIFEST=/Users/zhoubot/linx-isa/docs/bringup/agent_runs/manifest.yaml MULTI_AGENT_WAIVERS=/Users/zhoubot/linx-isa/docs/bringup/agent_runs/waivers.yaml MULTI_AGENT_CHECKLISTS_ROOT=/Users/zhoubot/linx-isa/docs/bringup/agent_runs/checklists MULTI_AGENT_REPORT=/Users/zhoubot/linx-isa/docs/bringup/gates/latest.json MULTI_AGENT_LANE=pin MULTI_AGENT_RUN_ID=2026-02-24-r1-pin-timeron MULTI_AGENT_OUT=/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/multi_agent_summary.strict_cross.json bash tools/regression/strict_cross_repo.sh</code> \u274c fail (<code>strict_cross_repo_fail</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-24-r1-pin-timeron/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GATE_STATUS/#lane-pin-2026-02-25-r2-pin-lanefix","title":"Lane <code>pin</code> (<code>2026-02-25-r2-pin-lanefix</code>)","text":"<ul> <li>Timestamp (UTC): <code>2026-02-25 12:41:30Z</code></li> <li>Profile: <code>release-strict</code></li> <li>Lane policy: <code>external+pin-required</code></li> <li>Trace schema version: <code>1.0</code></li> <li>SHA manifest:</li> <li><code>glibc</code>: <code>69493c1b395a23546cab196947d6424003a9f5ed</code> (<code>${LINXISA_ROOT}/lib/glibc</code>)</li> <li><code>linux</code>: <code>7326fc7cc9338ffde3e84daa82269b68b691765f</code> (<code>${LINXISA_ROOT}/kernel/linux</code>)</li> <li><code>linx-isa</code>: <code>16eca62df97c79088861f8979c6b1ceeeb281b73</code> (<code>${LINXISA_ROOT}</code>)</li> <li><code>linxcore</code>: <code>70de88fbedd6dd1c53b6c0d06df84dd84ed782e9</code> (<code>${LINXISA_ROOT}/rtl/LinxCore</code>)</li> <li><code>llvm</code>: <code>4e3d23f6ee81b399bdd6125eb30922dc6ddcff85</code> (<code>${LINXISA_ROOT}/compiler/llvm</code>)</li> <li><code>musl</code>: <code>eedfeaa4df3d07fc7f3cefb13641bf6eb000217a</code> (<code>${LINXISA_ROOT}/lib/musl</code>)</li> <li><code>pycircuit</code>: <code>5fe5e8304a993b6abf341a4a1138bb48c167c135</code> (<code>${LINXISA_ROOT}/tools/pyCircuit</code>)</li> <li><code>qemu</code>: <code>56b77eae03de6c89ba309b35ce1256046b8e13e0</code> (<code>${LINXISA_ROOT}/emulator/qemu</code>)</li> </ul> Domain Gate Required Waived Owner Command Result Evidence Compiler AVS compile suites (linx32) yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=/Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/out-linx32 ./run.sh</code> \u2705 pass (<code>compile_pass_linx32</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/compiler_linx32.log</code> Compiler AVS compile suites (linx64) yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests &amp;&amp; CLANG=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/clang TARGET=linx64-linx-none-elf OUT_DIR=/Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/out-linx64 ./run.sh</code> \u2705 pass (<code>compile_pass_linx64</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/compiler_linx64.log</code> Compiler Coverage 100% (linx32) yes no <code>bringup</code> <code>python3 /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/out-linx32 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx32</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/compiler_cov_linx32.log</code> Compiler Coverage 100% (linx64) yes no <code>bringup</code> <code>python3 /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir /Users/zhoubot/linx-isa/avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code> \u2705 pass (<code>mnemonic_coverage_100_linx64</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/compiler_cov_linx64.log</code> Emulator QEMU all suites yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/clang LLD=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/ld.lld QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 ./run_tests.sh --all --timeout 10</code> \u2705 pass (<code>all_suites_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/emu_all_suites.log</code> Emulator QEMU strict system yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa/avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 CLANG=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/clang LLD=/Users/zhoubot/linx-isa/compiler/llvm/build-linxisa-clang/bin/ld.lld QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 ./check_system_strict.sh</code> \u2705 pass (<code>strict_system_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/emu_strict_system.log</code> ISA check26 contract yes no <code>bringup</code> <code>python3 /Users/zhoubot/linx-isa/tools/bringup/check26_contract.py --root /Users/zhoubot/linx-isa</code> \u2705 pass (<code>contract_ok</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/isa_check26.log</code> Kernel Linux busybox rootfs boot no no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 python3 /Users/zhoubot/linx-isa/kernel/linux/tools/linxisa/busybox_rootfs/boot.py</code> \u2705 pass (<code>linux_busybox_rootfs_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/kernel_busybox_rootfs.log</code> Kernel Linux initramfs full boot yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 python3 /Users/zhoubot/linx-isa/kernel/linux/tools/linxisa/initramfs/full_boot.py</code> \u2705 pass (<code>linux_full_boot_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/kernel_full_boot.log</code> Kernel Linux initramfs smoke yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 python3 /Users/zhoubot/linx-isa/kernel/linux/tools/linxisa/initramfs/smoke.py</code> \u2705 pass (<code>linux_smoke_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/kernel_smoke.log</code> Kernel Linux initramfs virtio disk smoke no no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 QEMU=/Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 python3 /Users/zhoubot/linx-isa/kernel/linux/tools/linxisa/initramfs/virtio_disk_smoke.py</code> \u2705 pass (<code>linux_virtio_disk_smoke_pass_cmdline_fallback</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/kernel_virtio_disk_smoke.log</code> Library glibc G1b shared libc.so yes no <code>glibc</code> <code>cd /Users/zhoubot/linx-isa &amp;&amp; GLIBC_G1B_ALLOW_BLOCKED=0 bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code> \u2705 pass (<code>glibc_g1b_pass_shared_libc_so_built</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/lib_glibc_g1b.log</code>; <code>summary:/Users/zhoubot/linx-isa/out/libc/glibc/logs/g1b-summary.txt</code> Library musl runtime static+shared yes no <code>bringup</code> <code>LINX_DISABLE_TIMER_IRQ=0 python3 /Users/zhoubot/linx-isa/avs/qemu/run_musl_smoke.py --mode phase-b --link both --qemu /Users/zhoubot/linx-isa/emulator/qemu/build/qemu-system-linx64 --timeout 90</code> \u2705 pass (<code>runtime_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/lib_musl_both.log</code> Model QEMU vs model differential suite yes no <code>bringup</code> <code>python3 /Users/zhoubot/linx-isa/tools/bringup/run_model_diff_suite.py --root /Users/zhoubot/linx-isa --suite /Users/zhoubot/linx-isa/avs/model/linx_model_diff_suite.yaml --profile release-strict --trace-schema-version 1.0 --report-out /Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/model_diff_summary.json</code> \u2705 pass (<code>model_diff_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/model_diff_suite.log</code> Regression strict_cross_repo.sh yes no <code>bringup</code> <code>cd /Users/zhoubot/linx-isa &amp;&amp; LINX_BRINGUP_PROFILE=release-strict bash tools/regression/strict_cross_repo.sh</code> \u2705 pass (<code>strict_cross_repo_pass</code>) <code>log:/Users/zhoubot/linx-isa/docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/reg_strict_cross_repo.log</code>"},{"location":"bringup/GETTING_STARTED/","title":"LinxISA Bring-up Getting Started","text":"<p>This guide is the entry point for contributors joining the LinxISA bring-up workspace.</p>"},{"location":"bringup/GETTING_STARTED/#1-prerequisites","title":"1. Prerequisites","text":""},{"location":"bringup/GETTING_STARTED/#platform-notes","title":"Platform notes","text":"<ul> <li>Linux: supported (recommended).</li> <li>macOS: supported for most compiler/emulator/tooling work.</li> <li>Windows:</li> <li>supported via WSL2 (recommended),</li> <li>native Windows can be used for editing + some tooling, but most gates expect a POSIX shell.</li> </ul>"},{"location":"bringup/GETTING_STARTED/#required","title":"Required","text":"<ul> <li><code>git</code></li> <li><code>python3</code></li> <li>A POSIX shell to run <code>*.sh</code> gates (Linux/macOS, or Windows+WSL2)</li> <li><code>clang</code> + <code>ld.lld</code> for Linx cross builds (either from the pinned LLVM submodule build, or an external toolchain)</li> </ul>"},{"location":"bringup/GETTING_STARTED/#recommended","title":"Recommended","text":"<ul> <li><code>gh</code> (GitHub CLI)</li> </ul>"},{"location":"bringup/GETTING_STARTED/#2-clone-with-submodules","title":"2. Clone with Submodules","text":"<pre><code>git clone --recurse-submodules git@github.com:LinxISA/linx-isa.git\ncd linx-isa\ngit submodule sync --recursive\ngit submodule update --init --recursive\n</code></pre> <p>Submodule map:</p> <ul> <li><code>compiler/llvm</code> -&gt; <code>LinxISA/llvm-project</code></li> <li><code>emulator/qemu</code> -&gt; <code>LinxISA/qemu</code></li> <li><code>kernel/linux</code> -&gt; <code>LinxISA/linux</code></li> <li><code>rtl/LinxCore</code> -&gt; <code>LinxISA/LinxCore</code></li> <li><code>tools/pyCircuit</code> -&gt; <code>LinxISA/pyCircuit</code></li> <li><code>lib/glibc</code> -&gt; <code>LinxISA/glibc</code></li> <li><code>lib/musl</code> -&gt; <code>LinxISA/musl</code></li> <li><code>workloads/pto_kernels</code> -&gt; <code>LinxISA/PTO-Kernel</code></li> </ul>"},{"location":"bringup/GETTING_STARTED/#3-validate-baseline","title":"3. Validate Baseline","text":"<p>From repo root:</p> <pre><code>bash tools/regression/run.sh\n</code></pre> <p>Optional overrides:</p> <pre><code># Tool paths can come from:\n# - pinned submodules (recommended for reproducibility)\n# - external installs (recommended for day-to-day dev if you already have them)\n#\n# If you built the pinned submodules:\nexport CLANG=$PWD/compiler/llvm/build-linxisa-clang/bin/clang\nexport LLD=$PWD/compiler/llvm/build-linxisa-clang/bin/ld.lld\nexport QEMU=$PWD/emulator/qemu/build/qemu-system-linx64\n\n# Or point to external toolchains:\n# export CLANG=/path/to/clang\n# export LLD=/path/to/ld.lld\n# export QEMU=/path/to/qemu-system-linx64\n\nbash tools/regression/run.sh\n</code></pre> <p>Run contract gate:</p> <pre><code>python3 tools/bringup/check26_contract.py --root .\n</code></pre>"},{"location":"bringup/GETTING_STARTED/#4-daily-workflow","title":"4. Daily Workflow","text":"<ol> <li>Pick a scope under <code>docs/bringup/phases/</code>.</li> <li>Implement in the relevant submodule/repo first.</li> <li>Run AVS + regression gates locally.</li> <li>Merge upstream in ecosystem repos.</li> <li>Bump submodule SHAs in <code>linx-isa</code>.</li> </ol> <p>Submodule bump command:</p> <pre><code>git submodule update --remote compiler/llvm emulator/qemu kernel/linux rtl/LinxCore tools/pyCircuit lib/glibc lib/musl workloads/pto_kernels\ngit add .gitmodules compiler/llvm emulator/qemu kernel/linux rtl/LinxCore tools/pyCircuit lib/glibc lib/musl workloads/pto_kernels\ngit commit -m \"chore(submodules): bump ecosystem revisions\"\n</code></pre>"},{"location":"bringup/GETTING_STARTED/#5-canonical-paths","title":"5. Canonical Paths","text":"<ul> <li>AVS runtime tests: <code>avs/qemu/</code></li> <li>AVS compile tests: <code>avs/compiler/linx-llvm/tests/</code></li> <li>Freestanding libc support used by AVS: <code>avs/runtime/freestanding/</code></li> <li>Linux libc source forks: <code>lib/glibc/</code>, <code>lib/musl/</code></li> <li>PTO kernel headers: <code>workloads/pto_kernels/include/</code></li> <li>Assembly sample pack: <code>docs/reference/examples/v0.3/</code></li> </ul>"},{"location":"bringup/GETTING_STARTED/#6-coordination-references","title":"6. Coordination References","text":"<ul> <li>Bring-up progress: <code>docs/bringup/PROGRESS.md</code></li> <li>Contract checkpoint: <code>docs/bringup/CHECK26_CONTRACT.md</code></li> <li>Migration map: <code>docs/migration/path-map-v0.4.0.md</code></li> <li>Navigation guide: <code>docs/project/navigation.md</code></li> </ul>"},{"location":"bringup/ISA_GAP_ANALYSIS/","title":"LinxISA Gap Analysis (v0.2 -&gt; Tier-1)","text":"<p>Last updated: 2026-02-07</p> <p>This document summarizes what is currently missing or immature in LinxISA (spec, toolchain, emulator, validation), flags known inconsistencies, and maps each gap to concrete artifacts and bring-up gates in this repo.</p> <p>Primary roadmap: <code>docs/bringup/MATURITY_PLAN.md</code>.</p>"},{"location":"bringup/ISA_GAP_ANALYSIS/#what-tier-1-means-here","title":"What \"Tier-1\" Means Here","text":"<p>Comparable to Arm/x86/RISC-V maturity means:</p> <ul> <li>A spec that is unambiguous and machine-checkable (encoding + semantics + traps).</li> <li>A compiler/toolchain that is correct, well-tested, and debuggable.</li> <li>An emulator that is correct, deterministic, observable, and useful as a reference model.</li> <li>A validation suite (AVS) with clear pass/fail criteria and coverage gates.</li> </ul>"},{"location":"bringup/ISA_GAP_ANALYSIS/#current-strengths-evidence-in-repo","title":"Current Strengths (Evidence in Repo)","text":"<ul> <li>Golden opcode database and generated JSON catalog:</li> <li><code>isa/v0.3/</code> -&gt; <code>isa/v0.3/linxisa-v0.3.json</code></li> <li>Encoding conflict checks and hole reporting:</li> <li><code>python3 tools/isa/report_encoding_space.py --check</code></li> <li>Report: <code>docs/reference/encoding_space_report.md</code></li> <li>LLVM backend has full mnemonic disassembly coverage when using the per-target outputs:</li> <li><code>python3 avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir avs/compiler/linx-llvm/tests/out-linx64 --fail-under 100</code></li> <li>Benchmark harness exists with static and dynamic instruction statistics:</li> <li><code>python3 workloads/run_benchmarks.py --dynamic-hist</code></li> </ul>"},{"location":"bringup/ISA_GAP_ANALYSIS/#gaps-isa-specification","title":"Gaps: ISA Specification","text":"<ul> <li>Privileged architecture completeness:</li> <li>Missing or under-specified: trap causes, trap priority, precise state capture,     CSR reset values, and which fields are WARL vs fixed.</li> <li> <p>Required artifacts:</p> <ul> <li>Expand manual: <code>docs/architecture/isa-manual/src/chapters/09_system_and_privilege.adoc</code></li> <li>AVS coverage: <code>avs/matrix_v1.md</code> (SYS area)</li> </ul> </li> <li> <p>MMU and memory attributes:</p> </li> <li>No complete, testable definition of translation, page tables, TLB invalidation,     access faults, and cacheability attributes.</li> <li> <p>Bring-up strategy:</p> <ul> <li>Define a \"no-MMU\" profile gate first (current), then a minimal MMU profile.</li> </ul> </li> <li> <p>Debug architecture:</p> </li> <li>No spec for single-step, breakpoints/watchpoints, debug register access rules,     and privilege interactions.</li> <li> <p>Bring-up strategy:</p> <ul> <li>Start with GDB remote support in QEMU + a minimal debug CSR contract.</li> </ul> </li> <li> <p>Vector/tile semantic envelope:</p> </li> <li>Block legality rules need to be explicit and tested (what is legal in VPAR vs VSEQ,     and what traps on misuse).</li> <li>AVS vector tests: <code>AVS-VEC-*</code> in <code>avs/matrix_v1.md</code> and <code>avs/linx_avs_v1_test_matrix.yaml</code>.</li> </ul>"},{"location":"bringup/ISA_GAP_ANALYSIS/#gaps-memory-model-and-fences","title":"Gaps: Memory Model and Fences","text":"<ul> <li>The repo now documents a weak model, but many \"sharp edges\" still need closure:</li> <li>Device vs Normal ordering, cumulative fence intent, and exact <code>.aq/.rl</code> scope.</li> <li>Reference chapter: <code>docs/architecture/isa-manual/src/chapters/08_memory_operations.adoc</code></li> <li>Required validation:<ul> <li>Litmus tests for message passing and fence ordering (AVS-ATOM-010/011).</li> </ul> </li> </ul>"},{"location":"bringup/ISA_GAP_ANALYSIS/#gaps-toolchain-llvmasmobj","title":"Gaps: Toolchain (LLVM/Asm/Obj)","text":"<ul> <li>ABI contract stability:</li> <li>Register roles, stack alignment, varargs, TLS, and unwind/debug info must be     formally documented and tested.</li> <li> <p>Required artifacts:</p> <ul> <li>ABI doc under <code>docs/architecture/</code> (future)</li> <li>AVS ABI tests (AVS-ABI-001/002)</li> </ul> </li> <li> <p>Object/relocation model:</p> </li> <li>ET_DYN/dynamic linking is not yet a bring-up gate; relocation coverage must be     expanded before hosted workloads (LLVM test-suite) can run.</li> <li> <p>Evidence: <code>avs/compiler/linx-llvm/tests/run.sh</code> has PIC relocation checks, shared-lib gated.</p> </li> <li> <p>Disasm coverage gate ergonomics:</p> </li> <li>Stale <code>avs/compiler/linx-llvm/tests/out/</code> directories can cause false failures if used.</li> <li>Mitigation: <code>avs/compiler/linx-llvm/tests/analyze_coverage.py</code> auto-detects <code>out-linx*</code>.</li> </ul>"},{"location":"bringup/ISA_GAP_ANALYSIS/#gaps-emulator-qemu","title":"Gaps: Emulator (QEMU)","text":"<ul> <li>Execution completeness:</li> <li>Any spec-defined instruction not implemented in QEMU must trap deterministically     as illegal, not silently execute or decode as a different instruction.</li> <li> <p>AVS gate: AVS-DEC-001, AVS-EMU-001.</p> </li> <li> <p>Observability and difftest:</p> </li> <li>A stable commit-trace schema must be emitted by QEMU and consumed by RTL difftest.</li> <li>Contract: <code>docs/bringup/contracts/trace_schema.md</code></li> </ul>"},{"location":"bringup/ISA_GAP_ANALYSIS/#gaps-validation-linx-avs","title":"Gaps: Validation (Linx-AVS)","text":"<ul> <li>The matrix exists but many tests are not implemented yet:</li> <li>Matrix: <code>avs/matrix_v1.md</code></li> <li>Machine-readable: <code>avs/linx_avs_v1_test_matrix.yaml</code></li> <li>Required work:<ul> <li>Implement runtime tests under <code>avs/qemu/</code></li> <li>Implement compile-only / MC tests under <code>avs/compiler/linx-llvm/tests/</code></li> </ul> </li> </ul>"},{"location":"bringup/ISA_GAP_ANALYSIS/#gaps-benchmark-portfolio","title":"Gaps: Benchmark Portfolio","text":"<ul> <li>Third-party sources exist, but only a freestanding-friendly subset is expected   to run early:</li> <li>Fetch script: <code>workloads/fetch_third_party.sh</code></li> <li>Method: <code>workloads/BENCHMARKING_METHOD.md</code></li> <li>Reality:<ul> <li>Hosted workloads (full LLVM test-suite, Google Benchmark) require more libc   and OS services than the current minimal environment provides.</li> </ul> </li> </ul>"},{"location":"bringup/ISA_GAP_ANALYSIS/#concrete-fill-the-missing-parts-checklist","title":"Concrete \"Fill The Missing Parts\" Checklist","text":"<ul> <li>Spec:</li> <li>Close all normative TODOs for scalar core semantics and traps.</li> <li>Define privileged traps/CSR behavior with reset values and illegal/WARL rules.</li> <li> <p>Define memory model litmus expectations and fence semantics precisely.</p> </li> <li> <p>Toolchain:</p> </li> <li>Lock ABI and add ABI tests (calls, varargs, stack alignment).</li> <li>Expand relocation/object model and enable ET_DYN when ready.</li> <li> <p>Keep disasm/asm round-trip tests and coverage at 100%.</p> </li> <li> <p>Emulator:</p> </li> <li>Implement missing instructions or trap deterministically.</li> <li> <p>Emit commit-trace for difftest and keep histogram tooling stable.</p> </li> <li> <p>Validation:</p> </li> <li>Implement AVS tests and treat them as the primary bring-up gate.</li> </ul>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/","title":"Linx ASM ABI/Unwind/Context Checklist","text":"<p>Use this checklist when landing Linx64 asm changes in musl/glibc/runtime code.</p>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/#a-abi-register-contract","title":"A) ABI Register Contract","text":"<ul> <li>[ ] Uses linx64 ABI register map from <code>${LINUX_ROOT}/Documentation/linxisa/abi.md</code>.</li> <li>[ ] Preserves callee-saved set (<code>s0..s8</code>, <code>sp</code>) in callable functions.</li> <li>[ ] Preserves <code>ra</code> semantics across calls/returns.</li> <li>[ ] Keeps stack 16-byte aligned at call boundaries.</li> </ul>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/#b-block-isa-legality","title":"B) Block-ISA Legality","text":"<ul> <li>[ ] Control flow is expressed with valid block markers (<code>BSTART/C.BSTART</code> + <code>BSTOP/C.BSTOP</code>).</li> <li>[ ] Conditional branches consume <code>SETC</code> inside the same conditional block.</li> <li>[ ] Indirect transfers use <code>setc.tgt</code> in an <code>IND</code> block.</li> <li>[ ] <code>RET</code> blocks use explicit target setup (<code>BSTART.RET</code> + <code>setc.tgt ra</code>).</li> <li>[ ] No direct illegal branch into middle of a block body.</li> <li>[ ] Dynamic <code>RET/IND/ICALL</code> targets are legal block starts.</li> </ul>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/#c-call-header-fusionadjacency","title":"C) Call Header Fusion/Adjacency","text":"<ul> <li>[ ] Returning <code>CALL</code> headers use fused form: <code>BSTART.CALL</code> + immediate adjacent <code>SETRET/C.SETRET</code>.</li> <li>[ ] No instructions are emitted between call header and setret materialization.</li> <li>[ ] Non-returning <code>CALL</code> headers without <code>SETRET</code> are explicit/intentional and keep <code>ra</code> unchanged.</li> </ul>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/#d-syscall-path-correctness","title":"D) Syscall Path Correctness","text":"<ul> <li>[ ] Syscall number is in <code>a7</code>.</li> <li>[ ] Args are in <code>a0..a5</code>.</li> <li>[ ] Trap instruction is <code>acrc 1</code> (not legacy fallback traps).</li> <li>[ ] Return value path preserves negative errno convention in <code>a0</code>.</li> </ul>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/#e-setjmpsigsetjmplongjmp","title":"E) setjmp/sigsetjmp/longjmp","text":"<ul> <li>[ ] <code>__jmp_buf</code> matches Linx ABI save set size (11 words).</li> <li>[ ] <code>setjmp</code> saves only ABI-preserved state (<code>s0..s8</code>, <code>sp</code>, <code>ra</code>).</li> <li>[ ] <code>longjmp</code> restores the same state and enforces <code>val==0 -&gt; 1</code>.</li> <li>[ ] <code>sigsetjmp</code> routes through <code>__sigsetjmp_tail</code> for mask save/restore when <code>savemask!=0</code>.</li> </ul>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/#f-signalrestorer-abi","title":"F) Signal/Restorer ABI","text":"<ul> <li>[ ] Userspace <code>SA_RESTORER</code> is defined as <code>0x04000000</code>.</li> <li>[ ] <code>__restore_rt</code> issues <code>rt_sigreturn</code> (<code>a7=139</code>, <code>acrc 1</code>).</li> <li>[ ] No-op generic restorer fallback is not active for Linx.</li> <li>[ ] <code>mcontext/sigcontext/ucontext</code> layouts are Linux Linx UAPI-compatible.</li> </ul>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/#g-unwindcontext-switch-consistency","title":"G) Unwind/Context-Switch Consistency","text":"<ul> <li>[ ] Save/restore order is consistent with Linux Linx kernel patterns:</li> <li><code>${LINUX_ROOT}/arch/linx/kernel/switch_to.S</code></li> <li><code>${LINUX_ROOT}/arch/linx/kernel/entry.S</code></li> <li><code>${LINUX_ROOT}/arch/linx/kernel/signal.c</code></li> <li>[ ] Linux cross-stack check confirms call/ret target setup matches kernel patterns.</li> <li>[ ] Noreturn terminal stubs (<code>sigreturn</code>, <code>exit</code>, unmap-self path) do not expose fake unwind paths.</li> <li>[ ] Any context struct exported to userspace matches ptrace/signal expectations.</li> </ul>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/#h-relocationtls-contract","title":"H) Relocation/TLS Contract","text":"<ul> <li>[ ] Linx arch relocation headers use canonical <code>R_LINX_*</code> constants.</li> <li>[ ] <code>CRTJMP</code> is a real control transfer (not a no-op).</li> <li>[ ] <code>dlsym</code> passes caller return-address metadata to <code>__dlsym</code>.</li> <li>[ ] <code>tlsdesc</code> stubs are arch implementations (no zero-return fallback).</li> </ul>"},{"location":"bringup/LINX_ASM_ABI_UNWIND_CONTEXT_CHECKLIST/#i-runtime-gate-expectations","title":"I) Runtime Gate Expectations","text":"<ul> <li>[ ] Static and shared links both pass smoke gates.</li> <li>[ ] Shared runtime includes <code>/lib/libc.so</code> and <code>/lib/ld-musl-linx64.so.1</code>.</li> <li>[ ] QEMU tests cover:</li> <li>signal delivery/restorer</li> <li>setjmp/sigsetjmp/longjmp</li> <li>thread create/join + TLS</li> <li>dlopen/dlsym + TLS descriptor paths</li> </ul>"},{"location":"bringup/MATURITY_PLAN/","title":"LinxISA Maturity Plan (Tier-1 Track vs ARM/x86)","text":"<p>Last updated: 2026-02-25</p>"},{"location":"bringup/MATURITY_PLAN/#baseline","title":"Baseline","text":"<ul> <li>Strict baseline run: <code>2026-02-25-r2-pin-lanefix</code> (<code>2026-02-25 12:41:30Z</code>)</li> <li>Canonical report: <code>docs/bringup/gates/latest.json</code></li> <li>Current strict required gates are green across compiler, emulator, kernel, libc, model diff, and regression.</li> </ul>"},{"location":"bringup/MATURITY_PLAN/#gap-snapshot","title":"Gap Snapshot","text":"<ul> <li>Bring-up closure is complete for core strict gates.</li> <li>Remaining maturity gap is depth and breadth:</li> <li>AVS breadth (current status file: <code>13/39</code> implemented).</li> <li>ISA-vs-QEMU implementation breadth (<code>311/710</code> mapped mnemonics; tracked in machine report).</li> <li>SPEC hosted workload closure (<code>SPEC-*</code> checklist still open).</li> <li>ABI/unwind/TLS runtime hardening gates (checklist exists; executable gating expansion still pending).</li> <li>Privileged/MMU/debug completeness beyond current release-strict subset.</li> </ul>"},{"location":"bringup/MATURITY_PLAN/#milestones","title":"Milestones","text":""},{"location":"bringup/MATURITY_PLAN/#m1-1-2-weeks-gate-hygiene-and-open-non-spec-checklist-closure","title":"M1 (1-2 weeks): Gate hygiene and open non-SPEC checklist closure","text":"<p>Status: In progress (closure artifacts landed in this workspace update)</p> <ul> <li>Close open non-SPEC checklist IDs:</li> <li><code>LLVM-005</code></li> <li><code>QEMU-003</code></li> <li><code>QEMU-005</code></li> <li><code>LINUX-003</code></li> <li>Keep cross-doc truth aligned:</li> <li><code>docs/bringup/gates/latest.json</code></li> <li><code>docs/bringup/GATE_STATUS.md</code></li> <li><code>docs/bringup/ALIGNMENT_MATRIX.md</code></li> <li>Added machine artifacts for this milestone:</li> <li><code>docs/bringup/gates/linxisa_virt_defconfig_audit.json</code></li> <li><code>docs/bringup/gates/qemu_opcode_sync_latest.json</code></li> <li><code>docs/bringup/gates/qemu_isa_coverage_latest.json</code></li> </ul>"},{"location":"bringup/MATURITY_PLAN/#m2-3-6-weeks-avs-core-coverage-expansion","title":"M2 (3-6 weeks): AVS core coverage expansion","text":"<p>Status: Planned</p> <ul> <li>Implement missing core AVS IDs first: <code>DEC/BLK/BR/MEM/ALU/ATOM</code>.</li> <li>Implement <code>FP</code> and <code>VEC</code> IDs next.</li> <li>Promote AVS matrix status validation as strict maturity artifact:</li> <li>checker: <code>tools/bringup/check_avs_matrix_status.py</code></li> <li>artifact: <code>docs/bringup/gates/avs_matrix_status_audit.json</code></li> </ul>"},{"location":"bringup/MATURITY_PLAN/#m3-4-8-weeks-emulatormodel-completeness-gates","title":"M3 (4-8 weeks): Emulator/model completeness gates","text":"<p>Status: Started (coverage reporting landed; suite expansion pending)</p> <ul> <li>Keep canonical ISA-vs-QEMU coverage report machine-generated:</li> <li><code>tools/bringup/report_qemu_isa_coverage.py</code></li> <li>Expand <code>run_model_diff_suite.py</code> required coverage from scalar/basic to vector/tile + restart/fault scenarios.</li> <li>Keep unsupported instructions deterministic via explicit illegal traps until implemented.</li> </ul>"},{"location":"bringup/MATURITY_PLAN/#m4-4-10-weeks-hosted-toolchainruntime-workload-maturity","title":"M4 (4-10 weeks): Hosted toolchain/runtime workload maturity","text":"<p>Status: Planned</p> <ul> <li>Close <code>SPEC-001..SPEC-007</code> in <code>docs/bringup/agent_runs/checklists/specint_qemu.md</code>.</li> <li>Keep 9p/virtfs compatibility (<code>LINUX-003</code>) as hard prerequisite for SPEC lane.</li> <li>Evolve C++ runtime policy beyond current no-EH/no-RTTI baseline once dual-lane evidence is stable.</li> <li>Convert ABI/unwind/TLS checklist into executable runtime gates.</li> </ul>"},{"location":"bringup/MATURITY_PLAN/#m5-6-12-weeks-privilegedmmudebug-parity","title":"M5 (6-12 weeks): Privileged/MMU/debug parity","text":"<p>Status: Planned</p> <ul> <li>Close privileged/MMU/debug gaps in <code>docs/bringup/ISA_GAP_ANALYSIS.md</code>.</li> <li>Add Linux selftests for restartable tile faults and bridged memory ordering.</li> <li>Define minimal debug architecture contract (single-step, breakpoints/watchpoints, privilege interactions).</li> </ul>"},{"location":"bringup/MATURITY_PLAN/#m6-ongoing-performance-and-release-grade-parity","title":"M6 (ongoing): Performance and release-grade parity","text":"<p>Status: Planned</p> <ul> <li>Keep benchmark methodology and artifact discipline under <code>workloads/generated/</code>.</li> <li>Track static/dynamic instruction trends and optimization roadmap closure.</li> <li>Expand CI-like orchestration for full-stack, cross-repo reproducibility.</li> </ul>"},{"location":"bringup/MATURITY_PLAN/#required-policy-defaults","title":"Required Policy Defaults","text":"<ul> <li>No new waivers by default for required strict gates.</li> <li>Dual-lane promotion remains required (<code>pin</code> + <code>external</code>).</li> <li>Existing strict green gates remain mandatory while maturity gates are added incrementally.</li> </ul>"},{"location":"bringup/PROGRESS/","title":"Bring-up Progress (v0.4 workspace)","text":"<p>Last updated: 2026-02-22</p>"},{"location":"bringup/PROGRESS/#phase-status","title":"Phase status","text":"Phase Status Evidence 1. Contract freeze (26 checks) \u2705 Passed <code>python3 tools/bringup/check26_contract.py --root .</code> 2. linxisa v0.3 cutover \u2705 Passed <code>bash tools/regression/run.sh</code> 3. LLVM MC/CodeGen alignment \u2705 Passed <code>llvm-lit llvm/test/MC/LinxISA llvm/test/CodeGen/LinxISA</code> 4. QEMU runtime/system alignment \u2705 Passed <code>avs/qemu/check_system_strict.sh</code>; <code>avs/qemu/run_tests.sh --all</code> 5. Linux userspace boot path \u2705 Passed <code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code>; <code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> 6. pyCircuit + Janus model alignment \u2705 Bring-up scope complete pyCircuit/Janus run scripts 7. Skills/docs sync + full stack regression \u2705 Passed <code>CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld LLVM_ROOT=compiler/llvm QEMU=${QEMU_ROOT}/build/qemu-system-linx64 LINUX_ROOT=${LINUX_ROOT} LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 bash tools/regression/full_stack.sh</code> 8. musl Linux runtime bring-up \u2705 Phase-B runtime pass <code>MODE=phase-b lib/musl/tools/linx/build_linx64_musl.sh</code>; <code>python3 avs/qemu/run_musl_smoke.py --mode phase-b</code>"},{"location":"bringup/PROGRESS/#level-1-closure-activation-2026-02-17","title":"Level 1 closure activation (2026-02-17)","text":"<ul> <li>Release-strict gating now enforces:</li> <li>check26 directed coverage linkage (including <code>Model</code> domain tests),</li> <li>QEMU-vs-model differential suite as a required gate,</li> <li>trace schema version compatibility checks,</li> <li>external/pin lane parity checks for required gate sets,</li> <li>strict multi-agent manifest/checklist/waiver validation.</li> <li>Current blockers are tracked in <code>docs/bringup/MATURITY_PLAN.md</code> immediate backlog.</li> </ul>"},{"location":"bringup/PROGRESS/#gate-snapshot","title":"Gate snapshot","text":"Gate Status Command AVS compile-only (<code>linx64</code>/<code>linx32</code>) \u2705 <code>./avs/compiler/linx-llvm/tests/run.sh</code> AVS runtime suites \u2705 <code>./avs/qemu/run_tests.sh --all</code> Strict system gate \u2705 <code>./avs/qemu/check_system_strict.sh</code> Multi-agent strict checklist gate \u2705 Policy enabled <code>python3 tools/bringup/check_multi_agent_gates.py --strict-always --mode static --manifest docs/bringup/agent_runs/manifest.yaml --waivers docs/bringup/agent_runs/waivers.yaml --checklists-root docs/bringup/agent_runs/checklists</code> Main regression \u2705 <code>bash tools/regression/run.sh</code> Linux initramfs smoke/full \u2705 <code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code>; <code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> glibc <code>G1a</code> \u2705 (<code>configure</code> + <code>csu/subdir_lib</code>) <code>bash lib/glibc/tools/linx/build_linx64_glibc.sh</code> musl <code>M1</code> \u2705 <code>MODE=phase-b lib/musl/tools/linx/build_linx64_musl.sh</code> musl <code>M2</code> \u2705 (phase-b strict) <code>out/libc/musl/logs/phase-b-summary.txt</code> musl <code>M3</code> \u2705 (phase-b strict) <code>out/libc/musl/logs/phase-b-summary.txt</code>; <code>out/libc/musl/logs/phase-b-m3-shared.log</code> musl runtime <code>R1</code> \u2705 <code>avs/qemu/out/musl-smoke/compile.log</code> musl runtime <code>R2</code> \u2705 <code>avs/qemu/out/musl-smoke/qemu.log</code>"},{"location":"bringup/PROGRESS/#latest-command-log","title":"Latest command log","text":"<ul> <li> <p>virtio-9p over virtio-mmio: debug in progress (currently EPROTO -71); see <code>docs/bringup/virtio_9p_debug.md</code></p> </li> <li> <p><code>MODE=phase-b lib/musl/tools/linx/build_linx64_musl.sh</code> \u2705 (<code>M1/M2/M3</code> pass)</p> </li> <li><code>python3 avs/qemu/run_musl_smoke.py --mode phase-b</code> \u2705 (<code>runtime_pass</code>)</li> <li><code>bash lib/glibc/tools/linx/build_linx64_glibc.sh</code> \u2705 (<code>G1a</code>: configure + <code>csu/subdir_lib</code> + <code>crt1.o</code>)</li> <li><code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code> \u2705</li> <li><code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code> \u2705</li> <li><code>python3 tools/bringup/check_multi_agent_gates.py --strict-always --mode static --manifest docs/bringup/agent_runs/manifest.yaml --waivers docs/bringup/agent_runs/waivers.yaml --checklists-root docs/bringup/agent_runs/checklists</code> \u2705</li> <li><code>bash tools/regression/strict_cross_repo.sh</code> \u2705</li> <li><code>CLANG=${LLVM_ROOT}/build-linxisa-clang/bin/clang LLD=${LLVM_ROOT}/build-linxisa-clang/bin/ld.lld LLVM_ROOT=compiler/llvm QEMU=${QEMU_ROOT}/build/qemu-system-linx64 LINUX_ROOT=${LINUX_ROOT} LINX_DISABLE_TIMER_IRQ=1 LINX_EMU_DISABLE_TIMER_IRQ=0 bash tools/regression/full_stack.sh</code> \u2705</li> </ul>"},{"location":"bringup/PROGRESS/#canonical-gate-table","title":"Canonical Gate Table","text":"<ul> <li><code>docs/bringup/gates/latest.json</code> is the source-of-truth gate artifact (lane + SHA + command + result).</li> <li><code>docs/bringup/GATE_STATUS.md</code> is generated from the JSON gate artifact.</li> </ul>"},{"location":"bringup/code_density_and_dynamic_reduction/","title":"Code Density And Dynamic Instruction Reduction (Linux Kernel Driven)","text":"<p>This note turns the Linux-kernel static/dynamic instruction stats into a concrete optimization roadmap for LinxISA.</p>"},{"location":"bringup/code_density_and_dynamic_reduction/#data-sources-reproducible","title":"Data Sources (Reproducible)","text":"<ul> <li>Static (vmlinux objdump, block-aware patterns):</li> <li><code>workloads/generated/linux/build-linx-fixed/static_stats.md</code></li> <li><code>workloads/generated/linux/build-linx-fixed/static_stats.json</code></li> <li>Dynamic (QEMU boot sample, 30s histogram):</li> <li><code>workloads/generated/linux/build-linx-fixed/dynamic_stats.md</code></li> <li><code>workloads/generated/qemu/linux/build-linx-fixed/boot_30s.dyn_insn_hist.json</code></li> </ul>"},{"location":"bringup/code_density_and_dynamic_reduction/#key-observations-from-the-current-kernel-snapshot","title":"Key Observations From The Current Kernel Snapshot","text":"<ul> <li>Instruction length mix is already dominated by 16b/32b, so the biggest wins come from removing entire instructions (dynamic count), not only shrinking encodings.</li> <li>Linx block structure is visible in disassembly: <code>*.BSTART*</code> are frequent and block sizes are small (many 2-5 instruction blocks).</li> <li>Two-instruction blocks are common; the most frequent shapes include:</li> <li><code>C.BSTART ; c.setc.eq</code> (large) and <code>C.BSTART ; c.setc.ne</code></li> <li><code>C.BSTART ; &lt;small op&gt;</code> (e.g. <code>c.movr</code>, <code>c.movi</code>, <code>sdi</code>, ...)</li> <li>Hot \u201cextend/mask churn\u201d shows up as:</li> <li>explicit <code>sext.w</code> patterns (often materialized as <code>addw src, zero</code> then compressed to <code>c.sext.w</code>)</li> <li>explicit <code>zext.w</code> patterns (often <code>andiw</code> or shift-pairs)</li> <li>PC-relative symbol access exists (<code>*.PCR</code>), but there are still many cases where codegen falls back to address-materialization sequences, reducing density.</li> </ul>"},{"location":"bringup/code_density_and_dynamic_reduction/#block-aware-pattern-counting-tooling-contract","title":"Block-Aware Pattern Counting (Tooling Contract)","text":"<p>Statistical pattern analysis must respect block boundaries:</p> <ul> <li><code>BSTART</code> begins a block (e.g. <code>C.BSTART</code>, <code>HL.BSTART.STD</code>, <code>BSTART.*</code>).</li> <li><code>BSTOP</code>/<code>BSTACK</code> (if present) terminate a block.</li> <li>N-gram patterns must not cross blocks.</li> </ul> <p>Implementation: <code>tools/analysis/objdump_stats.py</code> resets its n-gram window at block boundaries and additionally reports:</p> <ul> <li>block length histogram</li> <li>top two-instruction block shapes</li> </ul>"},{"location":"bringup/code_density_and_dynamic_reduction/#1-beqhlbeq-fused-alias-no-new-cbr-isa-needed","title":"1) \u201cBEQ/HL.BEQ\u201d Fused Alias (No New CBR ISA Needed)","text":"<p>Constraint: Linx block encoding places the <code>BSTART(..., branch_offset)</code> before the <code>SETC.*</code> compare, so a classic compare+branch fused instruction (CBR) is awkward.</p> <p>Instead, define fused aliases for the common two-instruction conditional blocks:</p> <ul> <li><code>BEQ</code>  = <code>C.BSTART COND,&lt;target&gt;</code> + <code>C.SETC.EQ &lt;lhs&gt;,&lt;rhs&gt;</code></li> <li><code>BNE</code>  = <code>C.BSTART COND,&lt;target&gt;</code> + <code>C.SETC.NE &lt;lhs&gt;,&lt;rhs&gt;</code></li> <li><code>HL.BEQ</code>/<code>HL.BNE</code> similarly, when the target is out of compressed range (or to force a longer form).</li> </ul> <p>Where this helps:</p> <ul> <li>It makes this very common shape explicit, enabling compiler and assembler to treat it as a single semantic unit.</li> <li>It enables targeted peepholes: only emit the fused alias when the block has exactly two instructions.</li> </ul> <p>Required toolchain work:</p> <ul> <li>Assembler: accept <code>beq/bne</code> as pseudo that expands to <code>bstart.cond + setc.*</code> in the correct order.</li> <li>Disassembler: optionally re-sugar the two-instruction block back into <code>beq/bne</code> for readability.</li> <li>LLVM Blockify: when a block\u2019s entire body is exactly <code>{BSTART.COND, SETC.EQ/NE}</code>, emit the fused alias in the MIR-level representation so later passes can reason about it.</li> </ul>"},{"location":"bringup/code_density_and_dynamic_reduction/#2-producer-does-extend-using-srcrtype-sw-uw","title":"2) Producer-Does-Extend Using <code>SrcRType</code> (<code>.sw</code> / <code>.uw</code>)","text":"<p>Goal: remove explicit <code>sext.w</code> / <code>zext.w</code> instructions by tagging consumers.</p> <p>Mechanism already present in ISA encoding for many 32b/48b forms:</p> <ul> <li><code>SrcRType</code> is a 2-bit field:</li> <li><code>0</code>: <code>.sw</code>  (sign-extend low 32 bits)</li> <li><code>1</code>: <code>.uw</code>  (zero-extend low 32 bits)</li> <li><code>2</code>: <code>.neg/.not</code> (existing use)</li> <li><code>3</code>: none</li> </ul> <p>Encoding suggestions (concrete, non-conflicting):</p> <ol> <li>Keep compressed <code>C.SETC.*</code> as-is (no <code>SrcRType</code> bits available).</li> <li>Prefer promotion from <code>{c.sext.w + C.SETC.*}</code> (2x16b) to <code>{SETC.* with SrcRType}</code> (1x32b) when it deletes an instruction:</li> <li>size stays ~constant, dynamic instruction count drops.</li> <li>Expand the same policy to <code>CMP.*</code> when its <code>SrcRType</code> is available:</li> <li>fold local <code>sext.w</code>/<code>zext.w</code> producers into <code>cmp.* &lt;lhs&gt;, &lt;rhs.{sw|uw}&gt;</code></li> <li>For additional ALU ops (future work), do not try to retrofit <code>.sw/.uw</code> into 16b compressed encodings; prefer:</li> <li>a 32b \u201ctyped-srcR\u201d variant in unused encoding space, or</li> <li>an HL.* long form that carries <code>SrcRType</code> when 32b space is tight.</li> </ol> <p>Compiler work required:</p> <ul> <li>Add a distinct MI-operand flag for <code>.sw</code> (in addition to <code>.uw</code>).</li> <li>Peepholes:</li> <li>fold local <code>sext.w</code> producers feeding <code>SETC/CMP</code> into <code>SrcRType=.sw</code></li> <li>fold local <code>zext.w</code> producers feeding <code>SETC/CMP</code> into <code>SrcRType=.uw</code></li> <li>Heuristic:</li> <li>allow selecting 32b SETC/CMP with <code>SrcRType</code> when it replaces (removes) one or more instructions.</li> </ul>"},{"location":"bringup/code_density_and_dynamic_reduction/#3-pc-relative-codegen-must-prefer-pcr-loadstore-exactly-pc-relative","title":"3) PC-Relative Codegen Must Prefer <code>*.PCR</code> (Load/Store Exactly PC-Relative)","text":"<p>Policy:</p> <ul> <li>Global/constpool loads/stores should prefer <code>LB/LH/LW/LD.PCR</code> and <code>SB/SH/SW/SD.PCR</code>.</li> <li>Out-of-range should be handled by relaxation to <code>HL.*.PCR</code> (not by falling back to general address materialization).</li> </ul> <p>LLVM lowering strategy:</p> <ul> <li>Keep <code>GlobalAddress</code> lowering as PC-relative (page+low) only as an internal representation.</li> <li>In DAG-to-DAG isel, aggressively fold:</li> <li><code>addr = ADDI(ADDTPC(sym), sym) [+ const]</code></li> <li><code>load/store [addr]</code></li> <li>into <code>*.PCR</code> forms.</li> <li>Make the folding robust to equivalent (but not pointer-identical) symbol nodes.</li> </ul>"},{"location":"bringup/code_density_and_dynamic_reduction/#4-use-existing-bit-manip-concat-aggressively","title":"4) Use Existing Bit-Manip + CONCAT Aggressively","text":"<p>Already in ISA:</p> <ul> <li><code>BXU</code> / <code>BXS</code>: bitfield extract unsigned/signed</li> <li><code>BCNT</code>: popcount</li> <li><code>CONCAT</code>: enables barrel-shift style patterns by concatenating <code>(srcL,srcR)</code> then shifting.</li> </ul> <p>Required LLVM work:</p> <ul> <li>TableGen / DAG combines:</li> <li><code>sll; srl/sra</code> -&gt; <code>BXU/BXS</code> (already present as a peephole in Blockify; ensure it triggers on more shapes)</li> <li><code>popcount</code> -&gt; <code>BCNT</code></li> <li><code>rotl/rotr</code> -&gt; <code>CONCAT + shift</code> sequences (or a dedicated pattern if one exists)</li> </ul>"},{"location":"bringup/code_density_and_dynamic_reduction/#5-template-blocks-mcopy-mset-library-accelerator-path","title":"5) Template Blocks: <code>MCOPY</code> / <code>MSET</code> (Library + Accelerator Path)","text":"<p>Already in ISA:</p> <ul> <li><code>MCOPY</code> template block for <code>memcpy/memmove</code></li> <li><code>MSET</code> template block for <code>memset</code></li> </ul> <p>Roadmap:</p> <ol> <li>libc implements hand-written entry points that map to these templates for common size/align ranges.</li> <li>LLVM recognizes builtin patterns and selects templates (or calls libc stubs) depending on size thresholds.</li> <li>Later: identify additional kernel hot regions and define more template blocks so the CPU can offload to ASIC components.</li> </ol>"},{"location":"bringup/code_density_and_dynamic_reduction/#suggested-next-measurements","title":"Suggested Next Measurements","text":"<ul> <li>Re-run kernel static+dynamic stats after each compiler change (same build dir, same QEMU window):</li> <li>track <code>C.SETC.*</code>, <code>C.SEXT.W</code>, <code>ANDIW</code>, <code>HL.LUI</code>, <code>*.PCR</code> frequencies.</li> <li>Add dynamic \u201ctop PCs\u201d to the QEMU plugin (PC-&gt;count) to localize hotspots to functions/symbols.</li> <li>Add a \u201ctwo-instruction block candidate report\u201d that specifically counts:</li> <li><code>C.BSTART ; c.setc.eq/ne</code> and branch-target reachability classes.</li> </ul>"},{"location":"bringup/libc_status/","title":"Linx libc Bring-up Status","text":"<p>Canonical libc sources:</p> <ul> <li><code>lib/glibc</code></li> <li><code>lib/musl</code></li> </ul>"},{"location":"bringup/libc_status/#repositories-and-pins","title":"Repositories and pins","text":"<ul> <li><code>lib/glibc</code> @ <code>69493c1b395a23546cab196947d6424003a9f5ed</code></li> <li><code>lib/musl</code> @ <code>5b90c23dde11df89f37cf004256dff738510b469</code></li> </ul>"},{"location":"bringup/libc_status/#current-policy","title":"Current policy","text":"<ul> <li>Bring-up deltas live in fork history (<code>LinxISA/glibc</code>, <code>LinxISA/musl</code>).</li> <li>This repository provides orchestration, runtime smoke, and status tracking.</li> <li>Release-strict gating uses canonical artifacts from <code>docs/bringup/gates/latest.json</code>.</li> </ul>"},{"location":"bringup/libc_status/#release-strict-baseline-2026-02-17","title":"Release-strict baseline (2026-02-17)","text":"<ul> <li>glibc <code>G1a</code>: \u2705 pass (<code>configure</code> + <code>csu/subdir_lib</code> + startup objects)</li> <li>glibc <code>G1b</code>: pass</li> <li>musl runtime <code>R2</code>: pass</li> </ul>"},{"location":"bringup/libc_status/#evidence-pointers","title":"Evidence pointers","text":"<ul> <li>Canonical gate artifact: <code>docs/bringup/gates/latest.json</code></li> <li>Rendered gate table: <code>docs/bringup/GATE_STATUS.md</code></li> <li>glibc logs: <code>docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/lib_glibc_g1b.log</code></li> <li>musl logs: <code>docs/bringup/gates/logs/2026-02-17-r1-external-phase4b/external/lib_musl_both.log</code></li> </ul>"},{"location":"bringup/libc_status/#notes","title":"Notes","text":"<ul> <li>Release-strict sign-off does not allow blocked waivers for required libc gates.</li> <li>Runtime numeric/benchmark parity remains outside libc bring-up scope.</li> </ul>"},{"location":"bringup/virtio_9p_debug/","title":"virtio-9p bring-up status (Linx virt)","text":""},{"location":"bringup/virtio_9p_debug/#summary","title":"Summary","text":"<p>We are bringing up host\u2192guest file sharing for the Linx Linux bring-up using virtio-9p over virtio-mmio.</p> <p>Current status:</p> <ul> <li>virtio-mmio transport(s): working (guest enumerates virtio devices)</li> <li>virtio-blk on virtio-mmio: working (guest sees <code>vda</code>)</li> <li>virtio-9p mount: failing with <code>EPROTO (-71)</code> when running <code>mount -t 9p render-share /opt/share ...</code></li> </ul>"},{"location":"bringup/virtio_9p_debug/#minimal-reproduction","title":"Minimal reproduction","text":""},{"location":"bringup/virtio_9p_debug/#qemu","title":"QEMU","text":"<p>Use Linx virt DT-provided transports (do not add <code>virtio_mmio.device=...</code> when DT already declares virtio-mmio nodes).</p> <p>Example:</p> <pre><code>QEMU=~/linx-isa/emulator/qemu/build/qemu-system-linx64\nKERNEL=~/linx-isa/kernel/linux/build-linx-render/vmlinux\nINITRD=~/linx-isa/kernel/linux/build-linx-fixed/linx-initramfs/initramfs.cpio\nSHARE=~/linx-isa/out/render-share\n\n$QEMU \\\n  -machine virt -m 1024M -smp 1 \\\n  -kernel \"$KERNEL\" -initrd \"$INITRD\" \\\n  -append \"console=ttyS0 lpj=1000000 loglevel=7\" \\\n  -nographic -monitor none \\\n  -fsdev local,id=fsdev0,path=\"$SHARE\",security_model=none,multidevs=remap \\\n  -device virtio-9p-device,fsdev=fsdev0,mount_tag=render-share\n</code></pre>"},{"location":"bringup/virtio_9p_debug/#guest","title":"Guest","text":"<p>In initramfs, run <code>m9p</code> (debug applet) to attempt the mount and print the raw return code:</p> <ul> <li>expected today: <code>9p_mount=ffffffffffffffb9</code>  (== -71, EPROTO)</li> </ul>"},{"location":"bringup/virtio_9p_debug/#known-pitfalls-notes","title":"Known pitfalls / notes","text":"<ul> <li>If you pass <code>virtio_mmio.device=0x200@0x30001000:1</code> while the DT already contains virtio-mmio nodes, Linux may attempt to register a second virtio-mmio transport and hit probe conflicts (e.g. <code>-16</code>).</li> <li>Endianness assumption: little-endian for virtio and 9p protocol fields.</li> </ul>"},{"location":"bringup/virtio_9p_debug/#related-prs","title":"Related PRs","text":"<ul> <li>QEMU: multi, modern virtio-mmio transports for linx virt (infrastructure for virtio bring-up)</li> <li>https://github.com/LinxISA/qemu/pull/19</li> <li>Linux: initramfs <code>m9p</code> applet and <code>/opt/share</code> dirs for in-guest reproduction</li> <li>https://github.com/LinxISA/linux/pull/15</li> </ul>"},{"location":"bringup/virtio_9p_debug/#next-debug-steps","title":"Next debug steps","text":"<ul> <li>Add minimal QEMU-side logging for the first 9p exchange (Tversion/Rversion) to determine if the failure is:</li> <li>feature negotiation mismatch</li> <li>virtqueue descriptor parsing issue</li> <li>payload endian/length decoding issue</li> </ul>"},{"location":"bringup/agent_runs/checklists/compiler_llvm/","title":"Compiler / LLVM Checklist","text":"<ul> <li> <p>[x] ID: LLVM-001 Build pinned toolchain and pass AVS compile suites for <code>linx64</code> and <code>linx32</code>.   Command: <code>cd avs/compiler/linx-llvm/tests &amp;&amp; CLANG=compiler/llvm/build-linxisa-clang/bin/clang ./run.sh</code>   Done means: both targets compile cleanly and logs are archived under the active gate run directory.   Status: \u2705 PASS (2026-02-23) - convergence run <code>2026-02-23-r4-pin-qemu-linux-ctxfix</code> passes both targets (logs: <code>docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/compiler_linx64.log</code>, <code>docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/compiler_linx32.log</code>).</p> </li> <li> <p>[x] ID: LLVM-002 Verify mnemonic coverage stays at 100% for <code>linx64</code> and <code>linx32</code> outputs.   Command: <code>python3 avs/compiler/linx-llvm/tests/analyze_coverage.py --out-dir ... --fail-under 100</code>   Done means: both coverage checks pass with no missing mnemonics.   Status: \u2705 PASS (2026-02-23) - both coverage checks report <code>Coverage: 100.0%</code> (logs: <code>docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/compiler_cov_linx64.log</code>, <code>docs/bringup/gates/logs/2026-02-23-r4-pin-qemu-linux-ctxfix/pin/compiler_cov_linx32.log</code>).</p> </li> <li> <p>[x] ID: LLVM-003 Confirm v0.3 TEPL encodings in LLVM stay aligned with manual and QEMU.   Command: <code>python3 tools/bringup/check_tepl_encoding.py --root .</code>   Done means: script returns <code>OK</code> and no legacy TEPL encoding is present.   Status: \u2705 PASS (2026-02-23) - <code>check_tepl_encoding.py</code> returns <code>OK</code> (log: <code>docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/compiler_tepl.log</code>).</p> </li> <li> <p>[x] ID: LLVM-004 Rebuild C++ runtime overlay for target mode when runtime gates require it.   Command: <code>bash tools/build_linx_llvm_cpp_runtimes.sh --profile spec --mode phase-c</code>   Done means: runtime overlay artifacts are present and linkable in the sysroot.   Status: \u2705 PASS (2026-02-23) - C++ runtime overlay build completes with <code>ok: Linx C++ runtimes ready</code> (log: <code>docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/compiler_cpp_runtime_phasec.log</code>).</p> </li> <li> <p>[x] ID: LLVM-005 Record commit SHA and submodule bump evidence for LLVM changes.   Done means: SHA is captured in gate report lane manifest and referenced in change notes.   Status: \u2705 PASS (2026-02-25) - strict run <code>2026-02-25-r2-pin-lanefix</code> captures LLVM SHA in <code>docs/bringup/gates/latest.json</code> (<code>runs[-1].sha_manifest.llvm.sha</code>) and rendered lane manifest in <code>docs/bringup/GATE_STATUS.md</code>.</p> </li> </ul>"},{"location":"bringup/agent_runs/checklists/emulator_qemu/","title":"Emulator / QEMU Checklist","text":"<ul> <li> <p>[x] ID: QEMU-001 Pass strict-system gate with timer IRQ policy required by strict runs.   Command: <code>cd avs/qemu &amp;&amp; LINX_DISABLE_TIMER_IRQ=0 ./check_system_strict.sh</code>   Done means: strict system suite passes with no trap-noise regressions.   Status: \u2705 PASS (2026-02-25) - strict system re-verified in run <code>2026-02-25-r2-pin-lanefix</code> with <code>*** REGRESSION PASSED ***</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/emu_strict_system.log</code>).</p> </li> <li> <p>[x] ID: QEMU-002 Pass runtime AVS suites (<code>--all</code>) with timeout budget.   Command: <code>cd avs/qemu &amp;&amp; ./run_tests.sh --all --timeout 10</code>   Done means: all runtime suites pass and logs are attached to gate evidence.   Status: \u2705 PASS (2026-02-25) - <code>run_tests.sh --all --timeout 10</code> re-verified in run <code>2026-02-25-r2-pin-lanefix</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/emu_all_suites.log</code>).</p> </li> <li> <p>[x] ID: QEMU-003 Keep regenerated opcode meta/id tables synchronized with decode sources.   Command: <code>python3 tools/bringup/check_qemu_opcode_meta_sync.py --allowlist docs/bringup/qemu_opcode_sync_allowlist.json --report-out docs/bringup/gates/qemu_opcode_sync_latest.json --out-md docs/bringup/gates/qemu_opcode_sync_latest.md</code>   Files: <code>emulator/qemu/target/linx/linx_opcode_ids_gen.h</code>, <code>emulator/qemu/target/linx/linx_opcode_meta_gen.h</code>   Done means: opcode audit reports no unexpected decode/meta drift and no enum/meta op-id mismatch.   Status: \u2705 PASS (2026-02-25) - opcode sync audit returns <code>qemu_opcode_meta_sync_ok</code> with <code>decode_only_unexpected=0</code>, <code>meta_only_unexpected=0</code>, and <code>id_mismatch_count=0</code> (artifacts: <code>docs/bringup/gates/qemu_opcode_sync_latest.json</code>, <code>docs/bringup/gates/qemu_opcode_sync_latest.md</code>).</p> </li> <li> <p>[x] ID: QEMU-004 Validate trap semantics match strict v0.3 clarifications for CFI/BLOCKFMT/BFETCH.   Done means: no conflicting trap behavior is observed in strict-system and model-diff gates.   Status: \u2705 PASS (2026-02-25) - strict system and model-diff are both green in run <code>2026-02-25-r2-pin-lanefix</code> (logs: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/emu_strict_system.log</code>, <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/model_diff_suite.log</code>).</p> </li> <li> <p>[x] ID: QEMU-005 ISA spec vs QEMU implementation gap analysis.   Command: <code>python3 tools/bringup/report_qemu_isa_coverage.py --report-out docs/bringup/gates/qemu_isa_coverage_latest.json --out-md docs/bringup/gates/qemu_isa_coverage_latest.md</code>   Done means: Canonical machine-generated coverage report is refreshed and captures missing spec mnemonics.   Status: \u2705 PASS (2026-02-25) - coverage report generated with <code>coverage=311/710</code>, <code>missing=399</code>, and explicit missing/unmapped lists (artifacts: <code>docs/bringup/gates/qemu_isa_coverage_latest.json</code>, <code>docs/bringup/gates/qemu_isa_coverage_latest.md</code>).</p> </li> <li> <p>[x] ID: QEMU-006 QEMU can boot full Linux with complete runtime APIs.   Done means: Linux kernel boots with timer interrupts working, full syscalls available.   Status: \u2705 PASS (2026-02-25) - full-OS closure gate is green in run <code>2026-02-25-r2-pin-lanefix</code> (<code>strict_cross_repo.sh</code> pass and BusyBox rootfs boot pass evidence in <code>kernel_busybox_rootfs.log</code>).</p> </li> </ul>"},{"location":"bringup/agent_runs/checklists/emulator_qemu/#isa-vs-qemu-implementation-gap-analysis","title":"ISA vs QEMU Implementation Gap Analysis","text":""},{"location":"bringup/agent_runs/checklists/emulator_qemu/#summary","title":"Summary","text":"<ul> <li>ISA spec: 710 unique mnemonics</li> <li>QEMU mapped spec coverage: 311 unique mnemonics</li> <li>Gap: 399 mnemonics currently outside mapped QEMU decode coverage</li> </ul>"},{"location":"bringup/agent_runs/checklists/emulator_qemu/#categories-of-missing-instructions","title":"Categories of Missing Instructions","text":"<ol> <li>Vector instructions (<code>V.*</code>): large uncovered set remains</li> <li>Compressed/HL variants: many <code>C.*</code> and <code>HL.*</code> forms remain uncovered</li> <li>Block/tile families: additional <code>BSTART.*</code>, tile/template forms remain uncovered</li> <li>MMU/debug/system breadth: privileged/system families beyond current bring-up subset remain uncovered</li> </ol>"},{"location":"bringup/agent_runs/checklists/emulator_qemu/#key-findings","title":"Key Findings","text":"<ul> <li>Basic RISC-like ALU ops (ADD, SUB, etc.) are implemented</li> <li>Block control flow (BSTART/BSTOP) is implemented</li> <li>Atomic operations (AMO) are implemented</li> <li>System instructions (ACRC, ACRE, SSRGET/SRRSET) are implemented</li> <li>Vector and tile operations are largely missing</li> </ul>"},{"location":"bringup/agent_runs/checklists/integration_release/","title":"Integration / Release Checklist","text":"<ul> <li> <p>[x] ID: INT-001 Validate ISA check26 contract before cross-repo runtime gates.   Command: <code>python3 tools/bringup/check26_contract.py --root .</code>   Done means: contract gate passes and canonical patterns are present.   Status: \u2705 PASS (2026-02-25) - <code>check26_contract.py</code> is pass in run <code>2026-02-25-r2-pin-lanefix</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/isa_check26.log</code>).</p> </li> <li> <p>[x] ID: INT-002 Verify all required gate rows are assigned to a known agent checklist.   Done means: multi-agent static validator reports no unassigned required gate keys.   Status: \u2705 PASS (2026-02-25) - <code>check_multi_agent_gates.py --strict-always --mode static</code> returns <code>ok: multi-agent static validation passed (agents=6, assignments=21)</code> after adding ownership for virtio-disk and QEMU maturity audit gate keys.</p> </li> <li> <p>[x] ID: INT-003 Require model differential suite pass in strict runtime closure.   Command: <code>python3 tools/bringup/run_model_diff_suite.py ...</code>   Done means: model diff row is <code>pass</code> or explicitly waived via ledger.   Status: \u2705 PASS (2026-02-25) - model-diff strict profile passes in run <code>2026-02-25-r2-pin-lanefix</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/model_diff_suite.log</code>).</p> </li> <li> <p>[x] ID: INT-004 Require <code>strict_cross_repo.sh</code> pass in strict closure.   Command: <code>bash tools/regression/strict_cross_repo.sh</code>   Done means: regression row is <code>pass</code> or explicitly waived via ledger.   Status: \u2705 PASS (2026-02-25) - <code>strict_cross_repo.sh</code> passes in run <code>2026-02-25-r2-pin-lanefix</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/reg_strict_cross_repo.log</code>).</p> </li> <li> <p>[x] ID: INT-005 Emit per-run multi-agent closure summary JSON.   Artifact: <code>docs/bringup/gates/logs/&lt;run-id&gt;/&lt;lane&gt;/multi_agent_summary.json</code>   Done means: summary exists, <code>ok=true</code>, and includes waiver decisions.   Status: \u2705 PASS (2026-02-25) - runtime closure summary exists with <code>ok=true</code> for run <code>2026-02-25-r2-pin-lanefix</code> (artifact: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/multi_agent_summary.strict_cross.json</code>).</p> </li> <li> <p>[x] ID: INT-006 Keep <code>docs/bringup/GATE_STATUS.md</code> generated from canonical JSON report.   Command: <code>python3 tools/bringup/gate_report.py render --report docs/bringup/gates/latest.json --out-md docs/bringup/GATE_STATUS.md</code>   Done means: markdown timestamp matches report timestamp.   Status: \u2705 PASS (2026-02-25) - timestamp check passes: <code>latest.json</code> and <code>GATE_STATUS.md</code> both report <code>2026-02-25 12:41:30Z</code>.</p> </li> <li> <p>[x] ID: INT-007 Enforce explicit agent module ownership and canonical skill names.   Command: <code>python3 tools/bringup/check_multi_agent_gates.py --strict-always --mode static</code>   Done means: every agent declares <code>modules[]</code> + <code>skill</code>, and <code>skill</code> is in canonical list.   Status: \u2705 PASS (2026-02-28) - static validator passes in run <code>2026-02-28-r1-phase-next-skills</code> (log: <code>docs/bringup/gates/logs/2026-02-28-r1-phase-next-skills/pin/int_007_008_check_multi_agent.log</code>).</p> </li> <li> <p>[x] ID: INT-008 Allow multi-module ownership only for approved cross-module agents.   Command: <code>python3 tools/bringup/check_multi_agent_gates.py --strict-always --mode static</code>   Done means: agents with multiple modules are explicitly listed in <code>cross_module_agents</code>.   Status: \u2705 PASS (2026-02-28) - same static validation confirms only approved cross-module agents carry multi-module scope (log: <code>docs/bringup/gates/logs/2026-02-28-r1-phase-next-skills/pin/int_007_008_check_multi_agent.log</code>).</p> </li> <li> <p>[x] ID: INT-009 Sync installed skills from canonical map and prune deprecated aliases.   Command: <code>bash skills/linx-skills/scripts/install_canonical_skills.sh</code>   Done means: local <code>$CODEX_HOME/skills</code> keeps only canonical <code>linx-*</code> skills (plus protected utility skills).   Status: \u2705 PASS (2026-02-28) - canonical installer sync completed in run <code>2026-02-28-r1-phase-next-skills</code> (log: <code>docs/bringup/gates/logs/2026-02-28-r1-phase-next-skills/pin/int_009_install_canonical_skills.log</code>).</p> </li> <li> <p>[x] ID: INT-010 Pull latest skills submodule before each bring-up cycle.   Command: <code>bash tools/bringup/sync_canonical_skills.sh --pull-latest</code>   Done means: <code>skills/linx-skills</code> is on latest <code>origin/main</code> and installed into Codex skills.   Status: \u2705 PASS (2026-02-28) - sync script pulled <code>skills/linx-skills</code> to <code>2f9341826d636ab5a429bf6df572bce1aaeb9eed</code> and emitted summary JSON (log: <code>docs/bringup/gates/logs/2026-02-28-r1-phase-next-skills/pin/int_010_sync_canonical_skills.log</code>, artifact: <code>docs/bringup/agent_runs/skills_evolution/latest.json</code>).</p> </li> <li> <p>[x] ID: INT-011 Summarize evolved skills after bring-up work.   Command: <code>bash tools/bringup/finalize_skill_updates.sh --base origin/main</code>   Done means: summary markdown exists in <code>docs/bringup/agent_runs/skills_evolution/</code> with touched skills + SHA + rationale.   Status: \u2705 PASS (2026-02-28) - finalize script produced summary with explicit no-change decision for this run (log: <code>docs/bringup/gates/logs/2026-02-28-r1-phase-next-skills/pin/int_011_finalize_skill_updates.log</code>, artifact: <code>docs/bringup/agent_runs/skills_evolution/summary-2026-02-28-r1-phase-next-skills.md</code>).</p> </li> <li> <p>[x] ID: INT-012 Guard against destructive skill churn before skill commit.   Command: <code>python3 skills/linx-skills/scripts/check_skill_change_scope.py --repo-root skills/linx-skills --base origin/main</code>   Done means: change scope guard passes and only intended skill directories changed.   Status: \u2705 PASS (2026-02-28) - scope guard reports <code>changed=0, removed=0</code> for run <code>2026-02-28-r1-phase-next-skills</code> (log: <code>docs/bringup/gates/logs/2026-02-28-r1-phase-next-skills/pin/int_012_skill_scope_guard.log</code>).</p> </li> </ul>"},{"location":"bringup/agent_runs/checklists/kernel_linux/","title":"Kernel / Linux Checklist","text":"<ul> <li> <p>[x] ID: LINUX-001 Boot initramfs smoke on Linx QEMU.   Command: <code>python3 kernel/linux/tools/linxisa/initramfs/smoke.py</code>   Done means: smoke boot reaches expected userspace marker without trap loop.   Status: \u2705 PASS (2026-02-25) - smoke gate passes in run <code>2026-02-25-r2-pin-lanefix</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/kernel_smoke.log</code>).</p> </li> <li> <p>[x] ID: LINUX-002 Boot full initramfs scenario on Linx QEMU.   Command: <code>python3 kernel/linux/tools/linxisa/initramfs/full_boot.py</code>   Done means: full boot reaches expected completion marker.   Status: \u2705 PASS (2026-02-25) - full boot gate passes in run <code>2026-02-25-r2-pin-lanefix</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/kernel_full_boot.log</code>).</p> </li> <li> <p>[x] ID: LINUX-003 Keep <code>linxisa_virt_defconfig</code> compatible with 9p/virtfs SPEC workflows.   Command: <code>python3 tools/bringup/check_linx_virt_defconfig_spec.py --report-out docs/bringup/gates/linxisa_virt_defconfig_audit.json</code>   Done means: kernel config includes required 9p + virtio-mmio options and still boots.   Status: \u2705 PASS (2026-02-25) - defconfig audit reports <code>linxisa_virt_defconfig_spec_compatible</code> with zero missing/mismatched options (artifact: <code>docs/bringup/gates/linxisa_virt_defconfig_audit.json</code>); initramfs and busybox boot gates remain green in run <code>2026-02-25-r2-pin-lanefix</code>.</p> </li> <li> <p>[x] ID: LINUX-004 Boot BusyBox rootfs from virtio-blk and reach userspace <code>/sbin/init</code>.   Command: <code>python3 kernel/linux/tools/linxisa/busybox_rootfs/boot.py</code>   Done means: BusyBox rootfs boots from <code>/dev/vda</code>, shell commands run, and poweroff path works.   Status: \u2705 PASS (2026-02-25) - BusyBox rootfs boot reaches userspace and expected command markers in run <code>2026-02-25-r2-pin-lanefix</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/kernel_busybox_rootfs.log</code>).</p> </li> </ul>"},{"location":"bringup/agent_runs/checklists/libc_runtime/","title":"libc / Runtime Checklist","text":"<ul> <li> <p>[x] ID: LIBC-001 Build musl sysroots for required modes (phase-b and phase-c when requested).   Command: <code>MODE=phase-c lib/musl/tools/linx/build_linx64_musl.sh</code>   Done means: install trees exist under <code>out/libc/musl/install/&lt;mode&gt;</code>.   Status: \u2705 PASS (2026-02-23) - <code>MODE=phase-c</code> musl build completes (<code>M1/M2/M3</code> pass) in this run (log: <code>docs/bringup/gates/logs/2026-02-23-r2-pin-reassess/pin/lib_musl_phasec.log</code>).</p> </li> <li> <p>[x] ID: LIBC-002 Build glibc G1b shared libc gate artifacts.   Command: <code>bash lib/glibc/tools/linx/build_linx64_glibc_g1b.sh</code>   Done means: <code>out/libc/glibc/logs/g1b-summary.txt</code> reports pass or explicit waived block.   Status: \u2705 PASS (2026-02-25) - <code>g1b-summary.txt</code> reports pass in run <code>2026-02-25-r2-pin-lanefix</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/lib_glibc_g1b.log</code>; summary: <code>out/libc/glibc/logs/g1b-summary.txt</code>).</p> </li> <li> <p>[x] ID: LIBC-003 Pass musl runtime smoke for static and shared modes.   Command: <code>python3 avs/qemu/run_musl_smoke.py --mode phase-b --link both</code>   Done means: summary json for static/shared reports <code>ok=true</code>.   Status: \u2705 PASS (2026-02-25) - phase-b combined runtime smoke passes in run <code>2026-02-25-r2-pin-lanefix</code> (log: <code>docs/bringup/gates/logs/2026-02-25-r2-pin-lanefix/pin/lib_musl_both.log</code>; summary: <code>avs/qemu/out/musl-smoke/summary.json</code>).</p> </li> <li> <p>[x] ID: LIBC-004 Keep runtime status evidence updated in bring-up gate artifacts.   Done means: gate report rows include evidence links for musl/glibc runtime checks.   Status: \u2705 PASS (2026-02-25) - <code>docs/bringup/gates/latest.json</code> includes refreshed runtime evidence for run <code>2026-02-25-r2-pin-lanefix</code> (<code>Library::musl runtime static+shared</code>, <code>Library::glibc G1b shared libc.so</code>).</p> </li> </ul>"},{"location":"bringup/agent_runs/checklists/specint_qemu/","title":"SPECint / QEMU Checklist","text":"<ul> <li> <p>[ ] ID: SPEC-001 Build SPEC CPU2017 intrate binaries for Linx (<code>phase-c</code>) without patching SPEC sources.   Command: <code>MODE=phase-c bash tools/spec2017/build_int_rate_linx.sh --build-runtimes</code>   Done means: expected Linx executables are produced under each bench <code>exe/</code> directory.   Status: \u26a0\ufe0f NOT TESTED (2026-02-23)</p> </li> <li> <p>[ ] ID: SPEC-002 Verify produced executables are Linx machine type.   Command: <code>llvm-readelf -h benchspec/CPU/&lt;bench&gt;/exe/&lt;binary&gt;</code>   Done means: headers report <code>Machine: Linx</code>.   Status: \u26a0\ufe0f NOT TESTED (2026-02-23)</p> </li> <li> <p>[ ] ID: SPEC-003 Stage A fast subset run under QEMU (9p/virtfs).   Benches: <code>999.specrand_ir</code>, <code>505.mcf_r</code>, <code>531.deepsjeng_r</code>   Done means: all subset jobs complete with host-side specdiff pass.   Status: \u26a0\ufe0f NOT TESTED (2026-02-23)</p> </li> <li> <p>[ ] ID: SPEC-004 Stage A summary artifact is written.   Artifact: <code>workloads/spec2017/.../tmp/linx-qemu-results/stage_a_summary.json</code>   Done means: qemu exit, trap detection, and specdiff verdict are recorded per benchmark.   Status: \u26a0\ufe0f NOT TESTED (2026-02-23)</p> </li> <li> <p>[ ] ID: SPEC-005 Stage B full int-rate run under QEMU (excluding Fortran policy exclusions).   Done means: all required Stage B intrate benchmarks run and emit validation outputs.   Status: \u26a0\ufe0f NOT TESTED (2026-02-23)</p> </li> <li> <p>[ ] ID: SPEC-006 Stage B host-side specdiff validation passes for required compares.   Done means: every required compare command returns pass.   Status: \u26a0\ufe0f NOT TESTED (2026-02-23)</p> </li> <li> <p>[ ] ID: SPEC-007 Explicitly exclude <code>548.exchange2_r</code> from required Linx intrate closure.   Done means: exclusion is documented in manifest policy and enforced by gate review.   Status: \u26a0\ufe0f NOT TESTED (2026-02-23)</p> </li> </ul>"},{"location":"bringup/agent_runs/skills_evolution/summary-2026-02-28-r1-phase-next-skills/","title":"Skills Evolution Summary","text":"<ul> <li>Generated (UTC): 2026-02-28 11:07:16Z</li> <li>Base ref: origin/main</li> <li>Submodule SHA: 2f9341826d636ab5a429bf6df572bce1aaeb9eed</li> <li>Submodule branch: HEAD</li> </ul>"},{"location":"bringup/agent_runs/skills_evolution/summary-2026-02-28-r1-phase-next-skills/#touched-skills","title":"Touched skills","text":"<ul> <li>none</li> </ul>"},{"location":"bringup/agent_runs/skills_evolution/summary-2026-02-28-r1-phase-next-skills/#submodule-status","title":"Submodule status","text":"<ul> <li>clean</li> </ul>"},{"location":"bringup/agent_runs/skills_evolution/summary-2026-02-28-r1-phase-next-skills/#skill-evolve-decision","title":"Skill evolve decision","text":"<ul> <li><code>skill-evolve: no-update (no new reusable findings; no new contracts/gates/triage workflows discovered in this run)</code></li> </ul>"},{"location":"bringup/contracts/fpga_platform_contract/","title":"FPGA Platform Contract (ZYBO Z7-20)","text":"<p>Target board: Xilinx Zynq-7000 based Digilent ZYBO Z7-20.</p>"},{"location":"bringup/contracts/fpga_platform_contract/#fixed-platform-defaults","title":"Fixed platform defaults","text":"<ul> <li>UART MMIO base: <code>0x10000000</code></li> <li>Pass/fail test MMIO register: <code>0x10000004</code></li> </ul> <p>These defaults must remain compatible with existing QEMU-oriented software bring-up paths.</p> <p>Machine-readable form:</p> <ul> <li><code>docs/bringup/contracts/fpga_platform_contract.json</code></li> </ul>"},{"location":"bringup/contracts/fpga_platform_contract/#soc-integration-baseline","title":"SoC integration baseline","text":"<ul> <li>Core is implemented in PL.</li> <li>PL core accesses PS DDR through AXI interconnect/bridge.</li> <li>Linux images and staging buffers live in DDR.</li> </ul>"},{"location":"bringup/contracts/fpga_platform_contract/#boot-mode-default","title":"Boot-mode default","text":"<ul> <li>First Linux milestone uses direct kernel boot path.</li> <li>U-Boot integration is optional and not required for first pass/fail gate.</li> </ul>"},{"location":"bringup/contracts/fpga_platform_contract/#determinism-requirements","title":"Determinism requirements","text":"<ul> <li>Deterministic reset sequencing between PS and PL.</li> <li>Reproducible clocks/constraints for repeated boot tests.</li> <li>UART output is the primary acceptance channel for early milestones.</li> </ul>"},{"location":"bringup/contracts/pyc_artifact_contract/","title":"pyCircuit Artifact Contract","text":""},{"location":"bringup/contracts/pyc_artifact_contract/#authority-and-source-roots","title":"Authority and source roots","text":"<ul> <li>pyCircuit source of truth can be either:</li> <li>the pinned submodule: <code>tools/pyCircuit</code> (recommended for reproducibility), or</li> <li>an external checkout (set <code>PYCIRCUIT_ROOT=/path/to/pyCircuit</code>).</li> <li>Linx CPU source root:</li> <li><code>tools/pyCircuit/examples/linx_cpu_pyc</code></li> <li>Janus source root:</li> <li><code>tools/pyCircuit/janus/pyc/janus</code></li> </ul> <p><code>linxisa</code> does not manually author these RTL/model sources.</p>"},{"location":"bringup/contracts/pyc_artifact_contract/#required-generated-outputs","title":"Required generated outputs","text":"<p>For each tracked core target:</p> <ul> <li>Verilog RTL: <code>*.v</code></li> <li>C++ cycle model headers: <code>*_gen.hpp</code></li> <li>Testbench execution logs (C++ and RTL simulation paths)</li> </ul> <p>Recommended generated locations in pyCircuit:</p> <ul> <li>Linx generated artifacts: <code>tools/pyCircuit/examples/generated/linx_cpu_pyc/</code></li> <li>Janus generated artifacts: <code>tools/pyCircuit/janus/generated/</code></li> </ul>"},{"location":"bringup/contracts/pyc_artifact_contract/#canonical-generation-entrypoints","title":"Canonical generation entrypoints","text":"<ul> <li><code>bash tools/pyCircuit/scripts/pyc build</code></li> <li><code>bash tools/pyCircuit/scripts/pyc regen</code></li> <li><code>bash tools/pyCircuit/janus/update_generated.sh</code></li> </ul> <p>If using an external checkout, prefix those paths with <code>$PYCIRCUIT_ROOT/</code> instead.</p>"},{"location":"bringup/contracts/pyc_artifact_contract/#reproducibility-rules","title":"Reproducibility rules","text":"<ul> <li>Generated artifacts copied/staged into <code>linxisa</code> must come from scripts, not manual edits.</li> <li>Every bring-up gate must record the command used and artifact origin.</li> <li>If generator versions change, note the version/commit in gate notes.</li> </ul>"},{"location":"bringup/contracts/trace_schema/","title":"Trace Schema Contract","text":"<p>Version: <code>1.0</code> (release-strict baseline)</p> <p>All differential validation paths must emit a common architectural trace schema.</p>"},{"location":"bringup/contracts/trace_schema/#version-compatibility-policy","title":"Version compatibility policy","text":"<ul> <li>Schema version format is <code>MAJOR.MINOR</code>.</li> <li><code>MAJOR</code> mismatch is not allowed and must fail-fast.</li> <li><code>MINOR</code> is forward-compatible within the same <code>MAJOR</code>:</li> <li>consumer <code>X.Y</code> accepts producer <code>X.Z</code> when <code>Z &gt;= Y</code>;</li> <li>producer <code>X.Z</code> with <code>Z &lt; Y</code> must be rejected.</li> <li>Producers may emit an explicit per-row <code>schema_version</code>; if omitted, gate tooling   must use profile default (<code>1.0</code> for strict v0.3).</li> </ul>"},{"location":"bringup/contracts/trace_schema/#mandatory-fields-per-commitevent","title":"Mandatory fields per commit/event","text":"<p>Scalar/base required fields:</p> <ul> <li><code>cycle</code></li> <li><code>pc</code></li> <li><code>insn</code></li> <li><code>wb_valid</code></li> <li><code>wb_rd</code></li> <li><code>wb_data</code></li> <li><code>mem_valid</code></li> <li><code>mem_addr</code></li> <li><code>mem_wdata</code></li> <li><code>mem_rdata</code></li> <li><code>mem_size</code></li> <li><code>trap_valid</code></li> <li><code>trap_cause</code></li> <li><code>next_pc</code></li> </ul> <p>Extended vector/tile fields (when vector/tile subsets are under test):</p> <ul> <li><code>block_kind</code> (<code>scalar|vpar|vseq|tma|cube|tepl|call|ret|sys</code>)</li> <li><code>lane_id</code> (for lane-scoped vector commits)</li> <li><code>tile_meta</code> (descriptor summary for tile issue/commit)</li> <li><code>tile_ref_src</code> / <code>tile_ref_dst</code> (relative reference tokens)</li> </ul> <p>Validation policy:</p> <ul> <li><code>block_kind in {vpar,vseq}</code> requires vector fields (<code>lane_id</code>).</li> <li><code>block_kind in {tma,cube,tepl}</code> requires tile fields (<code>tile_meta</code>, tile refs).</li> <li>Commit ordering must be non-decreasing in <code>cycle</code> within one trace stream.</li> </ul>"},{"location":"bringup/contracts/trace_schema/#producers-required-to-conform","title":"Producers required to conform","text":"<ul> <li>QEMU reference execution</li> <li>pyCircuit C++ cycle model</li> <li>RTL simulation (Icarus/Verilator/VCS)</li> <li>FPGA reduced trace logger</li> </ul>"},{"location":"bringup/contracts/trace_schema/#comparison-rules","title":"Comparison rules","text":"<ul> <li>Compare traces in commit order using identical program image and boot PC.</li> <li>First mismatch is the triage anchor; do not skip ahead.</li> <li>If a field is unsupported in a path, mark it explicitly and treat as out-of-scope for that gate.</li> <li>Trace validators must run before semantic diff to catch schema violations early.</li> </ul>"},{"location":"bringup/contracts/trace_schema/#gate-requirement","title":"Gate requirement","text":"<p>No gate can be marked <code>Passed</code> if unresolved schema-level divergence remains within the declared instruction subset.</p>"},{"location":"bringup/gates/qemu_isa_coverage_latest/","title":"ISA vs QEMU Coverage Snapshot","text":"<ul> <li>Generated (UTC): <code>2026-02-25 13:12:48Z</code></li> <li>Spec unique mnemonics: <code>710</code></li> <li>QEMU unique decode mnemonics (non-internal): <code>322</code></li> <li>QEMU mapped spec mnemonics: <code>311</code></li> <li>Coverage: <code>311/710</code> (<code>43.8%</code>)</li> <li>Missing spec mnemonics: <code>399</code></li> <li>Unmapped QEMU mnemonics: <code>0</code></li> </ul>"},{"location":"bringup/gates/qemu_isa_coverage_latest/#coverage-by-prefix","title":"Coverage By Prefix","text":"<ul> <li><code>ACRC</code>: <code>1</code></li> <li><code>ACRE</code>: <code>1</code></li> <li><code>ADD</code>: <code>1</code></li> <li><code>ADDI</code>: <code>1</code></li> <li><code>ADDIW</code>: <code>1</code></li> <li><code>ADDTPC</code>: <code>1</code></li> <li><code>ADDW</code>: <code>1</code></li> <li><code>AND</code>: <code>1</code></li> <li><code>ANDI</code>: <code>1</code></li> <li><code>ANDIW</code>: <code>1</code></li> <li><code>ANDW</code>: <code>1</code></li> <li><code>B</code>: <code>10</code></li> <li><code>BCNT</code>: <code>1</code></li> <li><code>BIC</code>: <code>1</code></li> <li><code>BIS</code>: <code>1</code></li> <li><code>BSTART</code>: <code>14</code></li> <li><code>BSTOP</code>: <code>1</code></li> <li><code>BXS</code>: <code>1</code></li> <li><code>BXU</code>: <code>1</code></li> <li><code>C</code>: <code>27</code></li> <li><code>CLZ</code>: <code>1</code></li> <li><code>CMP</code>: <code>16</code></li> <li><code>CSEL</code>: <code>1</code></li> <li><code>CTZ</code>: <code>1</code></li> <li><code>DIV</code>: <code>1</code></li> <li><code>DIVU</code>: <code>1</code></li> <li><code>DIVUW</code>: <code>1</code></li> <li><code>DIVW</code>: <code>1</code></li> <li><code>EBREAK</code>: <code>1</code></li> <li><code>ERCOV</code>: <code>1</code></li> <li><code>ESAVE</code>: <code>1</code></li> <li><code>FABS</code>: <code>1</code></li> <li><code>FADD</code>: <code>1</code></li> <li><code>FCVT</code>: <code>1</code></li> <li><code>FCVTZ</code>: <code>1</code></li> <li><code>FDIV</code>: <code>1</code></li> <li><code>FENCE</code>: <code>2</code></li> <li><code>FENTRY</code>: <code>1</code></li> <li><code>FEQ</code>: <code>1</code></li> <li><code>FEXIT</code>: <code>1</code></li> <li><code>FGE</code>: <code>1</code></li> <li><code>FLT</code>: <code>1</code></li> <li><code>FMUL</code>: <code>1</code></li> <li><code>FRET</code>: <code>2</code></li> <li><code>FSUB</code>: <code>1</code></li> <li><code>HL</code>: <code>63</code></li> <li><code>LB</code>: <code>2</code></li> <li><code>LBI</code>: <code>1</code></li> <li><code>LBU</code>: <code>2</code></li> <li><code>LBUI</code>: <code>1</code></li> <li><code>LD</code>: <code>3</code></li> <li><code>LDI</code>: <code>1</code></li> <li><code>LH</code>: <code>2</code></li> <li><code>LHI</code>: <code>1</code></li> <li><code>LHU</code>: <code>2</code></li> <li><code>LHUI</code>: <code>1</code></li> <li><code>LR</code>: <code>2</code></li> <li><code>LUI</code>: <code>1</code></li> <li><code>LW</code>: <code>3</code></li> <li><code>LWI</code>: <code>1</code></li> <li><code>LWU</code>: <code>2</code></li> <li><code>LWUI</code>: <code>1</code></li> <li><code>MADD</code>: <code>1</code></li> <li><code>MADDW</code>: <code>1</code></li> <li><code>MAX</code>: <code>1</code></li> <li><code>MAXU</code>: <code>1</code></li> <li><code>MCOPY</code>: <code>1</code></li> <li><code>MIN</code>: <code>1</code></li> <li><code>MINU</code>: <code>1</code></li> <li><code>MSET</code>: <code>1</code></li> <li><code>MUL</code>: <code>1</code></li> <li><code>MULW</code>: <code>1</code></li> <li><code>OR</code>: <code>1</code></li> <li><code>ORI</code>: <code>1</code></li> <li><code>ORIW</code>: <code>1</code></li> <li><code>ORW</code>: <code>1</code></li> <li><code>REM</code>: <code>1</code></li> <li><code>REMU</code>: <code>1</code></li> <li><code>REMUW</code>: <code>1</code></li> <li><code>REMW</code>: <code>1</code></li> <li><code>REV</code>: <code>1</code></li> <li><code>SB</code>: <code>2</code></li> <li><code>SBI</code>: <code>1</code></li> <li><code>SC</code>: <code>2</code></li> <li><code>SCVTF</code>: <code>1</code></li> <li><code>SD</code>: <code>3</code></li> <li><code>SDI</code>: <code>1</code></li> <li><code>SETC</code>: <code>17</code></li> <li><code>SETRET</code>: <code>1</code></li> <li><code>SH</code>: <code>3</code></li> <li><code>SHI</code>: <code>1</code></li> <li><code>SLL</code>: <code>1</code></li> <li><code>SLLI</code>: <code>1</code></li> <li><code>SLLIW</code>: <code>1</code></li> <li><code>SLLW</code>: <code>1</code></li> <li><code>SRA</code>: <code>1</code></li> <li><code>SRAI</code>: <code>1</code></li> <li><code>SRAIW</code>: <code>1</code></li> <li><code>SRAW</code>: <code>1</code></li> <li><code>SRL</code>: <code>1</code></li> <li><code>SRLI</code>: <code>1</code></li> <li><code>SRLIW</code>: <code>1</code></li> <li><code>SRLW</code>: <code>1</code></li> <li><code>SSRGET</code>: <code>1</code></li> <li><code>SSRSET</code>: <code>1</code></li> <li><code>SSRSWAP</code>: <code>1</code></li> <li><code>SUB</code>: <code>1</code></li> <li><code>SUBI</code>: <code>1</code></li> <li><code>SUBIW</code>: <code>1</code></li> <li><code>SUBW</code>: <code>1</code></li> <li><code>SW</code>: <code>3</code></li> <li><code>SWAPD</code>: <code>1</code></li> <li><code>SWAPW</code>: <code>1</code></li> <li><code>SWI</code>: <code>1</code></li> <li><code>TLB</code>: <code>1</code></li> <li><code>UCVTF</code>: <code>1</code></li> <li><code>V</code>: <code>30</code></li> <li><code>XOR</code>: <code>1</code></li> <li><code>XORI</code>: <code>1</code></li> <li><code>XORIW</code>: <code>1</code></li> <li><code>XORW</code>: <code>1</code></li> </ul>"},{"location":"bringup/gates/qemu_isa_coverage_latest/#missing-by-prefix","title":"Missing By Prefix","text":"<ul> <li><code>ASSERT</code>: <code>1</code></li> <li><code>B</code>: <code>7</code></li> <li><code>BC</code>: <code>2</code></li> <li><code>BSE</code>: <code>1</code></li> <li><code>BSTART</code>: <code>6</code></li> <li><code>BWE</code>: <code>1</code></li> <li><code>BWI</code>: <code>1</code></li> <li><code>BWT</code>: <code>1</code></li> <li><code>C</code>: <code>11</code></li> <li><code>DC</code>: <code>8</code></li> <li><code>FCVTA</code>: <code>1</code></li> <li><code>FCVTM</code>: <code>1</code></li> <li><code>FCVTN</code>: <code>1</code></li> <li><code>FCVTP</code>: <code>1</code></li> <li><code>FEQS</code>: <code>1</code></li> <li><code>FEXP</code>: <code>1</code></li> <li><code>FGES</code>: <code>1</code></li> <li><code>FLTS</code>: <code>1</code></li> <li><code>FMADD</code>: <code>1</code></li> <li><code>FMAX</code>: <code>1</code></li> <li><code>FMIN</code>: <code>1</code></li> <li><code>FMSUB</code>: <code>1</code></li> <li><code>FNE</code>: <code>1</code></li> <li><code>FNES</code>: <code>1</code></li> <li><code>FNMADD</code>: <code>1</code></li> <li><code>FNMSUB</code>: <code>1</code></li> <li><code>FRECIP</code>: <code>1</code></li> <li><code>FSQRT</code>: <code>1</code></li> <li><code>HL</code>: <code>131</code></li> <li><code>IC</code>: <code>2</code></li> <li><code>J</code>: <code>1</code></li> <li><code>JR</code>: <code>1</code></li> <li><code>LD</code>: <code>7</code></li> <li><code>LDI</code>: <code>1</code></li> <li><code>LHI</code>: <code>1</code></li> <li><code>LHUI</code>: <code>1</code></li> <li><code>LR</code>: <code>2</code></li> <li><code>LSRGET</code>: <code>1</code></li> <li><code>LW</code>: <code>7</code></li> <li><code>LWI</code>: <code>1</code></li> <li><code>LWUI</code>: <code>1</code></li> <li><code>MULU</code>: <code>1</code></li> <li><code>MULUW</code>: <code>1</code></li> <li><code>PRF</code>: <code>1</code></li> <li><code>PRFI</code>: <code>1</code></li> <li><code>SC</code>: <code>2</code></li> <li><code>SD</code>: <code>8</code></li> <li><code>SDI</code>: <code>1</code></li> <li><code>SHI</code>: <code>1</code></li> <li><code>SW</code>: <code>8</code></li> <li><code>SWAPB</code>: <code>1</code></li> <li><code>SWAPH</code>: <code>1</code></li> <li><code>SWI</code>: <code>1</code></li> <li><code>TLB</code>: <code>3</code></li> <li><code>V</code>: <code>154</code></li> <li><code>XB</code>: <code>1</code></li> </ul>"},{"location":"bringup/gates/qemu_isa_coverage_latest/#unmapped-qemu-mnemonics","title":"Unmapped QEMU Mnemonics","text":"<ul> <li>none</li> </ul>"},{"location":"bringup/gates/qemu_isa_coverage_latest/#missing-spec-mnemonics-first-200","title":"Missing Spec Mnemonics (First 200)","text":"<ul> <li><code>ASSERT</code></li> <li><code>B.EQ</code></li> <li><code>B.GE</code></li> <li><code>B.GEU</code></li> <li><code>B.IOD</code></li> <li><code>B.LT</code></li> <li><code>B.LTU</code></li> <li><code>B.NE</code></li> <li><code>BC.IALL</code></li> <li><code>BC.IVA</code></li> <li><code>BSE</code></li> <li><code>BSTART.FIXP</code></li> <li><code>BSTART.FP</code></li> <li><code>BSTART.STD</code></li> <li><code>BSTART.SYS</code></li> <li><code>BSTART.TEPL</code></li> <li><code>BSTART.TMOV</code></li> <li><code>BWE</code></li> <li><code>BWI</code></li> <li><code>BWT</code></li> <li><code>C.B.DIM</code></li> <li><code>C.BSTART</code></li> <li><code>C.BSTART.FP</code></li> <li><code>C.BSTART.MPAR</code></li> <li><code>C.BSTART.MSEQ</code></li> <li><code>C.BSTART.SYS</code></li> <li><code>C.BSTART.VPAR</code></li> <li><code>C.BSTART.VSEQ</code></li> <li><code>C.EBREAK</code></li> <li><code>C.SETRET</code></li> <li><code>C.SSRGET</code></li> <li><code>DC.CISW</code></li> <li><code>DC.CIVA</code></li> <li><code>DC.CSW</code></li> <li><code>DC.CVA</code></li> <li><code>DC.IALL</code></li> <li><code>DC.ISW</code></li> <li><code>DC.IVA</code></li> <li><code>DC.ZVA</code></li> <li><code>FCVTA</code></li> <li><code>FCVTM</code></li> <li><code>FCVTN</code></li> <li><code>FCVTP</code></li> <li><code>FEQS</code></li> <li><code>FEXP</code></li> <li><code>FGES</code></li> <li><code>FLTS</code></li> <li><code>FMADD</code></li> <li><code>FMAX</code></li> <li><code>FMIN</code></li> <li><code>FMSUB</code></li> <li><code>FNE</code></li> <li><code>FNES</code></li> <li><code>FNMADD</code></li> <li><code>FNMSUB</code></li> <li><code>FRECIP</code></li> <li><code>FSQRT</code></li> <li><code>HL.BFI</code></li> <li><code>HL.BSTART.FP</code></li> <li><code>HL.BSTART.SYS</code></li> <li><code>HL.CASB</code></li> <li><code>HL.CASD</code></li> <li><code>HL.CASH</code></li> <li><code>HL.CASW</code></li> <li><code>HL.CCAT</code></li> <li><code>HL.CCATW</code></li> <li><code>HL.DIV</code></li> <li><code>HL.DIVU</code></li> <li><code>HL.DIVUW</code></li> <li><code>HL.DIVW</code></li> <li><code>HL.LB.PO</code></li> <li><code>HL.LB.PR</code></li> <li><code>HL.LBI</code></li> <li><code>HL.LBI.PO</code></li> <li><code>HL.LBI.PR</code></li> <li><code>HL.LBIP</code></li> <li><code>HL.LBP</code></li> <li><code>HL.LBU.PO</code></li> <li><code>HL.LBU.PR</code></li> <li><code>HL.LBUI</code></li> <li><code>HL.LBUI.PO</code></li> <li><code>HL.LBUI.PR</code></li> <li><code>HL.LBUIP</code></li> <li><code>HL.LBUP</code></li> <li><code>HL.LD.PO</code></li> <li><code>HL.LD.PR</code></li> <li><code>HL.LDI</code></li> <li><code>HL.LDI.U</code></li> <li><code>HL.LDP</code></li> <li><code>HL.LH.PO</code></li> <li><code>HL.LH.PR</code></li> <li><code>HL.LHI</code></li> <li><code>HL.LHI.PO</code></li> <li><code>HL.LHI.PR</code></li> <li><code>HL.LHI.U</code></li> <li><code>HL.LHI.UPO</code></li> <li><code>HL.LHI.UPR</code></li> <li><code>HL.LHIP</code></li> <li><code>HL.LHIP.U</code></li> <li><code>HL.LHP</code></li> <li><code>HL.LHU.PO</code></li> <li><code>HL.LHU.PR</code></li> <li><code>HL.LHUI</code></li> <li><code>HL.LHUI.PO</code></li> <li><code>HL.LHUI.PR</code></li> <li><code>HL.LHUI.U</code></li> <li><code>HL.LHUI.UPO</code></li> <li><code>HL.LHUI.UPR</code></li> <li><code>HL.LHUIP</code></li> <li><code>HL.LHUIP.U</code></li> <li><code>HL.LHUP</code></li> <li><code>HL.LIS</code></li> <li><code>HL.LIU</code></li> <li><code>HL.LW.PO</code></li> <li><code>HL.LW.PR</code></li> <li><code>HL.LWI</code></li> <li><code>HL.LWI.U</code></li> <li><code>HL.LWI.UPR</code></li> <li><code>HL.LWIP.U</code></li> <li><code>HL.LWP</code></li> <li><code>HL.LWU.PO</code></li> <li><code>HL.LWU.PR</code></li> <li><code>HL.LWUI</code></li> <li><code>HL.LWUI.PO</code></li> <li><code>HL.LWUI.U</code></li> <li><code>HL.LWUI.UPO</code></li> <li><code>HL.LWUI.UPR</code></li> <li><code>HL.LWUIP.U</code></li> <li><code>HL.LWUP</code></li> <li><code>HL.MADD</code></li> <li><code>HL.MADDW</code></li> <li><code>HL.MIADD</code></li> <li><code>HL.MISUB</code></li> <li><code>HL.MUL</code></li> <li><code>HL.MULU</code></li> <li><code>HL.PRF</code></li> <li><code>HL.PRF.A</code></li> <li><code>HL.PRFI.U</code></li> <li><code>HL.PRFI.UA</code></li> <li><code>HL.QMT</code></li> <li><code>HL.QPOP</code></li> <li><code>HL.QPUSH</code></li> <li><code>HL.REM</code></li> <li><code>HL.REMU</code></li> <li><code>HL.REMUW</code></li> <li><code>HL.REMW</code></li> <li><code>HL.SB.PO</code></li> <li><code>HL.SB.PR</code></li> <li><code>HL.SBI</code></li> <li><code>HL.SBI.PO</code></li> <li><code>HL.SBI.PR</code></li> <li><code>HL.SBP</code></li> <li><code>HL.SD.PO</code></li> <li><code>HL.SD.PR</code></li> <li><code>HL.SD.UPO</code></li> <li><code>HL.SD.UPR</code></li> <li><code>HL.SDP</code></li> <li><code>HL.SDP.U</code></li> <li><code>HL.SETC.ANDI</code></li> <li><code>HL.SETC.EQI</code></li> <li><code>HL.SETC.GEI</code></li> <li><code>HL.SETC.GEUI</code></li> <li><code>HL.SETC.LTI</code></li> <li><code>HL.SETC.LTUI</code></li> <li><code>HL.SETC.NEI</code></li> <li><code>HL.SETC.ORI</code></li> <li><code>HL.SETRET</code></li> <li><code>HL.SH.PO</code></li> <li><code>HL.SH.PR</code></li> <li><code>HL.SH.UPO</code></li> <li><code>HL.SH.UPR</code></li> <li><code>HL.SHI</code></li> <li><code>HL.SHI.PO</code></li> <li><code>HL.SHI.PR</code></li> <li><code>HL.SHI.U</code></li> <li><code>HL.SHI.UPO</code></li> <li><code>HL.SHI.UPR</code></li> <li><code>HL.SHP</code></li> <li><code>HL.SHP.U</code></li> <li><code>HL.SW.PO</code></li> <li><code>HL.SW.PR</code></li> <li><code>HL.SW.UPO</code></li> <li><code>HL.SW.UPR</code></li> <li><code>HL.SWI</code></li> <li><code>HL.SWI.U</code></li> <li><code>HL.SWI.UPR</code></li> <li><code>HL.SWP</code></li> <li><code>HL.SWP.U</code></li> <li><code>IC.IALL</code></li> <li><code>IC.IVA</code></li> <li><code>J</code></li> <li><code>JR</code></li> <li><code>LD.AND</code></li> <li><code>LD.OR</code></li> <li><code>LD.SMAX</code></li> <li><code>LD.SMIN</code></li> <li><code>LD.UMAX</code></li> <li><code>LD.UMIN</code></li> <li><code>LD.XOR</code></li> <li><code>LDI.U</code></li> </ul>"},{"location":"bringup/gates/qemu_opcode_sync_latest/","title":"QEMU Opcode Sync Audit","text":"<ul> <li>Generated (UTC): <code>2026-02-25 13:12:47Z</code></li> <li>Result: <code>qemu_opcode_meta_sync_ok</code></li> <li>OK: <code>true</code></li> <li>Decode forms (unique): <code>326</code></li> <li>Meta mnemonics (unique, non-internal): <code>322</code></li> </ul>"},{"location":"bringup/gates/qemu_opcode_sync_latest/#drift-summary","title":"Drift Summary","text":"<ul> <li>Decode-only (unexpected): <code>0</code></li> <li>Meta-only (unexpected): <code>0</code></li> <li>Enum/meta op-id mismatch count: <code>0</code></li> </ul>"},{"location":"bringup/phases/","title":"Bring-up Phases","text":"<p>Ordered bring-up phase plans:</p> <ol> <li><code>docs/bringup/phases/01_compiler.md</code></li> <li><code>docs/bringup/phases/02_isa_spec.md</code></li> <li><code>docs/bringup/phases/03_emulator_qemu.md</code></li> <li><code>docs/bringup/phases/04_rtl.md</code></li> <li><code>docs/bringup/phases/05_fpga_zybo_z7.md</code></li> <li><code>docs/bringup/phases/06_linux_on_janus.md</code></li> <li><code>docs/bringup/phases/07_toolchain_glibc.md</code></li> <li><code>docs/bringup/phases/08_toolchain_musl.md</code></li> </ol>"},{"location":"bringup/phases/01_compiler/","title":"Phase 1: Compiler Bring-up","text":"<p>Compiler implementation source of truth is the LLVM submodule:</p> <ul> <li><code>compiler/llvm/</code></li> </ul> <p>In-repo compile validation assets are centralized under AVS:</p> <ul> <li><code>avs/compiler/linx-llvm/tests/</code></li> </ul>"},{"location":"bringup/phases/01_compiler/#current-checkpoint","title":"Current checkpoint","text":"<ul> <li>Host compiler binary commonly used:</li> <li>pinned submodule build: <code>compiler/llvm/build-linxisa-clang/bin/clang</code></li> <li>or an external toolchain (set <code>CLANG=/path/to/clang</code>)</li> <li>Supported bring-up targets: <code>linx64-linx-none-elf</code>, <code>linx32-linx-none-elf</code></li> <li>Compile test suite entrypoint: <code>avs/compiler/linx-llvm/tests/run.sh</code></li> </ul>"},{"location":"bringup/phases/01_compiler/#required-invariants","title":"Required invariants","text":"<ul> <li>Encodings and decode assumptions must match <code>isa/v0.3/linxisa-v0.3.json</code>.</li> <li>Block ISA control-flow invariants must hold.</li> <li>Call header adjacency rule (<code>BSTART CALL</code> + <code>SETRET</code>) must hold.</li> </ul>"},{"location":"bringup/phases/01_compiler/#execution","title":"Execution","text":"<pre><code># Using pinned submodule build\nCLANG=$PWD/compiler/llvm/build-linxisa-clang/bin/clang ./avs/compiler/linx-llvm/tests/run.sh\n\n# Or using an external toolchain\n# CLANG=/path/to/clang ./avs/compiler/linx-llvm/tests/run.sh\n</code></pre>"},{"location":"bringup/phases/02_isa_spec/","title":"Phase 2: ISA Spec Integration","text":"<p>Source of truth: <code>isa/v0.3/**</code> (compiled to <code>isa/v0.3/linxisa-v0.3.json</code>)</p> <p>Supporting context: - <code>isa/README.md</code> - <code>isa/generated/codecs/</code> (generated decode/encode artifacts)</p>"},{"location":"bringup/phases/02_isa_spec/#rule","title":"Rule","text":"<p>Compiler, emulator, and RTL behavior must be derived from, or checked against, the same catalog.</p>"},{"location":"bringup/phases/02_isa_spec/#regeneration","title":"Regeneration","text":"<pre><code>python3 tools/isa/build_golden.py --in isa/v0.3 --out isa/v0.3/linxisa-v0.3.json --pretty\npython3 tools/isa/validate_spec.py --spec isa/v0.3/linxisa-v0.3.json\n</code></pre>"},{"location":"bringup/phases/03_emulator_qemu/","title":"Phase 3: Emulator (QEMU) Bring-up","text":"<p>QEMU implementation source of truth is the submodule:</p> <ul> <li><code>emulator/qemu/</code></li> </ul> <p>Linx patch lineage is maintained in the LinxISA QEMU fork history, then pinned here via submodule SHA.</p>"},{"location":"bringup/phases/03_emulator_qemu/#basic-flow","title":"Basic flow","text":"<ol> <li>Build Linx test object/executable.</li> <li>Run with <code>qemu-system-linx64 -machine virt -kernel &lt;image&gt;</code>.</li> <li>Validate output and exit status through AVS suites.</li> </ol>"},{"location":"bringup/phases/03_emulator_qemu/#test-entrypoints","title":"Test entrypoints","text":"<pre><code># Default suites\n./avs/qemu/run_tests.sh\n\n# Full suites\n./avs/qemu/run_tests.sh --all --timeout 20\n</code></pre>"},{"location":"bringup/phases/03_emulator_qemu/#conventions","title":"Conventions","text":"<ul> <li>UART MMIO base: <code>0x10000000</code></li> <li>Exit MMIO: <code>0x10000004</code></li> <li>Exit value written at <code>0x10000004</code> is used as QEMU process exit code</li> </ul>"},{"location":"bringup/phases/04_rtl/","title":"Phase 4: RTL Bring-up and Verification (Agile pyCircuit)","text":"<p>Primary RTL notes: <code>rtl/README.md</code></p>"},{"location":"bringup/phases/04_rtl/#scope-and-source-of-truth","title":"Scope and source of truth","text":"<ul> <li>Architecture/spec authority: <code>linxisa</code> (<code>isa/v0.3/</code>, <code>isa/v0.3/linxisa-v0.3.json</code>, <code>isa/generated/codecs/</code>).</li> <li>RTL/model generation authority:</li> <li>pinned submodule: <code>tools/pyCircuit</code> (recommended for reproducibility)</li> <li>or an external checkout (set <code>PYCIRCUIT_ROOT=/path/to/pyCircuit</code>).</li> <li>Core targets:</li> <li>Linx CPU first</li> <li>Janus Core second</li> </ul> <p>The Linux end goal is handled in later phases (<code>05_fpga_zybo_z7.md</code>, <code>06_linux_on_janus.md</code>), but this phase must produce stable and diffable models/RTL as prerequisites.</p>"},{"location":"bringup/phases/04_rtl/#contracts-mandatory-links","title":"Contracts (mandatory links)","text":"<ul> <li>Artifact contract: <code>docs/bringup/contracts/pyc_artifact_contract.md</code></li> <li>Trace contract: <code>docs/bringup/contracts/trace_schema.md</code></li> <li>FPGA platform defaults (for downstream compatibility): <code>docs/bringup/contracts/fpga_platform_contract.md</code></li> </ul>"},{"location":"bringup/phases/04_rtl/#required-architecture-alignment","title":"Required architecture alignment","text":"<ul> <li>Control-flow targets must land on block start markers.</li> <li>Block boundaries must commit at <code>BSTOP</code> or next block start.</li> <li><code>SETC.*</code> must execute inside a block and feed commit-time control-flow.</li> <li>Template blocks (<code>FENTRY</code>/<code>FEXIT</code>/<code>FRET.*</code>) are standalone blocks.</li> </ul>"},{"location":"bringup/phases/04_rtl/#workstream-a-linx-cpu-agile-loop","title":"Workstream A: Linx CPU agile loop","text":""},{"location":"bringup/phases/04_rtl/#entry-criteria","title":"Entry criteria","text":"<ul> <li>Compiler and QEMU regressions are green in <code>linxisa</code>.</li> <li><code>pyCircuit</code> toolchain builds (<code>scripts/pyc build</code>) and can regenerate outputs (<code>scripts/pyc regen</code>).</li> </ul>"},{"location":"bringup/phases/04_rtl/#implementation-loop","title":"Implementation loop","text":"<p>One sprint = one feature slice (instruction/CSR/exception/pipeline rule):</p> <ol> <li>Implement/update pyCircuit source in:</li> <li><code>tools/pyCircuit/examples/linx_cpu_pyc/</code> (or <code>$PYCIRCUIT_ROOT/examples/linx_cpu_pyc/</code>)</li> <li>Regenerate C++ and Verilog artifacts via canonical scripts.</li> <li>Run C++ and RTL simulations on identical program vectors.</li> <li>Diff against QEMU using the trace contract.</li> </ol>"},{"location":"bringup/phases/04_rtl/#canonical-runners","title":"Canonical runners","text":"<ul> <li><code>bash tools/pyCircuit/tools/run_linx_cpu_pyc_cpp.sh</code></li> <li><code>python3 tools/pyCircuit/tools/pyc_flow.py verilog-sim linx_cpu_pyc --tool verilator</code></li> </ul> <p>(If using an external checkout, prefix those paths with <code>$PYCIRCUIT_ROOT/</code>.)</p>"},{"location":"bringup/phases/04_rtl/#exit-criteria","title":"Exit criteria","text":"<ul> <li>Smoke suite passes in both C++ and RTL simulation.</li> <li>No unresolved divergence against QEMU in supported instruction subsets.</li> <li>Artifacts are reproducible and script-generated (no manual edits).</li> </ul>"},{"location":"bringup/phases/04_rtl/#workstream-b-janus-core-stabilization","title":"Workstream B: Janus Core stabilization","text":""},{"location":"bringup/phases/04_rtl/#entry-criteria_1","title":"Entry criteria","text":"<ul> <li>Workstream A exit criteria complete.</li> <li>Janus generated artifacts can be refreshed from source in <code>tools/pyCircuit/janus</code> (or <code>$PYCIRCUIT_ROOT/janus</code>).</li> </ul>"},{"location":"bringup/phases/04_rtl/#canonical-runners_1","title":"Canonical runners","text":"<ul> <li><code>bash tools/pyCircuit/janus/tools/run_janus_bcc_ooo_pyc_cpp.sh</code></li> <li><code>bash tools/pyCircuit/janus/tools/run_janus_bcc_ooo_pyc_sv.sh</code></li> <li><code>bash tools/pyCircuit/janus/tools/run_janus_bcc_ooo_pyc_verilator.sh</code></li> <li><code>bash tools/pyCircuit/janus/tools/run_janus_benchmarks.sh</code></li> </ul> <p>(If using an external checkout, prefix those paths with <code>$PYCIRCUIT_ROOT/</code>.)</p>"},{"location":"bringup/phases/04_rtl/#validation","title":"Validation","text":"<ul> <li>Reuse identical vectors where Linx and Janus ISA behavior overlaps.</li> <li>Add Janus-specific difftest gates against QEMU for supported subsets.</li> <li>Keep unsupported features explicitly marked as out-of-scope for current gate.</li> </ul>"},{"location":"bringup/phases/04_rtl/#exit-criteria_1","title":"Exit criteria","text":"<ul> <li>Janus C++ and Verilog simulations pass defined smoke programs.</li> <li>Benchmark scripts run and produce consistent architectural outcomes.</li> <li>Remaining deltas are documented with owners and blockers.</li> </ul>"},{"location":"bringup/phases/04_rtl/#artifact-ingestion-into-linxisa","title":"Artifact ingestion into <code>linxisa</code>","text":"<p><code>linxisa</code> stores planning, contracts, and validation outcomes. When needed, stage generated integration collateral into:</p> <ul> <li><code>rtl/</code> for integration wrappers or snapshots</li> <li><code>models/</code> for model wrappers and trace adapters</li> <li><code>tools/</code> for reproducible import/check scripts</li> </ul> <p>Direct authoring remains in pyCircuit (pinned <code>tools/pyCircuit</code> or external <code>$PYCIRCUIT_ROOT</code>); copied artifacts in <code>linxisa</code> must be script-derived.</p>"},{"location":"bringup/phases/05_fpga_zybo_z7/","title":"Phase 5: FPGA Platform Bring-up (Xilinx ZYBO Z7-20)","text":"<p>Target board: Digilent ZYBO Z7-20 (Zynq-7000)</p>"},{"location":"bringup/phases/05_fpga_zybo_z7/#objective","title":"Objective","text":"<p>Bring Linx CPU first, then Janus Core, onto a stable Zynq PS/PL platform using PS DDR + AXI + PL core integration.</p>"},{"location":"bringup/phases/05_fpga_zybo_z7/#platform-baseline","title":"Platform baseline","text":"<ul> <li>SoC integration path: PS DDR + AXI + PL core</li> <li>Core is instantiated in PL.</li> <li>Linux/test images and staging buffers reside in PS DDR.</li> <li>UART and pass/fail MMIO behavior must remain compatible with   <code>docs/bringup/contracts/fpga_platform_contract.md</code>.</li> </ul>"},{"location":"bringup/phases/05_fpga_zybo_z7/#hardware-architecture-assumptions","title":"Hardware architecture assumptions","text":"<ul> <li>Deterministic reset sequencing across PS and PL.</li> <li>Single bring-up clock domain first; multi-clock extensions are staged later.</li> <li>UART console available as primary bring-up visibility channel.</li> <li>AXI master bridge in PL for DDR access.</li> </ul>"},{"location":"bringup/phases/05_fpga_zybo_z7/#bring-up-ladder","title":"Bring-up ladder","text":"<ol> <li>Minimal Linx PL wrapper:</li> <li>core + BRAM/bootstrap path + UART + timer + AXI to PS DDR</li> <li>Board integration:</li> <li>clock/reset wiring, constraints, and reproducible project build</li> <li>Hardware smoke tests:</li> <li>ROM/DDR payload execution with UART pass/fail protocol</li> <li>Janus port:</li> <li>same wrapper pattern and smoke protocol on Janus Core</li> </ol>"},{"location":"bringup/phases/05_fpga_zybo_z7/#required-smoke-scenarios","title":"Required smoke scenarios","text":"<ul> <li>UART hello and deterministic boot log</li> <li>Memory write/readback sanity</li> <li>Branch/call control-flow sanity</li> <li>MMIO pass/fail register writes</li> </ul>"},{"location":"bringup/phases/05_fpga_zybo_z7/#exit-criteria","title":"Exit criteria","text":"<ul> <li>Linx and Janus both run smoke payloads on ZYBO Z7-20.</li> <li>Results are reproducible across repeated power cycles.</li> <li>Failures are triaged using the same trace/event conventions as simulation.</li> </ul>"},{"location":"bringup/phases/06_linux_on_janus/","title":"Phase 6: Linux Bring-up on FPGA (Janus End Goal)","text":"<p>Final goal: Linux + BusyBox shell on Janus Core running on ZYBO Z7-20 over UART.</p>"},{"location":"bringup/phases/06_linux_on_janus/#objective","title":"Objective","text":"<p>Use staged Linux bring-up:</p> <ol> <li>Linx on FPGA (NOMMU milestone)</li> <li>Janus on FPGA (NOMMU milestone)</li> <li>Janus on FPGA (MMU Linux milestone, final)</li> </ol>"},{"location":"bringup/phases/06_linux_on_janus/#stage-d1-linx-nommu-linux","title":"Stage D1: Linx NOMMU Linux","text":""},{"location":"bringup/phases/06_linux_on_janus/#entry-criteria","title":"Entry criteria","text":"<ul> <li>Phase 5 Linx FPGA smoke tests pass.</li> <li>Kernel, rootfs/initramfs, and boot image flow are reproducible.</li> </ul>"},{"location":"bringup/phases/06_linux_on_janus/#acceptance","title":"Acceptance","text":"<ul> <li>Kernel reaches BusyBox shell on UART.</li> <li>Smoke commands pass (at minimum): <code>uname -a</code> and memory/cpuinfo sanity.</li> </ul>"},{"location":"bringup/phases/06_linux_on_janus/#stage-d2-janus-nommu-linux","title":"Stage D2: Janus NOMMU Linux","text":""},{"location":"bringup/phases/06_linux_on_janus/#entry-criteria_1","title":"Entry criteria","text":"<ul> <li>D1 complete and reproducible.</li> <li>Janus FPGA smoke tests pass.</li> </ul>"},{"location":"bringup/phases/06_linux_on_janus/#acceptance_1","title":"Acceptance","text":"<ul> <li>Janus reaches BusyBox shell on UART with the same smoke commands.</li> <li>Boot path and payload generation are scriptable and repeatable.</li> </ul>"},{"location":"bringup/phases/06_linux_on_janus/#stage-d3-janus-mmu-linux-final","title":"Stage D3: Janus MMU Linux (final)","text":""},{"location":"bringup/phases/06_linux_on_janus/#entry-criteria_2","title":"Entry criteria","text":"<ul> <li>D2 complete.</li> <li>MMU/TLB/page-walk implementation and exception behavior meet architecture requirements.</li> </ul>"},{"location":"bringup/phases/06_linux_on_janus/#acceptance-final-gate","title":"Acceptance (final gate)","text":"<ul> <li>Full MMU Linux boots on Janus to BusyBox shell.</li> <li>Boot is stable across repeated runs/power cycles.</li> <li>Known unsupported features are tracked explicitly with owners.</li> </ul>"},{"location":"bringup/phases/06_linux_on_janus/#regression-requirements","title":"Regression requirements","text":"<ul> <li>Keep a minimal Linux boot regression script and log capture process.</li> <li>Store gate results and blockers in <code>docs/bringup/PROGRESS.md</code> (D1/D2/D3 rows).</li> </ul>"},{"location":"bringup/phases/07_toolchain_glibc/","title":"Phase 7: Toolchain/glibc Bring-up","text":"<p>Canonical source repository:</p> <ul> <li><code>lib/glibc</code> (<code>git@github.com:LinxISA/glibc.git</code>)</li> </ul>"},{"location":"bringup/phases/07_toolchain_glibc/#objective","title":"Objective","text":"<p>Track and validate Linx glibc bring-up for <code>linx64-unknown-linux-gnu</code> in the forked glibc repository.</p>"},{"location":"bringup/phases/07_toolchain_glibc/#role-in-the-bring-up-sequence","title":"Role in the bring-up sequence","text":"<ul> <li>This phase closes Linux userspace toolchain blockers after compiler/emulator/kernel basics.</li> <li>It is support work for phases 4-6 and does not replace RTL/Linux validation gates.</li> </ul>"},{"location":"bringup/phases/07_toolchain_glibc/#workflow","title":"Workflow","text":"<p>From the <code>lib/glibc</code> submodule:</p> <pre><code>cd lib/glibc\nbash tools/linx/build_linx64_glibc.sh\nbash tools/linx/build_linx64_glibc_g1b.sh\n</code></pre> <p>Artifacts and logs:</p> <ul> <li>Default logs: <code>out/libc/glibc/logs/02-configure.log</code>, <code>out/libc/glibc/logs/03-make.log</code>, <code>out/libc/glibc/logs/summary.txt</code>.</li> <li><code>G1b</code> summary: <code>out/libc/glibc/logs/g1b-summary.txt</code> (explicit <code>status</code> + <code>classification</code>).</li> <li><code>G1a</code> gate proves <code>configure</code> + <code>csu/subdir_lib</code> and produces startup objects (<code>crt*.o</code>).</li> <li><code>G1b</code> tracks shared <code>libc.so</code> build status and blocker signature if blocked.</li> </ul>"},{"location":"bringup/phases/07_toolchain_glibc/#current-gates","title":"Current gates","text":"<ul> <li><code>G1a</code>: configure + <code>csu/subdir_lib</code> + startup object production (<code>crt1.o</code>).</li> <li><code>G1b</code>: full shared <code>libc.so</code> build proof.</li> </ul>"},{"location":"bringup/phases/07_toolchain_glibc/#exit-criteria","title":"Exit criteria","text":"<ul> <li><code>G1a</code> passes on the reference bring-up host/toolchain.</li> <li><code>G1b</code> is measured by <code>build_linx64_glibc_g1b.sh</code> and status is tracked in <code>docs/bringup/libc_status.md</code>.</li> <li>Toolchain/libc no longer blocks Linux shell/userland gates.</li> <li>Remaining issues are tracked explicitly in <code>docs/bringup/libc_status.md</code>.</li> </ul>"},{"location":"bringup/phases/08_toolchain_musl/","title":"Phase 8: Toolchain/musl Bring-up","text":"<p>Canonical source repository:</p> <ul> <li><code>lib/musl</code> (<code>git@github.com:LinxISA/musl.git</code>)</li> </ul>"},{"location":"bringup/phases/08_toolchain_musl/#objective","title":"Objective","text":"<p>Bring up a reproducible Linx musl path for:</p> <ul> <li><code>linx64-unknown-linux-musl</code> (<code>M1/M2/M3</code>)</li> <li>Linux initramfs runtime smoke with a real C program using <code>malloc/free/printf</code> (<code>R1/R2</code>)</li> </ul>"},{"location":"bringup/phases/08_toolchain_musl/#entry-points","title":"Entry points","text":"<ul> <li>musl build entrypoint:</li> <li><code>lib/musl/tools/linx/build_linx64_musl.sh</code></li> <li>runtime harness:</li> <li><code>avs/qemu/run_musl_smoke.py</code></li> <li>runtime sample program:</li> <li><code>avs/qemu/tests/linux_musl_malloc_printf.c</code></li> </ul>"},{"location":"bringup/phases/08_toolchain_musl/#default-artifact-layout","title":"Default artifact layout","text":"<ul> <li>musl build/install/logs:</li> <li><code>out/libc/musl/build</code></li> <li><code>out/libc/musl/install</code></li> <li><code>out/libc/musl/logs</code></li> <li>smoke outputs:</li> <li><code>avs/qemu/out/musl-smoke/initramfs.cpio</code></li> <li><code>avs/qemu/out/musl-smoke/musl_smoke</code></li> <li><code>avs/qemu/out/musl-smoke/qemu.log</code></li> <li><code>avs/qemu/out/musl-smoke/summary.json</code></li> </ul>"},{"location":"bringup/phases/08_toolchain_musl/#modes","title":"Modes","text":"<ul> <li><code>phase-b</code>:</li> <li>strict mode (<code>LINX_MUSL_MODE=phase-b</code>)</li> <li>no temporary excludes allowed</li> <li><code>phase-a</code>:</li> <li>optional compatibility mode for temporary exclusions via <code>LINX_MUSL_EXTRA_EXCLUDES</code></li> <li>records active excludes and crash signature in <code>out/libc/musl/logs/phase-a-exclusions.md</code></li> </ul>"},{"location":"bringup/phases/08_toolchain_musl/#commands","title":"Commands","text":"<p>Build musl (<code>M1/M2/M3</code>):</p> <pre><code>cd lib/musl\nMODE=phase-b ./tools/linx/build_linx64_musl.sh\n</code></pre> <p>Run end-to-end smoke (<code>R1/R2</code>):</p> <pre><code>cd .\npython3 avs/qemu/run_musl_smoke.py --mode phase-b\n</code></pre>"},{"location":"bringup/phases/08_toolchain_musl/#current-status-2026-02-16","title":"Current status (2026-02-16)","text":"<ul> <li><code>M1</code>: pass.</li> <li><code>M2</code>: pass in <code>phase-b</code> (strict, no temporary excludes).</li> <li><code>M3</code>: pass in <code>phase-b</code> (shared <code>lib/libc.so</code> produced).</li> <li><code>arch/linx64</code> atomics: <code>a_cas</code>/<code>a_cas_p</code> now use a <code>swapw</code>-backed process-global lock (non-atomic load/store CAS removed).</li> <li><code>R1</code>: pass (sample compiles/links statically with musl sysroot, no extra harness fallback objects).</li> <li><code>R2</code>: pass (<code>MUSL_SMOKE_START</code> and <code>MUSL_SMOKE_PASS</code> observed in <code>avs/qemu/out/musl-smoke/qemu.log</code>).</li> <li>Linux no-libc initramfs baselines (<code>smoke.py</code> / <code>full_boot.py</code>): pass with default QEMU path selection.</li> <li>signal applets currently emit fallback <code>sigill: ok</code> / <code>sigsegv: ok</code> markers while signal-return paths are being hardened.</li> </ul>"},{"location":"bringup/phases/08_toolchain_musl/#baseline-repro-pointers","title":"Baseline repro pointers","text":"<ul> <li>baseline freeze:</li> <li><code>out/libc/musl/logs/baseline.md</code></li> <li>latest Linux userspace boot results:</li> <li><code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/smoke.py</code></li> <li><code>python3 ${LINUX_ROOT}/tools/linxisa/initramfs/full_boot.py</code></li> </ul>"},{"location":"bringup/phases/08_toolchain_musl/#exit-criteria","title":"Exit criteria","text":"<ul> <li><code>M1/M2</code> pass in strict mode (<code>phase-b</code>) with no temporary excludes.</li> <li><code>M3</code> passes in <code>phase-b</code> (<code>out/libc/musl/logs/phase-b-summary.txt</code> shows <code>m3=pass</code>).</li> <li>runtime sentinels are observed under QEMU:</li> <li><code>MUSL_SMOKE_START</code></li> <li><code>MUSL_SMOKE_PASS</code></li> </ul>"},{"location":"bringup/plan/arch/","title":"LinxISA v0.3 \u2014 Architecture Features &amp; Constraints Checklist (Bring-up)","text":"<p>This document is a bring-up checklist for the architectural features and hard constraints that implementations (LLVM/QEMU/RTL/Linux/libc) must satisfy for LinxISA v0.3.</p> <p>It is intended to be precise and test-aligned. The authoritative contract is <code>docs/architecture/v0.3-architecture-contract.md</code>, and the normative conformance gate is <code>check26</code> (<code>docs/bringup/check26_contract.yaml</code>).</p>"},{"location":"bringup/plan/arch/#scope-canonical-inputs","title":"Scope / Canonical Inputs","text":"<ul> <li>ISA profile: v0.3 only</li> <li>Canonical compiled catalog: <code>isa/v0.3/linxisa-v0.3.json</code></li> <li>Canonical \u201cgolden\u201d sources: <code>isa/v0.3/</code></li> <li>Manual chapters referenced by the check26 contract:</li> <li><code>docs/architecture/isa-manual/src/chapters/02_programming_model.adoc</code></li> <li><code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code></li> <li><code>docs/architecture/isa-manual/src/chapters/08_memory_operations.adoc</code></li> <li><code>docs/architecture/isa-manual/src/chapters/09_system_and_privilege.adoc</code></li> </ul>"},{"location":"bringup/plan/arch/#how-to-use-this","title":"How to Use This","text":"<ul> <li>Treat each checkbox as a must-hold invariant for any bring-up milestone claiming \u201cv0.3 architectural compliance\u201d.</li> <li>For each item, record:</li> <li>Evidence (test name + log path, waveform, trace, or diff)</li> <li>Owner (domain / person)</li> <li>Status (pass/fail/waived + justification)</li> </ul>"},{"location":"bringup/plan/arch/#a-isa-model-block-structured-execution-non-negotiable","title":"A. ISA Model: Block-Structured Execution (Non-Negotiable)","text":"<ul> <li>[ ] Block-structured ISA: execution is fundamentally block-based. Blocks are initiated and committed via block start/stop markers.</li> <li>Notes:<ul> <li><code>BSTART.*</code> / <code>BSTOP</code> are treated as markers for block init/commit (not \u201cnormal\u201d in-block payload instructions).</li> <li>The contract statement \u201cno architectural instructions outside blocks\u201d is interpreted here as: there must be no instructions that modify architectural state outside block execution (boundary markers/descriptors are allowed to exist as a control/packaging mechanism).</li> </ul> </li> <li>[ ] Two-layer architectural state model exists and is respected:</li> <li>[ ] GSTATE (first-layer, global architectural state)</li> <li>[ ] BSTATE (second-layer, per-block local architectural state)</li> <li>[ ] All computation is in blocks:</li> <li>[ ] There are no architectural state-modifying payload instructions outside block execution.</li> <li>[ ] Empty blocks are legal. For bring-up, treat the following as valid \u201cempty block\u201d scenarios (i.e., no architecturally meaningful payload work beyond boundary/control mechanics):</li> <li>[ ] Coupled form with header descriptors only and no body payload ops.</li> <li>[ ] Coupled form where the block end is the implicit boundary at the next block start marker (no explicit <code>BSTOP</code>).</li> <li>[ ] Decoupled form using <code>B.TEXT</code> where the referenced body is empty.</li> <li>[ ] Template marker blocks (<code>FENTRY</code>/<code>FEXIT</code>/<code>FRET.*</code>) with no additional payload.</li> <li>[ ] Blocks containing only boundary-event instructions (e.g. <code>ACRC</code>, <code>EBREAK</code>) and no other payload.</li> <li>[ ] Vector blocks with <code>DIM</code> implying zero iterations (where permitted by the profile/spec).</li> <li>[ ] Commit-time control-flow visibility:</li> <li>[ ] Block computes its next target during execution.</li> <li>[ ] Architectural PC is updated at block commit.</li> <li>[ ] Boundary-only branch target safety / CFI:</li> <li>[ ] Control-flow targets must land on legal block boundaries.</li> <li>[ ] Any architectural control-flow transfer to a non-boundary (e.g. mid-block / <code>BodyTPC</code>) is illegal and MUST raise a dedicated control-flow-integrity exception: <code>E_BLOCK(EC_CFI)</code>.<ul> <li>Bring-up cause encoding: <code>EC_CFI=0x1</code> in <code>E_BLOCK</code>, with <code>EC_CFI_KIND</code> in <code>TRAPNO.CAUSE[3:0]</code> (see System/Privilege chapter for the normative mapping).</li> <li>Bring-up reporting requirement: <code>TRAPARG0</code> = source PC/TPC of the control-flow instruction (or boundary marker that triggered the violation); <code>ECSTATE.BI=0</code>.</li> </ul> </li> </ul>"},{"location":"bringup/plan/arch/#b-architectural-state-gstate-composition","title":"B. Architectural State: GSTATE Composition","text":"<ul> <li>[ ] 24 GPRs are architecturally exposed in the global layer.</li> <li>[ ] 32 tile registers are architecturally exposed.</li> <li>[ ] SSR state (system register model) exists and is integrated into the architectural state.</li> <li>Reference: <code>isa/v0.3/state/system_registers.json</code></li> </ul>"},{"location":"bringup/plan/arch/#c-architectural-state-bstate-composition","title":"C. Architectural State: BSTATE Composition","text":"<ul> <li>[ ] BSTATE is block-type dependent.</li> <li>[ ] Local states for these categories are architecturally defined and consistent:</li> <li>[ ] scalar-local state</li> <li>[ ] vector/tile-local state</li> <li>[ ] template-local state</li> </ul>"},{"location":"bringup/plan/arch/#d-machine-model-bcc-pes-retirement","title":"D. Machine Model: BCC / PEs / Retirement","text":"<ul> <li>[ ] BCC schedules block commands.</li> <li>[ ] Heterogeneous PEs model:</li> <li>[ ] PEs share the first-layer architectural state.</li> <li>[ ] Each PE owns its second-layer local state.</li> <li>[ ] OoO issue, in-order retirement:</li> <li>[ ] Block issue may be out-of-order.</li> <li>[ ] Block retirement/resolve must be in program order via a block reorder buffer (BROB).</li> <li>[ ] Second-layer consume/execute/resolve contract:</li> <li>[ ] PE executes only after receiving a valid block command.</li> <li>[ ] PE returns liveouts/status to BROB for in-order resolve.</li> </ul>"},{"location":"bringup/plan/arch/#e-block-boundary-instruction-set-events","title":"E. Block Boundary Instruction Set &amp; Events","text":"<ul> <li>[ ] Block lifecycle boundaries are implemented and semantically correct:</li> <li>[ ] <code>BSTART.*</code> / <code>C.BSTART.*</code> start a block.</li> <li>[ ] <code>BSTOP</code> / <code>C.BSTOP</code> terminates a block.</li> <li>[ ] Boundary events/instructions are implemented and have correct semantics:</li> <li>[ ] <code>BWE</code> / <code>BWI</code></li> <li>[ ] <code>ACRC</code> / <code>ACRE</code></li> <li>[ ] <code>EBREAK</code></li> </ul>"},{"location":"bringup/plan/arch/#f-header-descriptors-normative","title":"F. Header Descriptors (Normative)","text":"<ul> <li>[ ] Header descriptors are implemented and interpreted normatively:</li> <li>[ ] <code>B.ARG</code></li> <li>[ ] <code>B.ATTR</code></li> <li>[ ] <code>B.IOR</code></li> <li>[ ] <code>B.IOT</code></li> <li>[ ] <code>B.IOD</code> exists only as obsolete compatibility descriptor (do not rely on it as normative).</li> </ul>"},{"location":"bringup/plan/arch/#g-coupled-vs-decoupled-blocks","title":"G. Coupled vs Decoupled Blocks","text":"<ul> <li>[ ] Coupled blocks (header + body) work.</li> <li>[ ] Decoupled blocks work:</li> <li>[ ] Header uses <code>B.TEXT</code> to point to the body.</li> <li>[ ] Header/body execution context separation is architecturally respected.</li> </ul>"},{"location":"bringup/plan/arch/#h-variable-length-interpretation-queues","title":"H. Variable-Length Interpretation / Queues","text":"<ul> <li>[ ] A block can be interpreted as a variable-length macro instruction.</li> <li>[ ] Internal T/U queue behavior follows the architected constrained producer\u2013consumer flow (no illegal reordering/overrun).</li> </ul>"},{"location":"bringup/plan/arch/#i-templates-tepl-saverestore","title":"I. Templates (TEPL + Save/Restore)","text":"<ul> <li>[ ] Template blocks are treated as architected contracts (not \u201cmicro-optimizations\u201d).</li> <li>[ ] Template body generation models are allowed (ROM/FSM/engine), but:</li> <li>[ ] Behavior must remain architecturally equivalent.</li> <li>[ ] Template save/restore contract is implemented:</li> <li>[ ] <code>ESAVE</code> saves second-layer state for recovery.</li> <li>[ ] <code>ERCOV</code> restores second-layer state from saved context.</li> <li>[ ] TEPL extension + FP hint semantics:</li> <li>[ ] <code>BSTART.TEPL</code> provides a generic accelerator block type.</li> <li>[ ] <code>BSTART.FP</code> is hint-only for mixed scalar/FP typing (must not change correctness).</li> </ul>"},{"location":"bringup/plan/arch/#j-vector-tile-execution-semantics","title":"J. Vector / Tile Execution Semantics","text":""},{"location":"bringup/plan/arch/#j1-mseq-mpar","title":"J1. MSEQ / MPAR","text":"<ul> <li>[ ] <code>BSTART.MSEQ</code> semantics:</li> <li>[ ] Vector body expresses one-lane semantics.</li> <li>[ ] <code>DIM</code> controls repeated execution and ordered commit.</li> <li>[ ] <code>BSTART.MPAR</code> semantics:</li> <li>[ ] Lanes execute in parallel.</li> <li>[ ] Commit/resolve semantics differ from MSEQ and match the spec.</li> </ul>"},{"location":"bringup/plan/arch/#j2-vpar-vseq-tile-only-vectors","title":"J2. VPAR / VSEQ (Tile-only vectors)","text":"<ul> <li>[ ] <code>BSTART.VPAR</code> / <code>BSTART.VSEQ</code>:</li> <li>[ ] Do not directly access main memory.</li> <li>[ ] May execute speculatively (within architected constraints).</li> </ul>"},{"location":"bringup/plan/arch/#j3-tile-architectural-bounds","title":"J3. Tile Architectural Bounds","text":"<p>These are hard architectural constraints for v0.3 bring-up (software may rely on them; invalid runtime values must be rejected per the spec / treated as illegal).</p> <ul> <li>[ ] Architectural tile register count is 32.</li> <li>[ ] Tile size bounds (tile size is variable per binding/allocation, selected via tile-size descriptors):</li> <li>[ ] min 512 B</li> <li>[ ] max 4 KiB</li> <li>[ ] Architectural tile capacity is 128 KiB.</li> <li>[ ] Tile renaming is allowed, but must preserve architectural semantics.</li> </ul>"},{"location":"bringup/plan/arch/#j4-clockhand-allocation-invariants-compiler","title":"J4. Clockhand Allocation Invariants (Compiler)","text":"<ul> <li>[ ] Compiler preserves relative tile distance across control-flow joins.</li> <li>[ ] If not provable, compiler must spill/reload (no silent corruption).</li> </ul>"},{"location":"bringup/plan/arch/#k-block-command-packing-dispatch","title":"K. Block-Command Packing / Dispatch","text":"<ul> <li>[ ] Header descriptors pack the block-command fields correctly.</li> <li>[ ] <code>BSTOP</code> dispatches the block command to the selected PE.</li> </ul>"},{"location":"bringup/plan/arch/#l-memory-model-memory-system-constraints","title":"L. Memory Model &amp; Memory-System Constraints","text":"<ul> <li>[ ] Ordering model is architectural TSO (applies to the architectural ordering domain; implementations may be stronger, but software must not depend on stronger-than-TSO behavior).</li> <li>In Linx terms, a memory operation includes: load, store, atomic RMW, or fence.</li> <li>Ordering/visibility primitives to explicitly cover during bring-up:<ul> <li>[ ] Atomic qualifiers: <code>.aq</code> / <code>.rl</code> / <code>.aqrl</code></li> <li>[ ] <code>FENCE.D pred_imm, succ_imm</code></li> <li>[ ] <code>FENCE.I</code></li> </ul> </li> <li>[ ] Vector-memory separation is respected:</li> <li>[ ] Vector PE has no direct main-memory access.</li> <li>[ ] Scalar pipe and TMA perform main-memory accesses.</li> <li>[ ] Shared MMU/TLB model:</li> <li>[ ] Scalar and tile accesses share the MMU/TLB path.</li> <li>[ ] <code>TLOAD</code> / <code>TSTORE</code> faults are restartable (ranged tile faults).</li> <li>[ ] Bridged memory path for <code>MSEQ</code>/<code>MPAR</code>:</li> <li>[ ] Memory flow is bridged through tile/TMA path.</li> <li>[ ] Barriers/fences/atomics constrain conflicts between bridged memory actions (TSO-preserving).</li> </ul>"},{"location":"bringup/plan/arch/#m-tile-alias-mapping-per-family-header-contracts","title":"M. Tile Alias Mapping &amp; Per-Family Header Contracts","text":""},{"location":"bringup/plan/arch/#m1-vector-bridge-loadstore-forms","title":"M1. Vector bridge load/store forms","text":"<ul> <li>[ ] Bridge loads/stores use the correct forms:</li> <li>[ ] <code>load.local</code> / <code>store.local</code></li> <li>[ ] <code>load.brg</code> / <code>store.brg</code></li> </ul>"},{"location":"bringup/plan/arch/#m2-vector-body-argument-namespace-base-registers","title":"M2. Vector body argument namespace &amp; base registers","text":"<ul> <li>[ ] Vector body uses <code>ri0..rin</code> argument namespace.</li> <li>[ ] Vector body uses these base registers consistently:</li> <li>[ ] <code>TA</code> / <code>TB</code> as inputs</li> <li>[ ] <code>TO</code> / <code>TS</code> as output/scratch bases</li> <li>[ ] Vector blocks may mix scalar and vector instructions in the block body for the applicable vector families (MSEQ/MPAR and VSEQ/VPAR).</li> <li>Note: <code>BSTART.TEPL</code> blocks do not have a normal architected block body (template expansion / engine execution), so \u201cmixing in the body\u201d is not applicable there.</li> </ul>"},{"location":"bringup/plan/arch/#m3-tma-tload-tstore-tmov-function-field","title":"M3. TMA / TLOAD / TSTORE / TMOV (Function field)","text":"<ul> <li>[ ] In strict v0.3, <code>BSTART.TMA</code> uses the Function field.</li> <li>[ ] Mappings:</li> <li>[ ] <code>BSTART.TLOAD</code>  -&gt; <code>Function = 0</code></li> <li>[ ] <code>BSTART.TSTORE</code> -&gt; <code>Function = 1</code></li> <li>[ ] <code>BSTART.TMOV</code>   -&gt; <code>Function = 2</code></li> <li>[ ] <code>Function = 3..31</code> is reserved in strict v0.3 and treated as architecturally illegal / UNPREDICTABLE: software must not generate it, and implementations must not assign ad-hoc semantics (do not repurpose).</li> <li>[ ] TMOV destination allocation is queue-push only (no illegal random-access destination semantics).</li> <li>[ ] Header requirements:</li> <li>[ ] <code>BSTART.TLOAD/TSTORE</code> require layout from <code>B.ARG</code>.</li> <li>[ ] Stride/base must come from <code>B.IOR</code>.</li> </ul>"},{"location":"bringup/plan/arch/#m4-cube-matmul-family","title":"M4. CUBE / MATMUL family","text":"<ul> <li>[ ] <code>BSTART.CUBE</code> uses a Function selector and maps these operations:</li> <li>[ ] <code>TMATMUL</code></li> <li>[ ] <code>TMATMUL.ACC</code></li> <li>[ ] <code>ACCCVT</code></li> <li>[ ] <code>TMATMUL</code> / <code>TMATMUL.ACC</code> bind <code>LB0/LB1/LB2</code> as <code>m/n/k</code>.</li> <li>[ ] <code>ACCCVT</code> requires quantization arguments via <code>B.ARG</code> and <code>B.IOR</code>.</li> </ul>"},{"location":"bringup/plan/arch/#m5-tepl-selector-space","title":"M5. TEPL selector space","text":"<ul> <li>[ ] <code>BSTART.TEPL</code> carries the PTO template-op selector <code>TileOp10</code>.</li> <li>[ ] Unassigned <code>TileOp10</code> space is reserved for future extension (do not allocate ad-hoc meanings).</li> <li>[ ] TVEC is represented by <code>BSTART.VPAR</code> / <code>BSTART.VSEQ</code>.</li> </ul>"},{"location":"bringup/plan/arch/#n-privilege-traps-and-restartability-system-model","title":"N. Privilege, Traps, and Restartability (System Model)","text":"<ul> <li>[ ] Privileged state and trap envelopes follow the v0.3 SSR/TRAPNO model.</li> <li>[ ] Trap behavior is consistent across compiler-emitted code, QEMU, and RTL (no \u201cimplementation-defined\u201d divergence).</li> </ul>"},{"location":"bringup/plan/arch/#reference-normative-gates","title":"Reference: Normative Gate(s)","text":"<ul> <li>Run the contract gate:</li> </ul> <pre><code>python3 tools/bringup/check26_contract.py --root .\n</code></pre> <ul> <li>The contract definition is in <code>docs/bringup/check26_contract.yaml</code>.</li> </ul>"},{"location":"bringup/plan/isa_clarifications/","title":"LinxISA v0.3 \u2014 Clarifications &amp; Decisions (Bring-up)","text":"<p>This document summarizes clarifications agreed during bring-up work. It is a non-normative index into the canonical spec and contract docs.</p> <p>Canonical spec sources:</p> <ul> <li>ISA manual (v0.3): <code>docs/architecture/isa-manual/src/linxisa-isa-manual.adoc</code></li> <li>Architecture contract: <code>docs/architecture/v0.3-architecture-contract.md</code></li> <li>Bring-up gates: <code>docs/bringup/check26_contract.yaml</code> and scripts under <code>tools/bringup/</code></li> </ul>"},{"location":"bringup/plan/isa_clarifications/#1-block-boundary-markers-and-outside-blocks","title":"1) Block boundary markers and \u201coutside blocks\u201d","text":"<ul> <li><code>BSTART.*</code> / <code>BSTOP</code> are block boundary markers for block init/commit.</li> <li>\u201cNo architectural instructions outside blocks\u201d is interpreted as:</li> <li>no architectural state-modifying payload instructions outside block execution; boundary markers/descriptors can     appear as packaging/control.</li> </ul> <p>See: - <code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code> - <code>docs/architecture/v0.3-architecture-contract.md</code></p>"},{"location":"bringup/plan/isa_clarifications/#2-cfi-illegal-targets","title":"2) CFI / illegal targets","text":"<ul> <li>Control-flow targets must land on legal block start markers.</li> <li>Architectural control-flow to engine-internal entrypoints (e.g. decoupled body entry, SIMT body entry) is illegal and   reported as <code>E_BLOCK(EC_CFI)</code> with <code>EC_CFI_KIND=CFI_BAD_TARGET</code>.</li> </ul>"},{"location":"bringup/plan/isa_clarifications/#21-e_blockec_cfi-encoding","title":"2.1) <code>E_BLOCK(EC_CFI)</code> encoding","text":"<ul> <li><code>EC_CFI = 0x1</code> within <code>E_BLOCK</code>.</li> <li><code>EC_CFI_KIND</code> is carried in <code>TRAPNO.CAUSE[3:0]</code>:</li> <li><code>0x1</code>: <code>CFI_BAD_TARGET</code></li> <li><code>0x3</code>: <code>CFI_MISSING_NEXT_MARKER</code></li> <li>other values reserved.</li> <li><code>TRAPNO.CAUSE[7:4]</code> reserved and must be 0.</li> </ul>"},{"location":"bringup/plan/isa_clarifications/#22-cfi-reporting","title":"2.2) CFI reporting","text":"<ul> <li><code>TRAPARG0</code> = source PC/TPC of the triggering control-flow instruction (or boundary marker).</li> <li><code>BI=0</code>.</li> <li>CFI is precise.</li> </ul> <p>See: - <code>docs/architecture/isa-manual/src/chapters/09_system_and_privilege.adoc</code> - <code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code> - <code>docs/bringup/plan/arch.md</code></p>"},{"location":"bringup/plan/isa_clarifications/#3-block-format-validation-failures","title":"3) Block-format validation failures","text":""},{"location":"bringup/plan/isa_clarifications/#31-e_blockec_blockfmt-encoding","title":"3.1) <code>E_BLOCK(EC_BLOCKFMT)</code> encoding","text":"<ul> <li><code>EC_BLOCKFMT = 0x2</code> within <code>E_BLOCK</code>.</li> </ul>"},{"location":"bringup/plan/isa_clarifications/#32-missinginvalid-descriptor-reporting","title":"3.2) Missing/invalid descriptor reporting","text":"<ul> <li><code>TRAPARG0[7:0] = MissingDescFamily</code>:</li> <li><code>1=B.DIM</code>, <code>2=B.TEXT</code>, <code>3=B.ARG</code>, <code>4=B.IOR</code>, <code>5=B.IOT/B.IOTI</code></li> <li><code>TRAPARG0[15:8]=MissingDetail</code>:</li> <li><code>0x00</code> missing</li> <li><code>0x01</code> invalid/out-of-range</li> <li><code>0x02</code> illegal combination</li> <li><code>0x03..0xFF</code> op/template-specific</li> </ul> <p>Other rules:</p> <ul> <li>Multiple missing families: report exactly one; priority order:</li> <li><code>B.ARG</code></li> <li><code>B.TEXT</code></li> <li><code>B.IOT/B.IOTI</code></li> <li><code>B.IOR</code></li> <li><code>B.DIM</code></li> <li>Must be detected during header validation before side effects.</li> <li><code>BI=0</code>, precise.</li> <li>Applies to all block headers (scalar + tile/vector).</li> <li>Malformed <code>BSTART.*</code> / <code>BSTOP</code> instruction encodings remain <code>E_INST(EC_ILLEGAL)</code>.</li> </ul> <p>See: - <code>docs/architecture/isa-manual/src/chapters/09_system_and_privilege.adoc</code> - <code>docs/architecture/isa-manual/src/chapters/07_tile_blocks.adoc</code></p>"},{"location":"bringup/plan/isa_clarifications/#4-body-fetch-faults-ec_bfetch","title":"4) Body fetch faults (<code>EC_BFETCH</code>)","text":""},{"location":"bringup/plan/isa_clarifications/#41-e_blockec_bfetch-encoding","title":"4.1) <code>E_BLOCK(EC_BFETCH)</code> encoding","text":"<ul> <li><code>EC_BFETCH = 0x3</code> within <code>E_BLOCK</code>.</li> </ul>"},{"location":"bringup/plan/isa_clarifications/#42-split-policy-mmu-vs-non-mmu","title":"4.2) Split policy (MMU vs non-MMU)","text":"<ul> <li>MMU translation/access faults during body fetch/execute =&gt; <code>E_DATA</code> (trap context indicates <code>BI=1</code> body context).</li> <li>Non-MMU body fetch faults (e.g. misaligned body entry) =&gt; <code>E_BLOCK(EC_BFETCH)</code>.</li> </ul>"},{"location":"bringup/plan/isa_clarifications/#43-reporting","title":"4.3) Reporting","text":"<ul> <li>For <code>E_BLOCK(EC_BFETCH)</code>, <code>TRAPARG0</code> = faulting body-fetch VA.</li> <li><code>BI=1</code>.</li> <li>Non-MMU <code>EC_BFETCH</code> misalignment faults are fatal (non-restartable).</li> </ul>"},{"location":"bringup/plan/isa_clarifications/#44-alignment","title":"4.4) Alignment","text":"<ul> <li>Decoupled <code>BodyTPC</code> (legacy name for body-entry <code>TPC</code>) must be 2-byte aligned.</li> <li>SIMT <code>B.TEXT</code> targets must be 2-byte aligned.</li> </ul> <p>See: - <code>docs/architecture/isa-manual/src/chapters/09_system_and_privilege.adoc</code> - <code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code> - <code>docs/architecture/isa-manual/src/chapters/07_tile_blocks.adoc</code></p>"},{"location":"bringup/plan/isa_clarifications/#5-program-counters-terminology","title":"5) Program counters terminology","text":"<ul> <li><code>TPC</code> is Temporary PC (not Thread PC).</li> <li><code>BodyTPC</code> is legacy/prose naming for body-entry <code>TPC</code>.</li> </ul> <p>See: - <code>docs/architecture/isa-manual/src/chapters/02_programming_model.adoc</code> - <code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code></p>"},{"location":"bringup/plan/isa_clarifications/#6-template-replay-flags-ids","title":"6) Template replay flags / IDs","text":"<ul> <li><code>EBARG_TPLFLAGS</code> bitfields standardized; <code>TPL_PHASE</code> meanings standardized.</li> <li>Marker-template <code>TPL_ID</code> mnemonic enum defined in <code>06_templates.adoc</code>.</li> <li><code>TPL_ID_PRESENT</code> must be 1 for marker templates and TEPL.</li> </ul> <p>See: - <code>docs/architecture/isa-manual/src/chapters/09_system_and_privilege.adoc</code> - <code>docs/architecture/isa-manual/src/chapters/06_templates.adoc</code></p>"},{"location":"bringup/plan/isa_clarifications/#7-simt-bodies-terminators","title":"7) SIMT bodies terminators","text":"<ul> <li>SIMT out-of-line body streams may terminate on <code>BSTOP</code> or <code>BSTART</code>; first terminator wins.</li> <li><code>BSTART</code> terminator is a terminator trigger only, not an in-body successor.</li> </ul> <p>See: - <code>docs/architecture/isa-manual/src/chapters/04_block_isa.adoc</code> - <code>docs/architecture/isa-manual/src/chapters/07_tile_blocks.adoc</code></p>"},{"location":"bringup/plan/isa_clarifications/#8-tilevector-block-chapter","title":"8) Tile/vector block chapter","text":"<p>A new chapter documents per-block mandatory descriptor contracts:</p> <ul> <li><code>07_tile_blocks.adoc</code></li> </ul>"},{"location":"bringup/plan/isa_clarifications/#9-tepl-encoding-maps-and-status","title":"9) TEPL encoding, maps, and status","text":"<ul> <li>Canonical TEPL map is published in manual (<code>04_block_isa.adoc</code>), and additionally mirrored in:</li> <li><code>isa/v0.3/state/engine_ops.json</code> (authoritative semantic catalog seed)</li> <li><code>docs/bringup/tepl_status.yaml</code> (bring-up status; per-op gate list)</li> <li>Gate tooling (manual run for now): <code>tools/bringup/check_tepl_encoding.py</code></li> </ul> <p>Recent changes:</p> <ul> <li><code>TCOLEXPAND</code> moved to <code>0x0C0</code> (legacy <code>0x027</code> non-canonical).</li> <li>Added <code>TROWEXPAND=0x0C1</code>.</li> </ul>"},{"location":"bringup/plan/isa_clarifications/#notes","title":"Notes","text":"<p>This file is updated as decisions land. If anything here conflicts with the canonical manual/contract, the manual/contract wins; please file an issue to reconcile.</p>"},{"location":"bringup/plan/sail_formalization_v0.3/","title":"LinxISA v0.3 \u2014 Sail formalization plan (stepwise)","text":"<p>This document tracks the step-by-step bring-up of the Sail model under <code>isa/sail/</code>.</p> <p>Scope / constraints:</p> <ul> <li>The Sail model is a reference for semantics.</li> <li>Missing semantics must be explicit (no guessing). If a rule is unclear, we either:</li> <li>add a clarification/convention entry, or</li> <li>leave the instruction unimplemented and record the question in the review log.</li> <li>Coverage is tracked mechanically by:</li> <li><code>isa/sail/implemented_mnemonics.txt</code></li> <li><code>isa/sail/coverage.json</code> (generated)</li> </ul> <p>Definition-of-done per mnemonic:</p> <ul> <li>Decode/dispatch reaches an implementation point for the mnemonic (even if decode is partial/feature-gated initially).</li> <li>Execute semantics are implemented (or explicitly <code>unimplemented(\"MNEMONIC\")</code> with a linked review log entry).</li> <li>Manual documentation impact is handled:</li> <li>either already covered by auto-generated ISA manual sections, or</li> <li>requires an explicit normative/non-normative note, captured as a commit in <code>docs/architecture/isa-manual/src/...</code>.</li> </ul> <p>Proposed iteration loop (one PR per small slice):</p> <p>1) Pick a small slice (e.g. 5\u201320 mnemonics in one coherent group). 2) For each mnemonic:    - confirm semantic corner cases (trap cause/arg, sign/zero extend rules, alignment/atomicity, etc.)    - implement Sail execute semantics    - add/extend decode/dispatch support 3) Update <code>isa/sail/implemented_mnemonics.txt</code>. 4) Regenerate and check:    - <code>python3 tools/isa/sail_coverage.py ... --check</code>    - <code>python3 tools/isa/validate_spec.py --profile v0.3</code>    - <code>python3 tools/isa/build_golden.py --profile v0.3 --check</code> 5) Record any reviewer decisions in: <code>docs/bringup/plan/sail_review_log_v0.3.md</code></p> <p>Initial prioritization (can be adjusted):</p> <ul> <li>P0: establish a maintainable decode/dispatch path (ideally generated from <code>isa/v0.3/linxisa-v0.3.json</code>).</li> <li>P1: integer core missing semantics needed for toolchain/QEMU alignment (compare + setc + branches).</li> <li>P2: loads/stores + cache maintenance (and the associated fault/partial-effect rules).</li> <li>P3: atomics.</li> <li>P4: float and vector (after integer/memory base is stable).</li> </ul> <p>Current coverage snapshot:</p> <ul> <li>See <code>isa/sail/coverage.json</code> for the authoritative missing list.</li> </ul>"},{"location":"bringup/plan/sail_review_log_v0.3/","title":"LinxISA v0.3 \u2014 Sail formalization review log","text":"<p>This log captures review decisions and open questions made while implementing the v0.3 Sail model.</p> <p>Format:</p> <ul> <li>Each entry has: date, topic, question, decision, rationale, and follow-ups.</li> <li>Keep it technical and reference canonical sources when possible.</li> </ul>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-24-kickoff","title":"2026-02-24 \u2014 Kickoff","text":"<p>Topic: stepwise Sail formalization for ~670 missing mnemonics (per <code>isa/sail/coverage.json</code>).</p> <p>Decision: - Proceed in small PR slices. - Ask one focused semantic question per slice when ambiguity is encountered.</p> <p>Follow-ups: - Choose the first slice and confirm any corner-case semantics that must be fixed in conventions.</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-setci-immediate-shift-semantics","title":"2026-02-25 \u2014 SETC.*I immediate shift semantics","text":"<p>Topic: <code>SETC.*I</code> forms encode an implicit <code>shamt</code> field but assembly syntax prints only <code>simm/uimm</code>.</p> <p>Question: - How should strict v0.3 interpret the encoded <code>shamt</code> for <code>SETC.*I</code>?</p> <p>Decision (Kevin): - A) Treat it as an immediate left shift: <code>imm = (SignExtend(simm) &lt;&lt; shamt)</code> (or <code>ZeroExtend(uimm) &lt;&lt; shamt</code>).</p> <p>Rationale: - Encoding clearly dedicates bits[11:7] (in 32-bit SETC.*I) to <code>shamt</code>, suggesting a widened immediate encoding scheme.</p> <p>Follow-ups: - Document this convention in <code>isa/v0.3/semantics_conventions.json</code>. - Update auto-generated pseudocode for SETC.*I in the ISA manual generator. - Implement the corresponding Sail semantics.</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-restricted-srcrtype-handling-for-cmpsetc","title":"2026-02-25 \u2014 Restricted SrcRType handling for CMP/SETC","text":"<p>Topic: <code>CMP.{EQ,NE,LT,GE,LTU,GEU}</code> and <code>SETC.{EQ,NE,LT,GE,LTU,GEU}</code> assembly syntax only allows <code>{.sw,.uw}</code>, but encoding still carries a 2-bit <code>SrcRType</code>.</p> <p>Question: - What should strict v0.3 do when <code>SrcRType=11</code> appears for these restricted forms?</p> <p>Decision (Kevin): - Treat <code>SrcRType=11</code> as equivalent to <code>00</code> (no modifier).</p> <p>Rationale: - Keeps strict profile deterministic without introducing extra illegal encodings for legacy streams.</p> <p>Follow-ups: - Record in <code>isa/v0.3/semantics_conventions.json</code> under <code>srcrtype.restricted_forms</code>. - Update Sail semantics for the restricted CMP/SETC forms to sanitize 11\u219200.</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-bru-control-transfer-legality-in-scalar-blocks","title":"2026-02-25 \u2014 BRU control-transfer legality in scalar blocks","text":"<p>Topic: - BRU control-transfer instructions (<code>B.*</code>, <code>J</code>, <code>JR</code>, and related direct control-transfer forms) are not legal payload instructions in coupled scalar blocks. - They are only executed on the vec engine scalar lane; if encountered in a scalar block, strict profile must trap.</p> <p>Decision (Kevin): - Misuse in scalar block raises ILLEGAL_INST: <code>TRAPNUM=4</code>.</p> <p>Open details: - Whether <code>TRAPARG0</code> should be populated (and with which PC) is still TBD.</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-vec-engine-scalar-lane-bru-pc-domain","title":"2026-02-25 \u2014 Vec engine scalar-lane BRU PC domain","text":"<p>Topic: - When BRU control-transfer instructions execute on the vec engine scalar lane, which PC domain do they update?</p> <p>Decision (Kevin): - Update TPC (body-local PC), not the architectural global PC.</p> <p>Follow-ups: - Define the immediate/label target computation relative to TPC (byte vs halfword scaling) for <code>B.*</code>/<code>J</code>/<code>JR</code>.</p> <p>Decision (Kevin): - Base for PC-relative targets is the current instruction TPC. - Immediate offsets are halfword-scaled: <code>target = base + (SignExtend(simm) &lt;&lt; 1)</code>. - <code>JR SrcL, label</code> reads <code>SrcL</code> from the vec engine scalar-lane GPR file (not ClockHands <code>t/u</code> queues). - <code>B.EQ/B.NE/B.LT/B.GE/B.LTU/B.GEU</code> read <code>SrcL/SrcR</code> from the vec engine scalar-lane GPR file. - Signed/unsigned compare uses full 64-bit width (signed for LT/GE, unsigned for LTU/GEU). - Equality compare (EQ/NE) is full 64-bit width. - <code>JR SrcL, label</code> also uses halfword-scaled immediate: <code>target = SrcL + (SignExtend(simm12) &lt;&lt; 1)</code>. - <code>JR</code> does not force 2-byte alignment; odd targets are permitted and are handled by the normal fetch/alignment-fault machinery. - If the resulting <code>TPC</code> is misaligned at fetch/execute time, it is reported as <code>E_BLOCK(EC_BFETCH)</code> (TRAPNUM=5) with <code>TRAPARG0</code> = faulting <code>TPC</code>. - <code>JR</code> encoding includes a <code>SrcZero</code> field; strict v0.3 ignores it (treat as 0). If the computed target ends up at VA=0, subsequent fetch will fault (body-fetch error). - If <code>JR</code> targets an address that is not a valid vec-body fetch location (out-of-body / unmapped / otherwise not fetchable), report as <code>E_BLOCK(EC_BFETCH)</code>. - No explicit architectural body-range boundary is defined; \"fetchable\" is defined operationally (if fetch fails =&gt; <code>EC_BFETCH</code>).</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-bz-bnz-predicate-source","title":"2026-02-25 \u2014 B.Z / B.NZ predicate source","text":"<p>Topic: - <code>B.Z</code>/<code>B.NZ</code> have no source operands; they branch based on a predicate value.</p> <p>Decision (Kevin): - They read the predicate register <code>p</code> (vec engine predicate domain) and test whether it is all-zero vs non-zero:   - <code>B.Z</code> taken iff <code>p == 0</code>   - <code>B.NZ</code> taken iff <code>p != 0</code></p> <p>Notes: - <code>B.Z</code>/<code>B.NZ</code> are vec-engine-only (scalar blocks executing them trap with <code>TRAPNUM=4</code>). - Any mirroring of <code>p</code> into architectural BARG/EBARG is vec-engine/profile-defined; scalar-only components must not assume it.</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-floating-point-minmax-nan-behavior","title":"2026-02-25 \u2014 Floating-point min/max NaN behavior","text":"<p>Topic: - <code>FMAX/FMIN</code> NaN handling semantics.</p> <p>Decision (Kevin): - IEEE/ARM-style <code>maxNum/minNum</code> behavior:   - if exactly one operand is NaN: return the non-NaN operand   - if both operands are NaN: return canonical qNaN   - signed zeros: FMAX returns +0 when both are zeros; FMIN returns -0 iff either operand is -0.</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-csel-srcrtype-handling","title":"2026-02-25 \u2014 CSEL SrcRType handling","text":"<p>Topic: - <code>CSEL</code> assembly syntax allows <code>SrcR&lt;.neg&gt;</code> but encoding includes 2-bit <code>SrcRType</code>.</p> <p>Decision (Kevin): - Treat <code>SrcRType=11</code> as <code>.neg</code>; treat all other values as <code>00</code> (no modifier).</p> <p>Notes: - This mirrors the \"restricted SrcRType\" philosophy used elsewhere: prefer deterministic sanitization over new traps.</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-immediate-materialization-lui-hllui-hllis-hlliu","title":"2026-02-25 \u2014 Immediate materialization (LUI / HL.LUI / HL.LIS / HL.LIU)","text":"<p>Topic: - Define constant materialization semantics for LUI and HL immediate-load forms.</p> <p>Decision: - Follow RTL decode conventions:   - <code>LUI imm20</code> materializes <code>SignExtend(imm20) &lt;&lt; 12</code>.   - <code>HL.LUI imm32</code> materializes <code>SignExtend(imm32)</code> (no <code>&lt;&lt; 12</code>).   - <code>HL.LIS simm32</code> materializes <code>SignExtend(imm32)</code>.   - <code>HL.LIU uimm32</code> materializes <code>ZeroExtend(imm32)</code>.</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-fixup-blocks-unmanaged-fixup","title":"2026-02-25 \u2014 Fixup blocks (unmanaged fixup)","text":"<p>Topic: - Define behavior of unmanaged fixup blocks and how exceptions are routed to <code>fixup_label</code>.</p> <p>Decisions (Kevin): - An unmanaged fixup block is only a <code>.SYS</code> block with an explicit <code>fixup_label</code>:   - <code>BSTART.SYS FALL&lt;, fixup_label</code> - If a synchronous exception occurs in an unmanaged fixup block:   - Write trap envelope registers: <code>TRAPNO/TRAPARG0/ECSTATE</code> (EBARG optional)     - <code>TRAPNO.E = 0</code> (sync) and <code>TRAPNO.ARGV = 1</code>   - Route control-flow to the fixup handler instead of EVBASE, entering it as a new block (try/catch):     - <code>fixup_target = BPC + (SignExtend(fixup_label) &lt;&lt; 1)</code>     - next-block target PC is set to <code>fixup_target</code>   - No privilege/ACR switch occurs (remain in current execution context) - <code>ASSERT</code> failures participate in the same fixup routing when they occur inside an unmanaged fixup block. - <code>ASSERT_FAIL</code> reserves <code>TRAPNUM=52</code>. - <code>ASSERT</code> is only legal in <code>.SYS</code> blocks; elsewhere it traps as <code>TRAPNUM=4 ILLEGAL_INST</code>. - Global exception enable is <code>ECONFIG[3]</code> (when 0: ASSERT is NOP). - For <code>ASSERT_FAIL</code>, <code>TRAPNO.CAUSE = 0</code>.</p> <p>Open questions: - Whether <code>CAUSE</code> is used/required in fixup context beyond <code>TRAPNUM</code>.</p> <p>Decision (Kevin): - <code>TRAPARG0</code> mapping in fixup context:   - For <code>ASSERT_FAIL</code>: <code>TRAPARG0 = faulting PC/TPC</code>   - For other synchronous exceptions: <code>TRAPARG0 = faulting VA</code> (e.g., data/page fault address)</p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-prefetch-prfprfi","title":"2026-02-25 \u2014 Prefetch (PRF/PRFI)","text":"<p>Topic: - Define architectural semantics for prefetch/hint instructions and whether they may fault.</p> <p>Decision (Kevin): - Prefetch is a non-faulting hint: address translation, permission, and alignment errors are suppressed (no trap). - <code>HL.PRF.A</code> / <code>HL.PRFI.UA</code> additionally return the computed effective address:   - <code>Rd = EA</code></p>"},{"location":"bringup/plan/sail_review_log_v0.3/#2026-02-25-divrem-edge-cases-arm-like-semantics","title":"2026-02-25 \u2014 DIV/REM edge cases (ARM-like semantics)","text":"<p>Topic: - Define non-trapping behavior for divide-by-zero and signed overflow for DIV/REM families.</p> <p>Decision (Kevin): - Follow ARM-style behavior (non-trapping, defined results):   - If divisor == 0:     * DIV/DIVU/DIVW/DIVUW =&gt; quotient = 0     * REM/REMU/REMW/REMUW =&gt; remainder = dividend   - If signed overflow (MIN_INT / -1):     * DIV/DIVW =&gt; quotient = MIN_INT     * REM/REMW =&gt; remainder = 0   - Division rounds toward zero; remainder computed as <code>a - q*b</code>. - For W variants, writeback is sign-extend from bit 31* to 64-bit for ALL of DIVW/DIVUW/REMW/REMUW. - For HL DIV/REM two-destination forms: <code>Dst0 = quotient</code>, <code>Dst1 = remainder</code>. - For HL MUL/MULU two-destination forms: <code>Dst0 = low64(full_product)</code>, <code>Dst1 = high64(full_product)</code>. - For HL MADD/MADDW two-destination forms: treat as 128-bit accumulator <code>acc = (SrcL*SrcR + SrcD)</code> (signed multiply/add), then <code>Dst0 = low64(acc)</code>, <code>Dst1 = high64(acc)</code>.</p>"},{"location":"migration/path-map-v0.4.0/","title":"LinxISA Path Migration Map v0.4.0","text":"<p>This map documents the AVS-centric and submodule-first repository tidy.</p>"},{"location":"migration/path-map-v0.4.0/#path-changes","title":"Path Changes","text":"Previous Canonical Path New Canonical Path Notes <code>compiler/linx-llvm/</code> <code>avs/compiler/linx-llvm/</code> compile-only AVS assets moved under AVS <code>tests/qemu/</code> <code>avs/qemu/</code> runtime AVS suites consolidated <code>tests/scratch/</code> <code>avs/scratch/</code> scratch tests consolidated <code>models/pyCircuit</code> <code>tools/pyCircuit</code> submodule moved to tools domain <code>docs/validation/avs/</code> <code>avs/</code> AVS docs now top-level canonical folder <code>toolchain/libc/</code> <code>avs/runtime/freestanding/</code> freestanding support moved under AVS runtime <code>toolchain/pto/include/pto/</code> <code>workloads/pto_kernels/include/</code> PTO headers now come from PTO-Kernel submodule <code>toolchain/llvm/sync_generated_opcodes.sh</code> <code>tools/isa/sync_generated_opcodes.sh</code> LLVM sync helper moved <code>examples/assembly/v0.3/</code> <code>docs/reference/examples/v0.3/</code> sample pack consolidated into docs <code>tools/ctuning/</code> <code>workloads/ctuning/</code> benchmark runner moved under workloads"},{"location":"migration/path-map-v0.4.0/#submodule-changes","title":"Submodule Changes","text":"Path URL <code>compiler/llvm</code> <code>https://github.com/LinxISA/llvm-project.git</code> <code>emulator/qemu</code> <code>https://github.com/LinxISA/qemu.git</code> <code>kernel/linux</code> <code>https://github.com/LinxISA/linux.git</code> <code>rtl/LinxCore</code> <code>https://github.com/LinxISA/LinxCore.git</code> <code>tools/pyCircuit</code> <code>https://github.com/LinxISA/pyCircuit.git</code> <code>lib/glibc</code> <code>https://github.com/LinxISA/glibc.git</code> <code>lib/musl</code> <code>https://github.com/LinxISA/musl.git</code> <code>workloads/pto_kernels</code> <code>https://github.com/LinxISA/PTO-Kernel.git</code>"},{"location":"migration/path-map-v0.4.0/#removed-paths","title":"Removed Paths","text":"<ul> <li><code>emulator/linx-qemu</code></li> <li><code>examples/</code></li> <li><code>models/</code></li> <li><code>toolchain/</code></li> <li><code>tests/</code></li> <li><code>docs/validation/avs/</code></li> <li><code>tools/ctuning/</code></li> </ul>"},{"location":"project/","title":"Project Documentation","text":"<p>Repository-level process, governance, and navigation policies.</p>"},{"location":"project/#contents","title":"Contents","text":"<ul> <li>navigation.md - Canonical path map and forbidden paths</li> <li>repository-flow.md - Development workflow and contribution guide</li> </ul>"},{"location":"project/#navigation-policy","title":"Navigation Policy","text":"<p>This workspace follows a strict navigation contract. See navigation.md for:</p> <ul> <li>Allowed top-level directories</li> <li>Canonical destinations for specific tasks</li> <li>Forbidden/replaced paths</li> <li>Submodule update procedures</li> </ul>"},{"location":"project/#quick-reference","title":"Quick Reference","text":"Task Path Runtime tests <code>avs/qemu/</code> Compile tests <code>avs/compiler/linx-llvm/tests/</code> Freestanding libc <code>avs/runtime/freestanding/</code> Linux libc sources <code>lib/glibc/</code>, <code>lib/musl/</code> PTO kernel headers <code>workloads/pto_kernels/include/</code> Assembly examples <code>docs/reference/examples/v0.3/</code>"},{"location":"project/#ci-validation","title":"CI Validation","text":"<p>Before committing, verify repository layout:</p> <pre><code>bash tools/ci/check_repo_layout.sh\n</code></pre>"},{"location":"project/navigation/","title":"LinxISA Navigation Guide (v0.5)","text":"<p>This is the canonical navigation contract for contributors and agents.</p>"},{"location":"project/navigation/#top-level-map","title":"Top-level map","text":"<ul> <li><code>README.md</code> \u2014 workspace overview</li> <li><code>AGENTS.md</code> \u2014 agent-facing routing and guardrails</li> <li><code>avs/</code> \u2014 architectural verification suite</li> <li><code>compiler/</code> \u2014 upstream LLVM submodule (<code>compiler/llvm</code>)</li> <li><code>emulator/</code> \u2014 upstream QEMU submodule (<code>emulator/qemu</code>)</li> <li><code>kernel/</code> \u2014 upstream Linux submodule (<code>kernel/linux</code>)</li> <li><code>rtl/</code> \u2014 LinxCore submodule (<code>rtl/LinxCore</code>) + rtl notes</li> <li><code>tools/</code> \u2014 generators, regression, pyCircuit submodule</li> <li><code>workloads/</code> \u2014 benchmark runners + generated artifacts + PTO kernel submodule</li> <li><code>isa/</code> \u2014 ISA source of truth and generated catalogs</li> <li><code>docs/</code> \u2014 architecture, bring-up, migration, project references</li> <li><code>lib/</code> \u2014 glibc/musl fork submodules</li> </ul>"},{"location":"project/navigation/#canonical-test-locations","title":"Canonical test locations","text":"<ul> <li>Runtime AVS suites: <code>avs/qemu/</code></li> <li>Compile AVS suites: <code>avs/compiler/linx-llvm/tests/</code></li> <li>AVS matrix/docs: <code>avs/</code></li> </ul>"},{"location":"project/navigation/#canonical-toolchain-support-locations","title":"Canonical toolchain support locations","text":"<ul> <li>Freestanding libc support used by AVS/tests: <code>avs/runtime/freestanding/</code></li> <li>Linux libc source forks: <code>lib/glibc/</code>, <code>lib/musl/</code></li> <li>PTO kernels/tools/headers (submodule): <code>workloads/pto_kernels/</code></li> <li>PTO header include root: <code>workloads/pto_kernels/include/</code></li> <li>LLVM opcode sync helper: <code>tools/isa/sync_generated_opcodes.sh</code></li> </ul>"},{"location":"project/navigation/#benchmark-locations","title":"Benchmark locations","text":"<ul> <li>CoreMark upstream: <code>workloads/coremark/upstream/</code></li> <li>Dhrystone upstream: <code>workloads/dhrystone/upstream/</code></li> <li>PolyBench source cache: <code>workloads/third_party/PolyBenchC/</code></li> <li>ctuning runner: <code>workloads/ctuning/</code></li> </ul>"},{"location":"project/navigation/#removed-forbidden-paths","title":"Removed / forbidden paths","text":"<p>Do not add or revive these paths:</p> <ul> <li><code>compiler/linx-llvm</code></li> <li><code>emulator/linx-qemu</code></li> <li><code>examples/</code></li> <li><code>models/</code></li> <li><code>toolchain/</code></li> <li><code>tests/</code></li> <li><code>docs/validation/avs/</code></li> <li><code>tools/ctuning/</code></li> <li><code>tools/libc/</code></li> <li><code>tools/glibc/</code></li> <li><code>workloads/benchmarks/</code></li> <li><code>workloads/examples/</code></li> <li><code>spec/</code></li> </ul> <p>CI guard: <code>tools/ci/check_repo_layout.sh</code></p>"},{"location":"project/navigation/#submodule-policy","title":"Submodule policy","text":"<p>When implementation repos change:</p> <ol> <li>Merge in the upstream ecosystem repo first.</li> <li>Update submodule SHA in this workspace.</li> <li>Keep <code>.gitmodules</code> URLs aligned to LinxISA org forks/repos.</li> <li>Validate with:</li> </ol> <pre><code>git submodule sync --recursive\ngit submodule update --init --recursive\nbash tools/ci/check_repo_layout.sh\n</code></pre>"},{"location":"project/repository-flow/","title":"LinxISA Repository Flow (v0.4)","text":"<p>The workspace is specification-first and submodule-first.</p>"},{"location":"project/repository-flow/#workspace-bootstrap","title":"Workspace Bootstrap","text":"<pre><code>git submodule sync --recursive\ngit submodule update --init --recursive\n</code></pre> <p>Pinned ecosystem repos:</p> <ul> <li><code>compiler/llvm</code></li> <li><code>emulator/qemu</code></li> <li><code>kernel/linux</code></li> <li><code>rtl/LinxCore</code></li> <li><code>tools/pyCircuit</code></li> <li><code>lib/glibc</code></li> <li><code>lib/musl</code></li> <li><code>workloads/pto_kernels</code></li> </ul>"},{"location":"project/repository-flow/#flow","title":"Flow","text":"<ol> <li>ISA definition in <code>isa/v0.3/</code></li> <li>Compiled catalog in <code>isa/v0.3/linxisa-v0.3.json</code></li> <li>Generated decode assets in <code>isa/generated/codecs/</code></li> <li>Validation in AVS (<code>avs/</code>)</li> <li>Cross-repo alignment through submodule pinning</li> <li>Regression gating with <code>tools/regression/run.sh</code></li> </ol>"},{"location":"reference/","title":"Reference Docs","text":"<p>Reference snippets and examples:</p> <ul> <li><code>docs/reference/examples/v0.3/</code> (see <code>docs/reference/examples/v0.3/index.yaml</code>)</li> <li><code>docs/reference/linxisa-assembly-agent-guide.md</code> (agent guide for Linx block-ISA asm, ABI, unwind, signal, and context-switch patterns)</li> <li><code>docs/reference/linxisa-call-ret-contract.md</code> (normative call/ret, tail-transfer, and fused call-header contract)</li> </ul>"},{"location":"reference/encoding_space_report/","title":"LinxISA Encoding Space Report","text":"<p>Spec: <code>isa/v0.3/linxisa-v0.3.json</code></p>"},{"location":"reference/encoding_space_report/#conflicts-part0-maskmatch-overlaps","title":"Conflicts (part0 mask/match overlaps)","text":"<p>Conflicts are reported at the full instruction length (all parts), not just part0.</p>"},{"location":"reference/encoding_space_report/#parts-16","title":"parts: 16","text":"<ul> <li>none</li> </ul>"},{"location":"reference/encoding_space_report/#parts-32","title":"parts: 32","text":"<ul> <li>none</li> </ul>"},{"location":"reference/encoding_space_report/#parts-48","title":"parts: 48","text":"<ul> <li>none</li> </ul>"},{"location":"reference/encoding_space_report/#parts-32-32","title":"parts: 32 + 32","text":"<ul> <li>none</li> </ul>"},{"location":"reference/encoding_space_report/#prefix-ambiguity-multi-part-prefix-vs-32-bit-single","title":"Prefix Ambiguity (multi-part prefix vs 32-bit single)","text":"<ul> <li>none</li> </ul>"},{"location":"reference/encoding_space_report/#major-opcode-occupancy-summary","title":"Major Opcode Occupancy (summary)","text":""},{"location":"reference/encoding_space_report/#c16-major50","title":"C16-major[5:0]","text":"<ul> <li>width_bits: 16</li> <li>major bits: [5:0] (6b)</li> <li>covered slots: 17/64</li> <li>patterns not fully constraining major bits: 2</li> <li>used slot indices: 0x00, 0x06, 0x08, 0x0a, 0x0c, 0x16, 0x18, 0x1a, 0x1c, 0x26, 0x28, 0x2a, 0x2c, 0x36, 0x38, 0x3a, 0x3c</li> <li>unused slot indices: 0x01..0x05, 0x07, 0x09, 0x0b, 0x0d..0x15, 0x17, 0x19, 0x1b, 0x1d..0x25, 0x27, 0x29, 0x2b, 0x2d..0x35, 0x37, 0x39, 0x3b, 0x3d..0x3f</li> </ul>"},{"location":"reference/encoding_space_report/#lx32-major60","title":"LX32-major[6:0]","text":"<ul> <li>width_bits: 32</li> <li>major bits: [6:0] (7b)</li> <li>covered slots: 41/128</li> <li>patterns not fully constraining major bits: 1</li> <li>used slot indices: 0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x11, 0x13, 0x15, 0x17, 0x19, 0x21, 0x23, 0x25, 0x27, 0x29, 0x2b, 0x31, 0x33, 0x35, 0x37, 0x39, 0x3b, 0x41, 0x43, 0x45, 0x47, 0x49, 0x4b, 0x55, 0x57, 0x59, 0x5b, 0x65, 0x67, 0x69, 0x6b, 0x75, 0x77, 0x7b, 0x7f</li> <li>unused slot indices: 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c..0x10, 0x12, 0x14, 0x16, 0x18, 0x1a..0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c..0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c..0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c..0x54, 0x56, 0x58, 0x5a, 0x5c..0x64, 0x66, 0x68, 0x6a, 0x6c..0x74, 0x76, 0x78..0x7a, 0x7c..0x7e</li> </ul>"},{"location":"reference/encoding_space_report/#hl48-major19171630","title":"HL48-major[19:17,16,3:0]","text":"<ul> <li>width_bits: 48</li> <li>major bits: [19:17],[16],[3:0] (8b)</li> <li>covered slots: 6/256</li> <li>patterns not fully constraining major bits: 1</li> <li>used slot indices: 0x1e, 0x5e, 0x7e, 0x9e, 0xbe, 0xde</li> <li>unused slot indices: 0x00..0x1d, 0x1f..0x5d, 0x5f..0x7d, 0x7f..0x9d, 0x9f..0xbd, 0xbf..0xdd, 0xdf..0xff</li> </ul>"},{"location":"reference/encoding_space_report/#16-bit-exhaustive-coverage","title":"16-bit Exhaustive Coverage","text":"<ul> <li>unmatched encodings (holes): 42572</li> <li>multiply-matched encodings (conflicts): 0</li> <li>hole ranges: 22964</li> </ul>"},{"location":"reference/encoding_space_report/#largest-16-bit-hole-ranges","title":"Largest 16-bit hole ranges","text":"<ul> <li><code>0xffeb..0xfff1</code> (count=7)</li> <li><code>0xffdb..0xffe1</code> (count=7)</li> <li><code>0xffab..0xffb1</code> (count=7)</li> <li><code>0xff9b..0xffa1</code> (count=7)</li> <li><code>0xff6b..0xff71</code> (count=7)</li> <li><code>0xff5b..0xff61</code> (count=7)</li> <li><code>0xff2b..0xff31</code> (count=7)</li> <li><code>0xff1b..0xff21</code> (count=7)</li> <li><code>0xfeeb..0xfef1</code> (count=7)</li> <li><code>0xfedb..0xfee1</code> (count=7)</li> <li><code>0xfeab..0xfeb1</code> (count=7)</li> <li><code>0xfe9b..0xfea1</code> (count=7)</li> <li><code>0xfe6b..0xfe71</code> (count=7)</li> <li><code>0xfe5b..0xfe61</code> (count=7)</li> <li><code>0xfe2b..0xfe31</code> (count=7)</li> <li><code>0xfe1b..0xfe21</code> (count=7)</li> <li><code>0xfdeb..0xfdf1</code> (count=7)</li> <li><code>0xfddb..0xfde1</code> (count=7)</li> <li><code>0xfdab..0xfdb1</code> (count=7)</li> <li><code>0xfd9b..0xfda1</code> (count=7)</li> <li><code>0xfd6b..0xfd71</code> (count=7)</li> <li><code>0xfd5b..0xfd61</code> (count=7)</li> <li><code>0xfd2b..0xfd31</code> (count=7)</li> <li><code>0xfd1b..0xfd21</code> (count=7)</li> <li><code>0xfceb..0xfcf1</code> (count=7)</li> </ul>"},{"location":"reference/encoding_space_report/#status","title":"Status","text":"<ul> <li>OK: no encoding conflicts detected</li> </ul>"},{"location":"reference/linxisa-assembly-agent-guide/","title":"LinxISA Assembly Agent Guide","text":"<p>This guide is the canonical agent-facing reference for writing LinxISA assembly in libc/runtime bring-up work.</p>"},{"location":"reference/linxisa-assembly-agent-guide/#1-scalar-abi-linx64-linux-userspace","title":"1) Scalar ABI (linx64 Linux userspace)","text":"<p>Source of truth:</p> <ul> <li><code>${LINUX_ROOT}/Documentation/linxisa/abi.md</code></li> </ul> <p>Register contract:</p> <ul> <li><code>R0</code> = <code>zero</code> (constant 0)</li> <li><code>R1</code> = <code>sp</code></li> <li><code>R2..R9</code> = <code>a0..a7</code> (arguments/return + syscall args)</li> <li><code>R10</code> = <code>ra</code></li> <li><code>R11..R19</code> = <code>s0..s8</code> (callee-saved)</li> <li><code>R20..R23</code> = <code>x0..x3</code> (caller scratch)</li> </ul> <p>Calling convention:</p> <ul> <li>Integer/pointer return: <code>a0</code></li> <li>Integer/pointer args: <code>a0..a7</code>, then stack</li> <li>Callee-saved: <code>s0..s8</code> and <code>sp</code></li> <li>Caller-saved: <code>a*</code>, <code>ra</code>, <code>x0..x3</code></li> <li>Stack alignment: 16 bytes</li> </ul> <p>Thread pointer:</p> <ul> <li>TLS base is modeled in SSR <code>0x0000</code> (<code>TP</code>) and accessed through <code>ssrget/ssrset</code>.</li> </ul>"},{"location":"reference/linxisa-assembly-agent-guide/#2-block-structured-control-flow-rules","title":"2) Block-Structured Control Flow Rules","text":"<p>Linx is block-structured; control flow must target legal block boundaries.</p> <p>Required patterns:</p> <ul> <li>Use <code>BSTART ...</code> / <code>BSTOP</code> or <code>C.BSTART ...</code> / <code>C.BSTOP</code> around control-flow regions.</li> <li>Use direct block branches for static labels: <code>C.BSTART DIRECT, &lt;label&gt;</code>.</li> <li>Use conditional block branches with <code>SETC</code> predicate in the same block:</li> <li><code>C.BSTART COND, &lt;label&gt;</code></li> <li><code>setc.&lt;cond&gt; ...</code></li> <li><code>C.BSTOP</code></li> <li>Use indirect block transfer via target register:</li> <li><code>C.BSTART IND</code></li> <li><code>setc.tgt &lt;reg&gt;</code></li> <li><code>C.BSTOP</code></li> </ul> <p>Practical rule:</p> <ul> <li>Do not emit ad-hoc fallthrough/jump mixes that bypass block enter/exit markers.</li> </ul>"},{"location":"reference/linxisa-assembly-agent-guide/#3-precise-callret-contract-mandatory","title":"3) Precise Call/Ret Contract (Mandatory)","text":"<p>Normal function form:</p> <ul> <li>Use <code>FENTRY</code> at function entry.</li> <li>Use <code>FRET.STK</code> for normal returns.</li> <li>Canonical pair is <code>FENTRY + FRET.STK</code>.</li> </ul> <p>Tail-call form:</p> <ul> <li>Tail-call functions still enter with <code>FENTRY</code>.</li> <li>Use <code>FEXIT</code> for tail-transfer exit.</li> <li>Canonical tail pair is <code>FENTRY + FEXIT</code>, then block-legal transfer to callee.</li> </ul> <p><code>RET/IND/ICALL</code> target setup:</p> <ul> <li><code>BSTART.RET</code> requires <code>setc.tgt</code> to define target source.</li> <li>Canonical return block is:</li> <li><code>C.BSTART.RET</code></li> <li><code>c.setc.tgt ra</code></li> <li><code>C.BSTOP</code></li> <li><code>IND</code> and <code>ICALL</code> blocks also require explicit <code>setc.tgt</code> in the same block.</li> </ul> <p>Fused call header (returning calls):</p> <ul> <li><code>CALL</code> is emitted as fused header pair:</li> <li><code>BSTART.CALL</code></li> <li>immediate adjacent <code>C.SETRET</code> (or <code>SETRET</code> in non-compressed form)</li> <li>No instruction may appear between <code>BSTART.CALL</code> and <code>SETRET/C.SETRET</code>.</li> <li><code>SETRET</code> defines an explicit return block label (<code>ra</code> target); do not assume return is lexical fall-through.</li> </ul> <p>Non-fallthrough return example:</p> <pre><code>BSTART.STD CALL, callee\nsetret .Lresume, -&gt;ra\n... call block body ...\nC.BSTOP\n\n... other blocks ...\n\n.Lresume:\nC.BSTART.STD\n</code></pre> <p>Setret width guidance:</p> <ul> <li>Prefer smallest legal form (<code>c.setret</code>, then <code>setret</code>).</li> <li>Use <code>hl.setret</code> when target range/layout cannot be encoded by smaller forms.</li> <li><code>hl.setret</code> is part of normal correctness/relaxation support, not a special-case extension.</li> </ul> <p>Non-returning call form:</p> <ul> <li><code>BSTART.CALL</code> without <code>SETRET</code> is valid only for non-returning transfer paths.</li> <li>In this form, <code>ra</code> is preserved; any eventual return must still satisfy dynamic target safety.</li> </ul>"},{"location":"reference/linxisa-assembly-agent-guide/#4-linux-syscall-template","title":"4) Linux Syscall Template","text":"<p>Linx Linux userspace syscall ABI:</p> <ul> <li>Syscall number in <code>a7</code></li> <li>Args in <code>a0..a5</code></li> <li>Trap with <code>acrc 1</code></li> <li>Return in <code>a0</code> (<code>&lt;0</code> means <code>-errno</code>)</li> </ul> <p>Reference template:</p> <pre><code>C.BSTART.STD\nc.movr  &lt;arg0&gt;, -&gt;a0\nc.movr  &lt;arg1&gt;, -&gt;a1\nc.movr  &lt;arg2&gt;, -&gt;a2\nc.movr  &lt;arg3&gt;, -&gt;a3\nc.movr  &lt;arg4&gt;, -&gt;a4\nc.movr  &lt;arg5&gt;, -&gt;a5\nc.movr  &lt;nr&gt;,   -&gt;a7\nacrc 1\nC.BSTART.STD RET\n</code></pre> <p>Notes:</p> <ul> <li>Keep <code>\"memory\"</code> clobber for inline-asm syscall helpers.</li> <li>Use <code>__syscall_ret</code> when libc API needs errno canonicalization.</li> </ul>"},{"location":"reference/linxisa-assembly-agent-guide/#5-setjmp-sigsetjmp-longjmp-invariants","title":"5) setjmp / sigsetjmp / longjmp Invariants","text":"<p>Linx64 jmp ABI save set:</p> <ul> <li><code>s0..s8</code>, <code>sp</code>, <code>ra</code> (11 slots total)</li> </ul> <p>Rules:</p> <ul> <li><code>setjmp</code> stores exactly the call-preserved set above.</li> <li><code>longjmp</code> restores exactly that set and returns with:</li> <li><code>ret = val</code> if <code>val != 0</code></li> <li><code>ret = 1</code> if <code>val == 0</code> (C standard)</li> <li><code>sigsetjmp(env, savemask)</code>:</li> <li><code>savemask == 0</code> behaves like plain <code>setjmp</code></li> <li><code>savemask != 0</code> must route through <code>__sigsetjmp_tail</code> so mask save/restore is symmetric across <code>siglongjmp</code>.</li> </ul>"},{"location":"reference/linxisa-assembly-agent-guide/#6-signal-restorer-protocol-rt_sigreturn","title":"6) Signal Restorer Protocol (<code>rt_sigreturn</code>)","text":"<p>Linux contract:</p> <ul> <li>Userspace restorer symbol (<code>__restore_rt</code>) must issue <code>rt_sigreturn</code> syscall (<code>a7=139</code>, <code>acrc 1</code>).</li> <li><code>SA_RESTORER</code> (<code>0x04000000</code>) must be available in userspace signal ABI.</li> </ul> <p>Kernel side reference:</p> <ul> <li><code>${LINUX_ROOT}/arch/linx/kernel/signal.c</code></li> </ul> <p>Userspace requirements:</p> <ul> <li><code>__restore</code> / <code>__restore_rt</code> must be arch implementations (no-op fallback is invalid for full Linux signal ABI).</li> </ul>"},{"location":"reference/linxisa-assembly-agent-guide/#7-unwind-and-cfi-policy","title":"7) Unwind and CFI Policy","text":"<p>Policy for bring-up parity:</p> <ul> <li>Preserve ABI-stable frame behavior in hand-written asm:</li> <li>keep <code>sp</code> 16-byte aligned at call boundaries</li> <li>preserve/restore callee-saved set exactly</li> <li>For stubs that intentionally do not unwind through normal return paths (<code>__restore_rt</code>, <code>__unmapself</code>, <code>exit</code> paths), treat them as noreturn terminal stubs.</li> <li>Avoid synthetic register save layouts that diverge from ABI docs; <code>setjmp</code>/context save structs must match exported headers.</li> </ul>"},{"location":"reference/linxisa-assembly-agent-guide/#8-linux-context-switch-trap-patterns-to-mirror","title":"8) Linux Context-Switch / Trap Patterns to Mirror","text":"<p>Primary references:</p> <ul> <li><code>${LINUX_ROOT}/arch/linx/kernel/switch_to.S</code></li> <li><code>${LINUX_ROOT}/arch/linx/kernel/entry.S</code></li> <li><code>${LINUX_ROOT}/arch/linx/kernel/signal.c</code></li> </ul> <p>Patterns to reuse in userspace arch asm:</p> <ul> <li>Save/restore order for callee-saved state (<code>s0..s8</code>, <code>sp</code>, <code>ra</code>) is stable and explicit.</li> <li>Trap/return flow uses SSR snapshots and restores the exact interrupted context.</li> <li>Signal frame setup/restore expects userspace restorer + aligned frame.</li> </ul> <p>Agent checklist before submitting asm:</p> <ol> <li>Are block markers legal and balanced?</li> <li>Are returning <code>CALL</code> headers fused (<code>BSTART.CALL</code> + adjacent <code>SETRET/C.SETRET</code>), and non-returning calls explicitly intentional?</li> <li>Do all <code>RET/IND/ICALL</code> blocks set target via <code>setc.tgt</code>?</li> <li>Is ABI save/restore set minimal and correct?</li> <li>Does syscall path use <code>a7 + acrc 1</code>?</li> <li>Are signal restorer and <code>SA_RESTORER</code> wired?</li> <li>Does <code>longjmp</code> normalize <code>0 -&gt; 1</code>?</li> <li>Are context structs consistent with Linux UAPI headers?</li> </ol>"},{"location":"reference/linxisa-call-ret-contract/","title":"LinxISA Precise Call/Ret Contract (linx64)","text":"<p>This document is normative for compiler, emulator, runtime, and Linux cross-check work.</p>"},{"location":"reference/linxisa-call-ret-contract/#1-function-entryexit-forms","title":"1) Function Entry/Exit Forms","text":"<p>Normal function path:</p> <ul> <li>Entry must use <code>FENTRY</code>.</li> <li>Return must use <code>FRET.STK</code>.</li> <li>Canonical form is <code>FENTRY ... FRET.STK</code>.</li> </ul> <p>Tail-transfer path:</p> <ul> <li>Entry still uses <code>FENTRY</code>.</li> <li>Tail exit uses <code>FEXIT</code>.</li> <li>Control transfer after <code>FEXIT</code> must be block-legal (direct or indirect block transfer).</li> <li>Canonical form is <code>FENTRY ... FEXIT</code>.</li> </ul> <p><code>FRET.RA</code> is valid when return target is consumed from pre-restore <code>ra</code> by design, but standard C ABI returns use <code>FRET.STK</code>.</p>"},{"location":"reference/linxisa-call-ret-contract/#2-return-target-semantics","title":"2) Return-Target Semantics","text":"<ul> <li><code>FRET.STK</code>: return target comes from restored <code>ra</code> state loaded from the frame.</li> <li><code>FRET.RA</code>: return target comes from <code>ra</code> before stack-restore return resolution.</li> <li><code>BSTART.RET</code> blocks must include explicit target setup:</li> <li><code>setc.tgt &lt;src&gt;</code> where <code>&lt;src&gt;</code> resolves to <code>ra</code> for normal returns.</li> </ul> <p>Required <code>RET</code> block form:</p> <pre><code>C.BSTART.RET\nc.setc.tgt ra\nC.BSTOP\n</code></pre>"},{"location":"reference/linxisa-call-ret-contract/#3-call-header-contract","title":"3) Call Header Contract","text":"<p>Returning call headers are architecturally fused:</p> <ul> <li><code>BSTART.CALL + C.SETRET</code> for compressed/direct call headers.</li> <li><code>BSTART.CALL + SETRET</code> for non-compressed forms.</li> </ul> <p>Adjacency rule for returning calls:</p> <ul> <li><code>SETRET/C.SETRET</code> must be immediately adjacent to the corresponding <code>BSTART.CALL</code>.</li> <li>No instruction may be scheduled between call-header and setret materialization.</li> <li>Return target is the explicit label encoded by <code>setret</code>, not the lexical fall-through.</li> </ul> <p>Non-returning call headers:</p> <ul> <li><code>BSTART.CALL</code> without <code>SETRET</code> is valid only for non-returning control transfer paths.</li> <li>In this form, <code>ra</code> is preserved (no implicit return-target rewrite).</li> <li>If control eventually returns and the dynamic target is not a legal block start, dynamic target safety checks must fault.</li> </ul> <p>Required fused form:</p> <pre><code>BSTART.CALL, callee\nc.setret .Lret, -&gt;ra\n</code></pre> <p>Non-fallthrough return form is valid and common:</p> <pre><code>BSTART.CALL, callee\nsetret .Ljoin, -&gt;ra\n... call block body ...\nC.BSTOP\n\n... unrelated blocks ...\n\n.Ljoin:\nC.BSTART.STD\n</code></pre> <p>Setret width selection:</p> <ul> <li><code>c.setret</code>: short forward range only.</li> <li><code>setret</code>: larger forward range only.</li> <li><code>hl.setret</code>: wide signed range (forward/backward); required when smaller forms cannot encode the return label.</li> </ul>"},{"location":"reference/linxisa-call-ret-contract/#4-indirect-target-setup-rules","title":"4) Indirect Target Setup Rules","text":"<p>Before any <code>RET</code>, <code>IND</code>, or <code>ICALL</code> block transfer, a <code>setc.tgt</code> must define the dynamic target register source in the same block.</p> <p>Non-conforming sequences (<code>setc.tgt</code> missing, or non-adjacent <code>SETRET</code> in returning call headers) are contract violations and must trap in strict mode.</p>"},{"location":"reference/linxisa-call-ret-contract/#5-dynamic-target-safety-rule","title":"5) Dynamic Target Safety Rule","text":"<p>Dynamic control-flow targets from <code>RET</code>/<code>IND</code>/<code>ICALL</code> must resolve to legal block start markers (<code>BSTART*</code>, <code>C.BSTART*</code>, template block starts like <code>FENTRY/FEXIT/FRET.*</code>). Non-block targets must fault.</p>"},{"location":"reference/linxisa-call-ret-contract/#6-cross-stack-validation-anchors","title":"6) Cross-Stack Validation Anchors","text":"<p>Cross-check against Linux Linx implementation patterns:</p> <ul> <li><code>${LINUX_ROOT}/arch/linx/kernel/switch_to.S</code></li> <li><code>${LINUX_ROOT}/arch/linx/kernel/entry.S</code></li> </ul> <p>These files are treated as authoritative reference behavior for return-target setup and call/return block sequencing.</p>"},{"location":"reference/examples/","title":"Examples","text":"<p>Canonical LinxISA sample pack:</p> <ul> <li><code>docs/reference/examples/v0.3/</code></li> </ul> <p>This location is canonical in v0.4 and no longer redirects to <code>examples/</code>.</p>"},{"location":"reference/examples/v0.3/","title":"LinxISA Assembly Sample Pack (v0.3)","text":"<p>Canonical public assembly examples for LinxISA v0.3.</p>"},{"location":"reference/examples/v0.3/#layout","title":"Layout","text":"<ul> <li><code>curated/</code>: reviewed hand-curated examples.</li> <li><code>scratch-legacy/</code>: selected migrated scratch assembly (public allowlist).</li> <li><code>generated/</code>: deterministic outputs generated from PTO examples.</li> <li><code>legacy-reference/</code>: moved historical reference examples.</li> <li><code>index.yaml</code>: manifest with provenance and generation commands.</li> </ul>"},{"location":"reference/examples/v0.3/#canonical-example","title":"Canonical Example","text":"<pre><code>BSTART.TMA   TLOAD, FP16\nB.ARG        ND2ZN.normal, FP16, Null\nB.IOTI       [], last -&gt;t&lt;4KB&gt;\nB.IOR        [x2,a6],[]\nC.B.DIMI     64, -&gt;lb0\nC.B.DIMI     64, -&gt;lb1\nC.B.DIMI     64, -&gt;lb2\n</code></pre> <p>Source: <code>docs/reference/examples/v0.3/curated/linxisa-v0.3-normalized.asm</code></p>"},{"location":"releases/v0.3.0/","title":"LinxISA v0.3.0","text":""},{"location":"releases/v0.3.0/#public-refactor","title":"Public Refactor","text":"<ul> <li>Refactored repository layout to canonical <code>spec/</code>, <code>impl/</code>, and <code>examples/</code> roots.</li> <li>Migrated legacy top-level paths to canonical locations with one-release compatibility shims.</li> <li>Removed v0.1/v0.2 operational ISA artifacts from the public tree.</li> <li>For the current layout, see <code>docs/project/navigation.md</code>.</li> </ul>"},{"location":"releases/v0.3.0/#specification-and-tooling","title":"Specification and Tooling","text":"<ul> <li>Enforced v0.3-only defaults across ISA generators and validators.</li> <li>Updated regression flow to canonical paths and optional cross-repo legacy scan mode.</li> <li>Added CI guard workflow for removed legacy catalog dependencies.</li> </ul>"},{"location":"releases/v0.3.0/#sample-pack","title":"Sample Pack","text":"<ul> <li>Added canonical assembly sample pack at <code>examples/assembly/v0.3/</code>.</li> <li>Included curated, generated (PTO), and migrated scratch-legacy subsets.</li> <li>Added provenance manifest: <code>examples/assembly/v0.3/index.yaml</code>.</li> </ul>"},{"location":"releases/v0.3.0/#documentation","title":"Documentation","text":"<ul> <li>Rewrote root README for public v0.3 positioning.</li> <li>Added v0.3 architecture contract: <code>docs/architecture/v0.3-architecture-contract.md</code>.</li> <li>Regenerated ISA manual derived sections against canonical v0.3 catalog.</li> </ul>"},{"location":"releases/v0.3.0/#release-assets","title":"Release Assets","text":"<ul> <li><code>linxisa-isa-manual-v0.3.0.pdf</code></li> <li><code>linxisa-isa-manual-v0.3.0.pdf.sha256</code></li> </ul>"}]}